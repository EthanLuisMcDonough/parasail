// ParaSail Prototype Standard Library

// Copyright (C) 2011-2015, AdaCore, New York, NY
// This program is provided "as is" with no warranty.
// Report errors at http://groups.google.com/group/parasail-programming-language

interface PSL<> is
end interface PSL

interface PSL::Core<> is
end interface PSL::Core

interface PSL::Containers<> is
end interface PSL::Containers

interface PSL::Test<> is
end interface PSL::Test

abstract interface PSL::Core::Any<> is
end interface PSL::Core::Any

abstract interface PSL::Core::Assignable<> is
end interface PSL::Core::Assignable
interface PSL::Core::Boolean<> is
    op "from_univ"(Lit : Univ_Enumeration) 
      {*"Must be #true or #false"* Lit in [#false, #true]}
      -> Boolean is import(#bool_from_univ)

    op "to_univ"(Val : Boolean) -> Univ_Enumeration 
      is import(#bool_to_univ)

    op "=?"(Left, Right : Boolean) -> Ordering
      is import("=?")
        // NOTE: #true > #false

    func Strict_Compare(Left, Right : Boolean) -> Ordered::Full_Ordering
      is import("=?")

    op "not"(Boolean) -> Boolean is import("not")
    op "and"(Left, Right : Boolean) -> Boolean is import("and")
    op "or"(Left, Right : Boolean) -> Boolean is import("or")
    op "xor"(Left, Right : Boolean) -> Boolean is import("xor")

    op "and="(var Left : Boolean; Right : Boolean)
    op "or="(var Left : Boolean; Right : Boolean)
    op "xor="(var Left : Boolean; Right : Boolean)

    func Hash(Val : Boolean) -> Unsigned_64
      is import(#identity)

    // For Imageable
    func To_String(Val : optional Boolean) -> Univ_String
    func From_String(Str : Univ_String) -> optional Boolean

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Boolean) -> Boolean 
      is import("+")
    op "+"(Left : Boolean; Right : Univ_Integer) -> Boolean 
      is import("+")
    op "-"(Left, Right : Boolean) -> Univ_Integer 
      is import("-")
    op "-"(Left : Boolean; Right : Univ_Integer) -> Boolean 
      is import("-")
    op "+="(var Left : Boolean; Right : Univ_Integer)
      is import("+=");
    op "-="(var Left : Boolean; Right : Univ_Integer)
      is import("-=");

    func Min(Left, Right : optional Boolean) -> optional Boolean
      is import(#min)
    func Max(Left, Right : optional Boolean) -> optional Boolean
      is import(#max)

    // TBD: These should be properties some day (e.g. Boolean#first).
    func First()->Boolean
    func Last()->Boolean

    op ".."(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "<.."(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "..<"(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "<..<"(Left, Right : Boolean) -> Countable_Set<Boolean>
    op "|"(Left, Right : Boolean) -> Countable_Set<Boolean>
end interface PSL::Core::Boolean

interface PSL::Core::Ordering<> is
  // Enumeration type used to represent value of "=?" operator
    op "from_univ"(Lit : Univ_Enumeration) 
      {*"Literal not defined for Ordering"*
       Lit in [#less, #equal, #greater, #unordered]}
      -> Ordering is import(#ordering_from_univ)

    op "to_univ"(Val : Ordering) -> Univ_Enumeration 
      is import(#ordering_to_univ)

    op "to_bool"(Ord : Ordering; Mask : Univ_Integer) -> Boolean 
      is import(#ordering_to_bool)

    op "=?"(Left, Right : Ordering) -> Ordering is import("=?")
    func Strict_Compare(Left, Right : Ordering)
      -> Ordered::Full_Ordering is import("=?")

    func Hash(Val : Ordering) -> Unsigned_64
      is import(#identity)

    // For Imageable
    func To_String(Val : Ordering) -> Univ_String
    func From_String(Str : Univ_String) -> optional Ordering

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Ordering) -> Ordering 
      is import("+")
    op "+"(Left : Ordering; Right : Univ_Integer) -> Ordering 
      is import("+")
    op "-"(Left, Right : Ordering) -> Univ_Integer 
      is import("-")
    op "-"(Left : Ordering; Right : Univ_Integer) -> Ordering 
      is import("-")
    op "+="(var Left : Ordering; Right : Univ_Integer)
      is import("+=");
    op "-="(var Left : Ordering; Right : Univ_Integer)
      is import("-=");

    func Min(Left, Right : optional Ordering) -> optional Ordering
      is import(#min)
    func Max(Left, Right : optional Ordering) -> optional Ordering
      is import(#max)

    // TBD: These should be properties some day (e.g. Ordering#first).
    func First()->Ordering
    func Last()->Ordering

    op ".."(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "<.."(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "..<"(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "<..<"(Left, Right : Ordering) -> Countable_Set<Ordering>
    op "|"(Left, Right : Ordering) -> Countable_Set<Ordering>
end interface PSL::Core::Ordering

abstract interface PSL::Core::Comparable<> implements Assignable<> is
    op "=?"(Left, Right : Comparable) -> Ordering
end interface PSL::Core::Comparable

abstract interface PSL::Core::Ordered<> implements Comparable<> is
  // An Ordered type provides a Strict_Compare operation in addition
  // to a "=?" operator.  The Strict_Compare operation never returns
  // #unordered.

    type Full_Ordering is Ordering
      // {Full_Ordering in #less | #equal | #greater}

    op "=?"(Left, Right : Ordered) -> Ordering;

    func Strict_Compare(Left, Right : Ordered) -> Ordered::Full_Ordering
      {Strict_Compare != #unordered};
end interface PSL::Core::Ordered

class PSL::Core::Boolean is
    type Boolean_Set is Countable_Set<Boolean>

  exports
    op "and="(var Left : Boolean; Right : Boolean) is
        Left := Left and Right
    end op "and="

    op "or="(var Left : Boolean; Right : Boolean) is
        Left := Left or Right
    end op "or="

    op "xor="(var Left : Boolean; Right : Boolean) is
        Left := Left xor Right
    end op "xor="

    func To_String(Val : optional Boolean) -> Univ_String is
        if Val is null then
            return "null"
        elsif Val then
            return "#true"
        else
            return "#false"
        end if
    end func To_String

    func From_String(Str : Univ_String) -> optional Boolean is
        if Str == "#true" then
            return #true
        elsif Str == "#false" then
            return #false
        else
            return null
        end if
    end func From_String

    func First()->Boolean is
        return #false
    end func First

    func Last()->Boolean is
        return #true
    end func Last

    // NOTE: For implementation reasons, we put these here rather than defining
    //       them in the interface using "is in Countable_Set<Boolean>"
    op ".."(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::".."(Left, Right)
    end op ".."

    op "<.."(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"<.."(Left, Right)
    end op "<.."

    op "..<"(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"..<"(Left, Right)
    end op "..<"
    op "<..<"(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"<..<"(Left, Right)
    end op "<..<"

    op "|"(Left, Right : Boolean) -> Countable_Set<Boolean> is
        return Boolean_Set::"|"(Left, Right)
    end op "|"
end class PSL::Core::Boolean

func PSL::Test::Test_Boolean(UX, UY : Univ_Enumeration) is
    const X : Boolean := UX
    const Y : Boolean := UY

    Println("not " | X | " = " | (not X))
    if X != Y then
       Println("not " | Y | " = " | (not Y))
    end if
    Println(X | " and " | Y | " = " | (X and Y))
    Println(X | " or " | Y | " = " | (X or Y))
    Println(X | " xor " | Y | " = " | (X xor Y))

    var XX := X
    XX and= Y
    Println(X | " and= " | Y | " = " | XX)
    XX := X
    XX or= Y
    Println(X | " or= " | Y | " = " | XX)
    XX := X
    XX xor= Y
    Println(X | " xor= " | Y | " = " | XX)
end func PSL::Test::Test_Boolean

//  Streaming in ParaSail is a three layer cake:
//    Byte Stream is the lowest layer
//    Value Stream is the middle layer
//    Object Stream is the top layer
//
//  This is the Value stream layer.
//  A value stream abstracts away the byte representation of any given
//  value, where a value could be a number or a string, possibly optional,
//  and possibly surrounded by syntax to indicate that the value is part of
//  a larger composite object, such as a sequence or a map, or
//  an object of some user-defined type.
//
//  A value stream could be in binary, or in some textual form such as
//  JSON or XML.  A binary value stream generally has no need for extra
//  indicators of the start or finish of, for example, a sequence or a
//  map.  A textual form generally will need some sort of extra
//  syntax.  Each kind of value stream provides its own way of indicating
//  the begin or end of a sequence, a map (i.e. a dictionary), an object,
//  or a "polymorphic" object, where the type name itself is encoded within
//  the value stream.  The operations which emit this syntax (if any)
//  are Begin/End_Seq, Begin/End_Map, Begin/End_Object, and Begin/End_Poly.
//
abstract ref interface PSL::Core::Output_Value_Stream<> is
   //  A stream for emitting values, typically built on top of an
   //  output byte stream.
   type Univ_Float is Univ_Real;

   func Is_Self_Describing (Output_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.
     //  If true, it also requires that the Key of each Key/Value
     //  pair of a Map is required to be a string, and written/read using
     //  {Write,Read}_String.  The actual key could be of any type with
     //  appropriate {To,From}_String routines, but those conversions
     //  must be performed in the higher level code.

   func Reached_End(Output_Value_Stream) -> Boolean;

   func Write_Int (var Output_Value_Stream; Val : Univ_Integer;
      Low, High : Univ_Integer) {Val in Low .. High};
   func Write_Optional_Int
     (var Output_Value_Stream; Val : optional Univ_Integer;
      Low, High : Univ_Integer);

   func Write_Float (var Output_Value_Stream; Val : Univ_Float;
      Digits : Univ_Integer);
   func Write_Optional_Float
     (var Output_Value_Stream; Val : optional Univ_Float;
      Digits : Univ_Integer);

   func Write_String (var Output_Value_Stream; Val : Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
      {Min_Len >= 0 and then |Val| in Min_Len .. Max_Len};
   func Write_Optional_String
     (var Output_Value_Stream; Val : optional Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer);

   const Unknown_Actual_Len : Univ_Integer := -1;

   func Write_Begin_Seq (var Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer);
   func Write_Begin_Optional_Seq (var Output_Value_Stream;
      Min_Len, Max_Len : Univ_Integer; Actual_Len : optional Univ_Integer);
   //  A "Seq" in a value stream is represented by a sequences of values.
   //  If the value stream is "self describing" then the actual length
   //  need not be specified, and may be -1, indicating an unknown length.
   //  If the value stream is *not* self describing, then the length
   //  must be given in the Begin_Seq, or a special end-seq indicator
   //  must be written by End_Seq so that More_Seq_Elements can indicate
   //  whether or not there are more elements.
   //  A sequence that is a "null" value (not the same thing as a
   //  zero-length sequence) is produced by calling Write_Begin_Optional_Seq
   //  with the Actual_Len parameter being null.

   func Write_End_Seq (var Output_Value_Stream);
   //  Write out the end-seq indicator (if any).

   func Write_Begin_Map (var Output_Value_Stream);
   func Write_Begin_Optional_Map (var Output_Value_Stream;
      Is_Null : Boolean);
   //  A "Map" in a value stream is represented as a set of key/value
   //  pairs.  If the value stream is "self describing" then
   //  the keys are required to be strings.  The higher-level code is free
   //  to use To_String/From_String to support maps with non-string keys.
   //  In general the order of the key/value pairs is *not*
   //  significant, and reading a Map in from a stream and then writing
   //  it back out is *not* guaranteed to produce the same order
   //  of Key/Value pairs.

   func Write_End_Map (var Output_Value_Stream);

   func Write_Begin_Poly (var Output_Value_Stream; Type_Name : Univ_String);
   func Write_Begin_Optional_Poly (var Output_Value_Stream;
      Type_Name : optional Univ_String);
   //  A polymorphic object in a value stream is represented by
   //  a type name as a string, followed by the value produced by
   //  the appropriate Write_* routine.  If the Type_Name is null, the
   //  object is presumed to be the null value.
   //  On input, the Type_Name should be used to decide what kind of
   //  value to expect, and call the corresponding Read_* routine.
   func Write_End_Poly (var Output_Value_Stream);

   func Write_Begin_Obj (var Output_Value_Stream);
   func Write_Begin_Optional_Obj (var Output_Value_Stream;
      Is_Null : Boolean);
   //  An arbitrary (non-polymorphic) ParaSail object is represented
   //  in the value stream by its components, followed by an end-of-obj
   //  indicator.

   func Write_End_Obj (var Output_Value_Stream);
   //  Write an end-of-obj indicator.
end interface PSL::Core::Output_Value_Stream;

abstract ref interface PSL::Core::Input_Value_Stream<> is
   //  A stream for reading in values, typically on top of
   //  a input byte stream.
   type Univ_Float is Univ_Real;

   func Is_Self_Describing (Input_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.
     //  If true, it also requires that the Key of each Key/Value
     //  pair of a Map is required to be a string, and written/read using
     //  {Write,Read}_String.  The actual key could be of any type with
     //  appropriate {To,From}_String routines, but those conversions
     //  must be performed in the higher level code.

   func Reached_End(Input_Value_Stream) -> Boolean;

   func Read_Int (var IVS : Input_Value_Stream;
      Low, High : Univ_Integer) -> Val : Univ_Integer
      {Val in Low .. High};

   func Read_Optional_Int
     (var Input_Value_Stream;
      Low, High : Univ_Integer) -> optional Univ_Integer;

   func Read_Float (var Input_Value_Stream;
      Digits : Univ_Integer) -> Univ_Float;
   func Read_Optional_Float
     (var Input_Value_Stream;
      Digits : Univ_Integer) -> optional Univ_Float;

   func Read_String (var Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> Univ_String;
   func Read_Optional_String
     (var Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> optional Univ_String;

   const Unknown_Actual_Len : Univ_Integer := -1;

   func Read_Begin_Seq (var Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : Univ_Integer;
   func Read_Begin_Optional_Seq (var Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer;
   //  Absorb begin-of-seq indicator and return actual length of sequence
   //  if known, or -1 if unknown, or null if the sequence is a null value.
   //  Only "self describing" value streams permit an unknown length.

   func More_Seq_Elements (var Input_Value_Stream) -> Boolean;
   //  Return #true if more sequence elements are expected.
   //  If the value stream is "self describing" then this function
   //  may "peek" ahead to determine whether more elements are present.

   func Read_End_Seq (var Input_Value_Stream);
   //  Absorb end-of-seq indicator.

   func Read_Begin_Map (var Input_Value_Stream);
   func Read_Begin_Optional_Map (var Input_Value_Stream) -> Is_Null : Boolean;

   func More_Map_Elements (var Input_Value_Stream) -> Boolean;
   //  Return #true if there are more key/value pairs in the map.

   func Read_Key_Value_Separator (var Input_Value_Stream);
   //  Skip over the separator, if any, in a Key/Value pair of a map

   func Read_End_Map (var Input_Value_Stream) -> Syntax_OK : Boolean;
   //  Absorb end-of-map indicator.
   //  Return #false if end-of-map indicator is missing.

   func Read_Begin_Poly (var Input_Value_Stream)
     -> Type_Name : Univ_String;
   func Read_Begin_Optional_Poly (var Input_Value_Stream)
     -> Type_Name : optional Univ_String;
   //  Read the type name for a polymorphic object.
   //  The caller may use the type name to determine which Read_* routine(s)
   //  to use.

   func Read_End_Poly (var Input_Value_Stream);

   func Read_Begin_Obj (var Input_Value_Stream);
   func Read_Begin_Optional_Obj (var Input_Value_Stream) -> Is_Null : Boolean;
   //  Begin reading an arbitrary (non-polymorphic) ParaSail object.

   func Read_End_Obj (var Input_Value_Stream);
   //  Absorb the end-of-obj indicator.

end interface PSL::Core::Input_Value_Stream;

//  Streaming in ParaSail is a three layer cake:
//    Byte Stream is the lowest layer
//    Value Stream is the middle layer
//    Object Stream is the top layer
//
//  This is the Object stream layer.
//  An object stream abstracts away the set of values and other syntax
//  that are used to represent a high-level object.
//  The ParaSail run-time library provides a default representation of
//  any ParaSail object.  The user can also define a "custom" representation
//  for a given type of object.  The implementation of the "custom" streaming
//  operations ("read" and "write") can use the "default" streaming operations
//  (Write_Default, Read_Default) as a fall-back, perhaps preceded or followed
//  by additional values or other syntax.
interface PSL::Core::Output_Object_Stream<> is
   ref var Val_Str : Output_Value_Stream+;

   func Create(ref var Output_Value_Stream+) -> Output_Object_Stream is
     ((Val_Str => Output_Value_Stream));

   func Reached_End(Output_Object_Stream) -> Boolean is
     ((Output_Object_Stream.Val_Str.Reached_End()));

   func Write_Obj (var Output_Object_Stream; Obj : Obj_Type is Assignable<>)
     is import (#write_obj);
   func Write_Optional_Obj
      (var Output_Object_Stream; Obj : optional Obj_Type is Assignable<>)
     is import (#write_optional_obj);

   func Write_Default
      (var Output_Object_Stream; Obj : Obj_Type is Assignable<>)
     is import (#write_default);
   func Write_Optional_Default
      (var Output_Object_Stream; Obj : optional Obj_Type is Assignable<>)
     is import (#write_optional_default);

end interface PSL::Core::Output_Object_Stream;

interface PSL::Core::Input_Object_Stream<> is

   ref var Val_Str : Input_Value_Stream+;

   func Create(ref var Input_Value_Stream+) -> Input_Object_Stream is
     ((Val_Str => Input_Value_Stream));

   func Reached_End(Input_Object_Stream) -> Boolean is
     ((Input_Object_Stream.Val_Str.Reached_End()));

   func Read_Obj (var Input_Object_Stream; var Obj : Obj_Type is Assignable<>)
     is import (#read_obj);
   func Read_Optional_Obj
      (var Input_Object_Stream; var Obj : optional Obj_Type is Assignable<>)
     is import (#read_optional_obj);

   func Read_Default
      (var Input_Object_Stream; var Obj : Obj_Type is Assignable<>)
     is import (#read_default);
   func Read_Optional_Default
      (var Input_Object_Stream; var Obj : optional Obj_Type is Assignable<>)
     is import (#read_optional_default);

end interface PSL::Core::Input_Object_Stream;

abstract interface PSL::Core::Custom_Streaming<> is
   //  Implement this interface to provide type-specific
   //  streaming operations.
   op "write" (var Output_Object_Stream;
               Obj : optional Custom_Streaming;
               Is_Optional : Boolean);
   op "read"  (var Input_Object_Stream;
               var Obj : optional Custom_Streaming;
               Is_Optional : Boolean);
end interface PSL::Core::Custom_Streaming;

interface PSL::Containers::Set<Element_Type is Hashable<>>
  implements Custom_Streaming<> is
  // A hashed-set module
    op "[]"() -> Set

    func Singleton(Elem : Element_Type) -> Set

    op "|"(Left, Right : Element_Type) -> Set
    op "|"(Left : Set; Right : Element_Type) -> Set
    op "|"(Left : Element_Type; Right : Set) -> Set
    op "|"(Left : Set; Right : Set) -> Set

    op "|="(var Left : Set; Right : Set)

    op "|="(var Left : Set; Right : Element_Type)
        // Add element to Set.

    op "<|="(var Left : Set; var Right : optional Element_Type)
        // Move element into Set.

    op "<|="(var Left : Set; var Right : Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "in"(Left : Element_Type; Right : Set) -> Boolean<>

    op "=?"(Left, Right : Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    op "or"(Left, Right : Set) -> Set is "|"  // Union
    op "or="(var Left : Set; Right : Set) is "|="

    op "+"(Left, Right : Set) -> Set is "|"   // Union
    op "+="(var Left : Set; Right : Set) is "|="
    op "+="(var Left : Set; Right : Element_Type) is "|="   // aka Include

    op "and"(Left, Right : Set) -> Set
        // Intersection
    op "and="(var Left : Set; Right : Set)

    op "xor"(Left, Right : Set) -> Set
        // Symmetric difference
    op "xor="(var Left : Set; Right : Set)

    op "-"(Left, Right : Set) -> Set
        // Set difference

    op "-="(var Left : Set; Right : Set)
        // Compute Set difference

    op "-="(var S : Set; Elem : Element_Type)   // aka Exclude
        // Remove one element, if present

    func Count(S : Set) -> Univ_Integer

    op "magnitude"(Set) -> Univ_Integer is Count

    func Is_Empty(S : Set) -> Boolean<>

    func Remove_Any(var S : Set) -> optional Element_Type
      // Remove and return an arbitrary element of the Set S

    func Any_Element(S : Set) -> optional Element_Type
      // Return an arbitrary element of the Set S;
      // return null if S is empty.

    //  Provide custom streaming operations
    op "write" (var Output_Object_Stream;
                Obj : optional Set;
                Is_Optional : Boolean);

    op "read"  (var Input_Object_Stream;
                var Obj : optional Set;
                Is_Optional : Boolean);

    optional func Dump_Statistics(S : Set)
      // A debugging routine to show bucket sizes of Set

end interface PSL::Containers::Set
interface PSL::Core::Univ_Enumeration<> is
    op "=?"(Left, Right : Univ_Enumeration) -> Ordering 
      is import(#unordered_compare)

    func To_String(Val : optional Univ_Enumeration) -> Univ_String
      is import(#to_string_enum)

    func From_String(Str : Univ_String) -> optional Univ_Enumeration
      is import(#from_string_enum)

    func Print(Val : Univ_Enumeration) 
      is import(#print_univ_enum)
    func Println(Val : Univ_Enumeration) 
      is (Println(To_String(Val)))

    func Hash(Val : Univ_Enumeration) -> Unsigned_64
      is import(#hash_enum)

    op "in"(Left : Univ_Enumeration; Right : Set<Univ_Enumeration>) 
      -> Boolean<>
      is in Set<Univ_Enumeration>

end interface PSL::Core::Univ_Enumeration

abstract interface PSL::Core::Optional<> is
    op "null"() -> Optional
    op "is null"(Optional) -> Boolean
end interface PSL::Core::Optional

class PSL::Core::Ordering is
    type Ordering_Set is Countable_Set<Ordering>

  exports
    func First()->Ordering is
        return #less
    end func First

    func Last()->Ordering is
        return #unordered
    end func Last

    func To_String(Val : Ordering) -> Univ_String is
        case Val of
          [#less] =>
            return "#less"
          [#equal] =>
            return "#equal"
          [#greater] =>
            return "#greater"
          [#unordered] =>
            return "#unordered"
        end case
    end func To_String

    func From_String(Str : Univ_String) -> optional Ordering is
        case Str of
          ["#less"] =>
            return #less
          ["#equal"] =>
            return #equal
          ["#greater"] =>
            return #greater
          ["#unordered"] =>
            return #unordered
          [..] =>
            return null
        end case
    end func From_String

    // NOTE: For implementation reasons, we put these here rather than defining
    //       them in the interface using "is in Countable_Set<Ordering>"
    op ".."(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::".."(Left, Right)
    end op ".."

    op "<.."(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"<.."(Left, Right)
    end op "<.."

    op "..<"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"..<"(Left, Right)
    end op "..<"
    op "<..<"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"<..<"(Left, Right)
    end op "<..<"

    op "|"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"|"(Left, Right)
    end op "|"
end class PSL::Core::Ordering

abstract interface PSL::Core::Hashable<> implements Comparable<> is
    // Types which aren't ordered nevertheless are often
    // hashable, which makes it possible to create an efficient
    // set or map using them as the index type.
    op "=?"(Left, Right : Hashable) -> Ordering
    func Hash(Val : Hashable) -> Unsigned_64
end interface PSL::Core::Hashable

abstract interface PSL::Core::Summable<> implements Hashable<> is
    //  Types that can be added and subtracted and provide a partial
    //  mapping from integers, as appropriate for histogramming.
    op "+"(Right : Summable) -> Summable
    op "-"(Right : Summable) -> Summable
    op "abs"(Right : Summable) -> Summable
    op "magnitude"(Summable) -> Summable is "abs"
    op "+"(Left, Right : Summable) -> Result : Summable 
    op "-"(Left, Right : Summable) -> Result : Summable
    op "*"(Left, Right : Summable) -> Result : Summable 
    op "*"(Left : Summable; Right : Univ_Integer) -> Result : Summable 
    op "*"(Left : Univ_Integer; Right : Summable) -> Result : Summable
    op "/"(Left, Right : Summable) -> Result : Summable
    op "/"(Left : Summable; Right : Univ_Integer) -> Result : Summable
    op "**"(Left : Summable; Right : Univ_Integer) -> Summable
    op "+="(var Left : Summable; Right : Summable) 
    op "-="(var Left : Summable; Right : Summable) 
    op "*="(var Left : Summable; Right : Summable) 
    op "/="(var Left : Summable; Right : Summable) 
    op "**="(var Left : Summable; Right : Univ_Integer) 
    op "=?"(Left, Right : Summable) -> Ordering
    func Strict_Compare(Left, Right : Summable) -> Ordered::Full_Ordering
    func Min(Left, Right : optional Summable) -> optional Summable
    func Max(Left, Right : optional Summable) -> optional Summable
    func Hash(Val : Summable) -> Unsigned_64
    func From_Int(Int : Univ_Integer) -> optional Summable
    func Trunc_To_Int(Val : Summable) -> Univ_Integer
    func Floor_To_Int(Val : Summable) -> Univ_Integer
    func Round_To_Int(Val : Summable) -> Univ_Integer
    func To_String(Val : optional Summable) -> Univ_String
    func From_String(Str : Univ_String) -> optional Summable
    op "in"(Left : Summable; Right : Range_Set<Summable>) -> Boolean
      is in Range_Set<Summable>
        // "in" defined in Range_Set
end interface PSL::Core::Summable

interface PSL::Containers::Countable_Set<Element_Type is Countable<>> is
    //  A set of values of a "countable" type (e.g. integer or enum),
    //  where we can efficiently represent intervals (i.e. contiguous ranges)
    //  of values of the type, allowing large sets to be handled.
    op "[]"() -> Countable_Set
    op "[..]"() -> Countable_Set

    func Singleton(Elem : Element_Type) -> Countable_Set

    op ".."(Left, Right : Element_Type) -> Countable_Set
    op "<.."(Left, Right : Element_Type) -> Countable_Set
    op "..<"(Left, Right : Element_Type) -> Countable_Set
    op "<..<"(Left, Right : Element_Type) -> Countable_Set

    op "|"(Left, Right : Element_Type) -> Countable_Set
    op "|"(Left : Countable_Set; Right : Element_Type) -> Countable_Set
    op "|"(Left : Element_Type; Right : Countable_Set) -> Countable_Set
    op "|"(Left : Countable_Set; Right : Countable_Set) -> Countable_Set

    op "|="(var Left : Countable_Set; Right : Element_Type)
    op "|="(var Left : Countable_Set; Right : Countable_Set)

    op "<|="(var Left : Countable_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Countable_Set; var Right : Countable_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Countable_Set) -> Countable_Set
      // Set difference
    op "-"(Left : Countable_Set; Right : Element_Type) -> Countable_Set
      // Remove one element
    op "-="(var S : Countable_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Countable_Set; Right : Countable_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Countable_Set; Right : Countable_Set) 
      -> Countable_Set is "|"   // union
    op "or="(var Left : Countable_Set; Right : Countable_Set) is "|="

    op "+"(Left : Countable_Set; Right : Countable_Set) 
      -> Countable_Set is "|"   // Union
    op "+="(var Left : Countable_Set; Right : Countable_Set) is "|="
    op "+="(var Left : Countable_Set; Right : Element_Type) is "|="
   
    op "and"(Left, Right : Countable_Set) -> Countable_Set
        // Intersection
    op "and="(var Left : Countable_Set; Right : Countable_Set)

    op "xor"(Left, Right : Countable_Set) -> Countable_Set
        // Symmetric difference
    op "xor="(var Left : Countable_Set; Right : Countable_Set)

    op "in"(Left : Element_Type; Right : Countable_Set) -> Boolean

    op "=?"(Left, Right : Countable_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    func Strict_Compare(Left, Right : Countable_Set) -> Ordered::Full_Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less or #greater based on a lexicographical ordering
        // Never return #unordered

    func Count(S : Countable_Set) -> Univ_Integer

    op "magnitude"(Countable_Set) -> Univ_Integer is Count

    func Is_Empty(S : Countable_Set) -> Boolean

    func First(S : Countable_Set) -> optional Element_Type
    func Last(S : Countable_Set) -> optional Element_Type
    func Any_Element(S : Countable_Set) -> optional Element_Type

    op "indexing"(S : Countable_Set; Index : Univ_Integer)
      -> optional Element_Type
         //  Return "Index"th element of set S, counting 1 .. Count(S)

    op "slicing"(S : Countable_Set; 
      Index_Set : Countable_Range<Univ_Integer>) -> Countable_Set
         //  Return subset of set S, elements S[Index_Set.First] through
         //  S[Index_Set.Last], counting 1 .. Count(S)

    op "/"(Set : Countable_Set; Num_Pieces : Univ_Integer)
      -> Vector<Countable_Set>
        // Divide a set into a vector of sets, each of similar size

    func Remove_First(var S : Countable_Set) -> optional Element_Type
        // Remove first element of set (lowest value)

    func Remove_Last(var S : Countable_Set) -> optional Element_Type
        // Remove last element of set (highest value)

    func Remove_Any(var S : Countable_Set) -> optional Element_Type
        // Remove an arbitrary element of set

    func Ranges(S : Countable_Set) ->
      Ordered_Set<Countable_Range<Element_Type>>
        // Return set of disjoint ranges that represent the set of values in S

end interface PSL::Containers::Countable_Set

abstract interface PSL::Core::Countable<> implements Ordered<> is
    op "+"(Left : Countable; Right : Univ_Integer) -> Countable
    op "+"(Left : Univ_Integer; Right : Countable) -> Countable

    op "-"(Left : Countable; Right : Univ_Integer) -> Countable
    op "-"(Left, Right : Countable) -> Univ_Integer

    op "+="(var Left : Countable; Right : Univ_Integer)
    op "-="(var Left : Countable; Right : Univ_Integer)

    op "=?"(Left, Right : Countable) -> Ordering
    func Strict_Compare(Left, Right : Countable) -> Ordered::Full_Ordering

    func First() -> Countable

    func Last() -> Countable

     // Note that Min and Max may be given null operands.
     // They each return null if both operands are null, and return the
     // non-null operand if only one of the operands is null.
     // This allows null to be used as the initial value when computing
     // the "Max" or "Min" of a possibly-empty sequence, rather than
     // having to start with the equivalent of negative or positive infinity.
    func Min(Left, Right : optional Countable) -> optional Countable
    func Max(Left, Right : optional Countable) -> optional Countable

    func Hash(Val : Countable) -> Unsigned_64

    op ".."(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "<.."(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "..<"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "<..<"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>
    op "|"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>

    //  Countable also implements Imageable
    func To_String(Val : Countable) -> Univ_String
    optional func From_String(Univ : Univ_String) -> optional Countable
end interface PSL::Core::Countable
interface PSL::Core::Univ_Integer<> is
    op "+"(Right : Univ_Integer) -> Univ_Integer
      is import(#identity)

    op "-"(Right : Univ_Integer) -> Univ_Integer
      is import(#negate)

    op "abs"(Right : Univ_Integer) -> Univ_Integer
      is import("abs")

    op "magnitude"(Univ_Integer) -> Univ_Integer is "abs"

    op "+"(Left, Right : Univ_Integer) -> Result : Univ_Integer 
      is import(#univ_add)

    op "-"(Left, Right : Univ_Integer) -> Result : Univ_Integer
      is import(#univ_subtract)

    op "*"(Left, Right : Univ_Integer) -> Result : Univ_Integer 
      is import(#univ_multiply)

    op "/"(Left, Right : Univ_Integer) -> Result : Univ_Integer
      is import(#univ_divide)

    op "**"(Left, Right : Univ_Integer) -> Univ_Integer
      is import(#univ_exp)

    op "mod"(Left, Right : Univ_Integer) -> Univ_Integer
      is import(#univ_mod)

    op "rem"(Left, Right : Univ_Integer) -> Univ_Integer
      is import(#univ_rem)


    op "+="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import(#univ_assign_add)

    op "-="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import(#univ_assign_subtract)

    op "*="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import(#univ_assign_multiply)

    op "/="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import(#univ_assign_divide)

    op "**="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import(#univ_assign_exp)


    op "=?"(Left, Right : Univ_Integer) -> Ordering
      is import(#univ_compare)

    func Strict_Compare(Left, Right : Univ_Integer) -> Ordered::Full_Ordering
      is import(#univ_compare)

    op ">>"(Univ_Integer; Univ_Integer) -> Univ_Integer
      is import(#univ_rshift)

    op "<<"(Univ_Integer; Univ_Integer) -> Univ_Integer
      is import(#univ_lshift)

    func Min(Left, Right : optional Univ_Integer) -> optional Univ_Integer
      is import(#univ_min)
    func Max(Left, Right : optional Univ_Integer) -> optional Univ_Integer
      is import(#univ_max)

    func Hash(Val : Univ_Integer) -> Unsigned_64
      is (Val mod 2**32)

    func To_String(Val : optional Univ_Integer) -> Univ_String
      is import(#to_string_univ_int)

    func From_String(Str : Univ_String) -> optional Univ_Integer
      is import(#from_string_univ_int)

    func Print(X : Univ_Integer) is import(#print_univ_int)
    func Println(X : Univ_Integer) is (Println(To_String(X)))

    func First() -> Univ_Integer is
      import(#univ_integer_first)

    func Last() -> Univ_Integer is
      import(#univ_integer_last)

    op ".."(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "<.."(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "..<"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "<..<"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>
    op "|"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>

    func GCD (A, B : Univ_Integer) -> Univ_Integer
      is import (#gcd_univ_int);

 implements for Summable

    func From_Int (Int : Univ_Integer) -> Univ_Integer is
      import(#identity)
    func Trunc_To_Int(Val : Univ_Integer) -> Univ_Integer is
      import(#identity)
    func Floor_To_Int(Val : Univ_Integer) -> Univ_Integer is
      import(#identity)
    func Round_To_Int(Val : Univ_Integer) -> Univ_Integer is
      import(#identity)

end interface PSL::Core::Univ_Integer

interface PSL::Core::Countable_Range<Bound_Type is Countable<>> is
    // Simple contiguous Countable_Range of integers (i.e. an interval)
    const First : Bound_Type
    const Last : Bound_Type
    op ".."(Left, Right : Bound_Type) -> Countable_Range
    op "<.."(Left, Right : Bound_Type) -> Countable_Range
    op "..<"(Left, Right : Bound_Type) -> Countable_Range
    op "<..<"(Left, Right : Bound_Type) -> Countable_Range
    op "in"(Val : Bound_Type; Interval : Countable_Range) -> Boolean
    func Length(R : Countable_Range) -> Univ_Integer
    op "magnitude"(Countable_Range) -> Univ_Integer is Length
    op "[..]"() -> Countable_Range
    op "[]"() -> Countable_Range
    func Singleton(Bound : Bound_Type) -> Countable_Range

    op "/"(R : Countable_Range; Num_Pieces : Univ_Integer)
      -> Vector<Countable_Range>
        // Divide a range into a vector of subranges, each of similar size

    func Remove_First(var S : Countable_Range) -> optional Bound_Type
    func Remove_Last(var S : Countable_Range) -> optional Bound_Type
    func Remove_Any(var S : Countable_Range) -> optional Bound_Type

    op "=?"(Left, Right : Countable_Range) -> Ordering
    //  Return #equal if Left.First == Right.First and Left.Last == Right.Last
    //  Return #less if Left.Last < Right.First
    //  Return #greater Left.First > Right.Last
    //  Return #unordered otherwise (i.e. they overlap and are not identical)

    func Strict_Compare(Left, Right : Countable_Range) ->
      Ordered::Full_Ordering
    //  Return #equal if Left.First == Right.First and Left.Last == Right.Last
    //  Return #less if Left.First < Right.First
    //    or (Left.First == Right.First and Left.Last < Right.Last)
    //  Return #greater if Left.First > Right.First
    //    or (Left.First == Right.First and Left.Last > Right.Last)
    //  Never return #unordered

end interface PSL::Core::Countable_Range

class PSL::Core::Countable_Range is
exports  // check that indent of 0 works
    op ".."(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left, Last => Right)
    end op ".."

    op "<.."(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left+1, Last => Right)
    end op "<.."

    op "..<"(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left, Last => Right-1)
    end op "..<"

    op "<..<"(Left, Right : Bound_Type) -> Countable_Range is
        return (First => Left+1, Last => Right-1)
    end op "<..<"

    op "in"(Val : Bound_Type; Interval : Countable_Range) -> Boolean is
        return Val >= Interval.First and then Val <= Interval.Last
    end op "in"

    func Length(R : Countable_Range) -> Univ_Integer is
        return R.Last - R.First + 1
    end func Length

    op "[]"() -> Countable_Range is
        return Bound_Type::First()+1 .. Bound_Type::First()
    end op "[]"

    op "[..]"() -> Countable_Range is
        return Bound_Type::First() .. Bound_Type::Last()
    end op "[..]"

    func Singleton(Bound : Bound_Type) -> Countable_Range is
        return Bound .. Bound
    end func Singleton

    op "/"(R : Countable_Range; Num_Pieces : Univ_Integer)
      -> Result : Vector<Countable_Range> is
       // Divide a range into a vector of subranges, each of similar size
        {> Num_Pieces > 0 <}

        if Num_Pieces <= 1 then
            //  Return a vector of length 1 if Num_Pieces is 1 (or less)
            return Create(1, R)
        end if

        const Size := Length(R)
        const Small_Piece_Size := Size / Num_Pieces
        const Big_Piece_Size := Small_Piece_Size + 1
        const Num_Big_Pieces := Size rem Num_Pieces

        //  Create the result
        Result := Create(Num_Pieces, [])

        //  Fill in the elements of the result vector with slices of the set.
        var Index := R.First

        //  Big pieces first
        for I in 1 .. Num_Big_Pieces forward loop
            Result[I] := Index .. Index + Big_Piece_Size - 1
            Index := Index + Big_Piece_Size
        end loop

        //  Small pieces next
        if Small_Piece_Size > 0 then
            for I in Num_Big_Pieces + 1 .. Num_Pieces forward loop
                Result[I] := Index .. Index + Small_Piece_Size - 1
                Index := Index + Small_Piece_Size
            end loop
        end if

        {> Index == R.Last + 1 <}
            
    end op "/"

    func Remove_First(var S : Countable_Range) 
      -> Result : optional Bound_Type is
        if S.First <= S.Last then
            Result := S.First
            S := (First => Result+1, Last => S.Last)
        else
            Result := null
        end if
    end func Remove_First
        
    func Remove_Last(var S : Countable_Range) 
      -> Result : optional Bound_Type is
        if S.First <= S.Last then
            Result := S.Last
            S := (First => S.First, Last => Result-1)
        else
            Result := null
        end if
    end func Remove_Last

    func Remove_Any(var S : Countable_Range) 
      -> Result : optional Bound_Type is
        //  NOTE: Optimized to minimize calls on Bound_Type operations
        const Diff := S.Last - S.First
        if Diff >= 0 then
            if Diff mod 2 == 0 then
                Result := S.First
                S := (First => Result+1, Last => S.Last)
            else
                Result := S.Last
                S := (First => S.First, Last => Result-1)
            end if
        else
            return null
        end if
    end func Remove_Any

    op "=?"(Left, Right : Countable_Range) -> Ordering is
    //  Return #equal if Left.First == Right.First and Left.Last == Right.Last
    //  Return #less if Left.Last < Right.First
    //  Return #greater Left.First > Right.Last
    //  Return #unordered otherwise (i.e. they overlap and are not identical)
        if Left.Last < Right.First then
           return #less
        elsif Left.First > Right.Last then
           return #greater
        elsif Left.First == Left.First
          and then Left.Last == Right.Last
        then
           return #equal
        else
           return #unordered
        end if
    end op "=?"

    func Strict_Compare(Left, Right : Countable_Range) ->
      Result : Ordered::Full_Ordering is
    //  Return #equal if Left.First == Right.First and Left.Last == Right.Last
    //  Return #less if Left.First < Right.First
    //    or (Left.First == Right.First and Left.Last < Right.Last)
    //  Return #greater if Left.First > Right.First
    //    or (Left.First == Right.First and Left.Last > Right.Last)
    //  Never return #unordered

        Result := Left.First =? Right.First

        if Result == #equal then
            return Left.Last =? Right.Last
        end if
    end func Strict_Compare

end class PSL::Core::Countable_Range

func PSL::Test::Test_Countable_Range(A, X, Y : Integer) is
    var R : Countable_Range<Integer> := X .. Y
    Println(A | " in " | X | ".." | Y | "=" | ( A in R ))

    for J in R loop 
        Println("Remove_Any(" | X | ".." | Y | ") = " | J)
    end loop

    R := 1 .. 10
    Println("R := 1..10");

    for K in R reverse loop 
        Println("Remove_Last(R) = " | K)
    end loop

    Println("Length(R) = " | Length(R))

    for Num in 1 .. 11 forward loop
       Print("R / " | Num | " =")
       for each Piece of R / Num forward loop
          if Length(Piece) == 0 then
             Print (" []")
          else
             Print (" " | Piece.First | ".." | Piece.Last)
          end if
       end loop
       Print('\n')
    end loop
end func PSL::Test::Test_Countable_Range
interface PSL::Core::Univ_Character<> is
    op "+"(Left : Univ_Character; Right : Univ_Integer) -> Univ_Character
      is import("+")
    op "+"(Left : Univ_Integer; Right : Univ_Character) -> Univ_Character
      is import("+")

    op "-"(Left : Univ_Character; Right : Univ_Integer) -> Univ_Character
      is import("-")
    op "-"(Left, Right : Univ_Character) -> Univ_Integer
      is import("-")

    op "+="(var Left : Univ_Character; Right : Univ_Integer)
      is import("+=");
    op "-="(var Left : Univ_Character; Right : Univ_Integer)
      is import("-=");

    op "*"(Left : Univ_Integer; Right : Univ_Character) -> Univ_String
        // Produce specified number of "Right" chars in a row
    op "*"(Left : Univ_Character; Right : Univ_Integer) -> Univ_String
        // Produce specified number of "Left" chars in a row

    op "=?"(Left, Right : Univ_Character) -> Ordering
      is import("=?")

    func Strict_Compare(Left, Right : Univ_Character) -> Ordered::Full_Ordering
      is import("=?")

    func To_String(Val : optional Univ_Character) -> Univ_String
      is import(#to_string_char)

    func From_String(Str : Univ_String) -> optional Univ_Character
      is import(#from_string_char)

    func Print(C : Univ_Character) is import(#print_char)
    func Println(C : Univ_Character) is (Println(To_String(C)))

    func Hash(Val : Univ_Character) -> Unsigned_64
      is import(#identity)

    func First() -> Univ_Character

    func Last() -> Univ_Character

    func Min(Left, Right : optional Univ_Character) -> optional Univ_Character
      is import(#min)
    func Max(Left, Right : optional Univ_Character) -> optional Univ_Character
      is import(#max)

    op ".."(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "<.."(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "..<"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "<..<"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
    op "|"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>
end interface PSL::Core::Univ_Character
    
class PSL::Core::Univ_Character is
  exports
    op "*"(Left : Univ_Integer; Right : Univ_Character) -> Univ_String is
        // Produce specified number of "Right" chars in a row
        return Left * To_String(Right)   // Just pass the buck to the string op
    end op "*"

    op "*"(Left : Univ_Character; Right : Univ_Integer) -> Univ_String is
        // Produce specified number of "Left" chars in a row
        return Right * To_String(Left)   // Just pass the buck to the string op
    end op "*"

    func First() -> Univ_Character is
        return '\0'
    end func First

    func Last() -> Univ_Character is
        return '\0' + 2**31-1
    end func Last
end class PSL::Core::Univ_Character

abstract interface PSL::Core::Imageable<> is
    func To_String(Val : Imageable) -> Univ_String<>

    optional func From_String(Str : Univ_String<>) -> optional Imageable

    // NOTE: We include Hashable<> operations here
    //       so that Set<Imageable+> works nicely.
    //       Clearly if something is Imageable it is possible
    //       to implement "=?" and Hash using the string image,
    //       so we might as well requires these operations too.

    op "=?"(Left, Right : Imageable) -> Ordering
    func Hash(Val : Imageable) -> Unsigned_64
end interface PSL::Core::Imageable
interface PSL::Containers::Packed_Word
  <Key_Type is Enum<>;
   Bit_Field_Sizes : Array<Integer_64, Indexed_By => Key_Type>;
     {Bit_Field_Sizes.Bounds == [..]}  // All values of Key_Type have a size
     {(for all Size of Bit_Field_Sizes => |Size| <= 63)} // Each size <= 63
     {(for each Size of Bit_Field_Sizes => <0> + |Size|) <= 64} // Total <= 64
   Allow_Null : Boolean := #false> is
   // This implements a packed word, where the map determines
   // the sizes of the bit fields.
   // The size of a bit field may be negative to indicate a signed bit field,
   // or positive to indicate an unsigned bit field.
   // The sum of the absolute values of the sizes must be no more than 64.
   // If Allow_Null is #true, then null values can be stored/fetched.
   // Otherwise, only non-null values are permitted.

   const Bit_Field_Ranges :
     Array<Countable_Range<Integer_64>, Indexed_By => Key_Type> :=
     //  Range of allowed values for each bit field
     //  Null is most negative value if Size < 0, else most positive value.
      [for each [Key => Size] of Bit_Field_Sizes,
        Key => (if Size >= 0 then 0
                elsif Allow_Null then -2**(|Size|-1) + 1
                else -2**(|Size|-1))
                 ..
               (if Size < 0 then 2**(|Size|-1) - 1
                elsif Allow_Null then 2**Size - 2
                else 2**Size - 1)]

   func Create(Bit_Field_Values : Map<Key_Type, Integer_64>)
     {(for all [Key => Val] of Bit_Field_Values =>
        (if Val is null then Allow_Null else Val in Bit_Field_Ranges[Key]))}
     -> Packed_Word
     // Create a packed word with the given initial values.
     // Unspecified fields will be initialized to zero or null,
     // according to Allow_Null.

   op "indexing"(W : Packed_Word; Key : Key_Type)
     -> Result : optional Integer_64
     {(if Result is null then Allow_Null else Result in Bit_Field_Ranges[Key])}
     //  Extract from W and return the bit field identified by Key

   func Set_Bit_Field(var W : Packed_Word;
                      Key : Key_Type; Value : optional Integer_64)
     {(if Value is null then Allow_Null else Value in Bit_Field_Ranges[Key])}
     //  Insert Value into bit field of W identified by Key

   func Dump_Constant_Info()
   //  Dump constants computed to make packing/unpacking more efficient.

end interface PSL::Containers::Packed_Word

class PSL::Containers::Packed_Word is
   // This implements a packed word, where the map determines
   // the sizes of the bit fields.
   // The size of a bit field may be negative to indicate a signed bit field,
   // or positive to indicate an unsigned bit field.
   // The sum of the absolute values of the sizes must be no more than 64.
   // If Allow_Null is #true, then null values can be stored/fetched.
   // Otherwise, only non-null values are permitted.

   var Word : Unsigned_64
   const Bit_Field_Defaults : Array<Unsigned_64, Indexed_By => Key_Type> :=
     [for each [Key => Size] of Bit_Field_Sizes, Key =>
        (if not Allow_Null then 0
         elsif Size < 0 then 2**(|Size|-1)
         else 2**Size-1)]

   const Bit_Field_Offsets : Array<Unsigned_64, Indexed_By => Key_Type> :=
     [for each [Key => Size] of Bit_Field_Sizes, Key =>
        (for K in Key_Type::First() .. Key-1 =>
           <Unsigned_64::0> + [[|Bit_Field_Sizes[K]|]])]

 exports

   func Create(Bit_Field_Values : Map<Key_Type, Integer_64>)
     -> Result : Packed_Word is
     // Create a packed word with the given initial values.
     // Unspecified fields will be initialized to zero or null,
     // according to Allow_Null.
      //  TBD: Should not need to repeat precondition here to get it checked!
      {(for all [Key => Val] of Bit_Field_Values =>
           (if Val is null then Allow_Null else Val in Bit_Field_Ranges[Key]))}
      return (Word => (for each [Key => Size] of Bit_Field_Sizes reverse =>
                <Unsigned_64::0> * 2**|Size| + (Key in Bit_Field_Values?
                                     [[Bit_Field_Values[Key] mod 2**|Size|]]:
                                     Bit_Field_Defaults[Key])))
   end func Create

   op "indexing"(W : Packed_Word; Key : Key_Type)
     -> Result : optional Integer_64 is
     //  Extract from W and return the bit field identified by Key
     const Size := Bit_Field_Sizes[Key]
     const Abs_Size := |Size|
     const Uns_Result : Unsigned_64 := [[(W.Word >> Bit_Field_Offsets[Key]) mod
                  2 ** Abs_Size]]

     if Allow_Null and then Uns_Result == Bit_Field_Defaults[Key] then
        //  We have a "null" value
        Result := null
     elsif Size < 0 and then Uns_Result >= 2 ** (Abs_Size-1) then
        //  Handle negative values for signed fields
        Result := [[Uns_Result]] - 2 ** (Abs_Size-1)
     else
        Result := [[Uns_Result]]
     end if

     {(if Result is null then Allow_Null else Result in Bit_Field_Ranges[Key])}
   end op "indexing"

   func Set_Bit_Field(var W : Packed_Word;
                      Key : Key_Type; Value : optional Integer_64) is
     //  Insert Value into bit field of W identified by Key
      {(if Value is null then Allow_Null else Value in Bit_Field_Ranges[Key])}
      const Abs_Size := |Bit_Field_Sizes[Key]|

      const Unsigned_Field_Value : Unsigned_64 :=  //  Unsigned Value of field
        (if Value is null then Bit_Field_Defaults[Key]
         else [[Value mod 2**Abs_Size]])

      const Above_Field :=
         W.Word - W.Word mod (2 ** (Abs_Size + [[Bit_Field_Offsets[Key]]]))
      const Below_Field := W.Word mod 2**[[Bit_Field_Offsets[Key]]]

      W.Word := (Unsigned_Field_Value << Bit_Field_Offsets[Key]) +
             Above_Field + Below_Field
   end func Set_Bit_Field

   func Dump_Constant_Info() is
   //  Dump constants computed to make packing/unpacking more efficient.
      Println(" Bit_Field_Sizes: [" |
        (for (each [Key => Size] of Bit_Field_Sizes; Sep := "" then ", ")
          forward => <""> | Sep | Key | " => " | Size) | "]")

      Println(" Bit_Field_Ranges: [" |
        (for (each [Key => Range] of Bit_Field_Ranges; Sep := "" then ", ")
          forward => <""> | Sep | Key | " => " |
            Range.First | ".." | Range.Last) | "]")

      Println(" Bit_Field_Defaults: [" |
        (for (each [Key => Default] of Bit_Field_Defaults; Sep := "" then ", ")
          forward => <""> | Sep | Key | " => " | Default) | "]")

      Println(" Bit_Field_Offsets: [" |
        (for (each [Key => Offset] of Bit_Field_Offsets; Sep := "" then ", ")
          forward => <""> | Sep | Key | " => " | Offset) | "]")
   end func Dump_Constant_Info

end class PSL::Containers::Packed_Word

func PSL::Test::Test_Packed_Word() is
   type Fields is Enum<[#red, #green, #blue]>
   type RGB is Packed_Word<Fields, [#red => 8, #green => 7, #blue => 9]>

   Println ("type RGB is Packed_Word" |
     "<Fields, [#red => 8, #green => 7, #blue => 9]>");

   RGB::Dump_Constant_Info()

   var All_Red : RGB := Create([#red => 255, #green => 0])

   func Print_RGB(C : RGB) is
      Print("[")
      for (F in Fields; Sep := "" then ", ") forward loop
         Print(Sep | F | " => " | C[F])
      end loop
      Println("]")
   end func Print_RGB

   Print("Red: ")
   Print_RGB(All_Red)

   var Purple := All_Red
   Set_Bit_Field(Purple, #blue, 255)

   Print("Purple: ")
   Print_RGB(Purple)

   Set_Bit_Field(Purple, #green, Purple[#green] + 3)

   Print("Purple with a touch of green: ")
   Print_RGB(Purple)


end func PSL::Test::Test_Packed_Word
interface PSL::Containers::Packed_Array
  <Elem_Type is Countable<>; Indexed_By is Countable<>;
   Allow_Null : Boolean := #false> 
  implements Indexable<Elem_Type, Indexed_By> is
  // A packed array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
  // The element type must be countable, and only the range First()..Last()
  // need be represented.
  // If Allow_Null is #true, then one extra value per element is allowed
  // so that "null" can be represented (the "all ones" value is used for null).
  // In an instantiation, the Elem_Type should include "optional"
  // if Allow_Null is #true.

    const Bounds : Countable_Range<Indexed_By>

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : Elem_Type)
      -> Packed_Array

    func Length(Arr : Packed_Array) -> Univ_Integer
    op "magnitude"(Packed_Array) -> Univ_Integer is Length

    func Bounds(Arr : Packed_Array) -> Countable_Range<Indexed_By>
    func First(Arr : Packed_Array) -> Indexed_By is (Arr.Bounds().First)
    func Last(Arr : Packed_Array) -> Indexed_By is (Arr.Bounds().Last)

    interface Packed_Array_Ref<> is
        func Create(ref Arr : Packed_Array; Index : Indexed_By)
          -> ref Packed_Array_Ref
        op "ref"(ref Packed_Array_Ref) -> ref Elem_Type
        op "end"(var Packed_Array_Ref)
    end interface Packed_Array_Ref

    op "indexing"(Arr : Packed_Array; Index : Indexed_By)
      -> optional Elem_Type
    op "var_indexing"(ref var Arr : Packed_Array; Index : Indexed_By)
      -> ref var Packed_Array_Ref
    op "index_set"(Arr : Packed_Array) -> Countable_Range<Indexed_By>
    func Set(var Arr : Packed_Array; Index : Indexed_By; New_Val : Elem_Type)
    op "<|="(var Left : Packed_Array; var Right : Elem_Type)
    op "|"(Left : Packed_Array; Right : Key_Value<Indexed_By, Elem_Type>)
      -> Packed_Array
    op "|"(Left, Right : Packed_Array) -> Packed_Array;
    op "[]"() -> Packed_Array
    func Dump()
end interface PSL::Containers::Packed_Array

class PSL::Containers::Packed_Array is
  // A packed array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
  // The element type must be countable, and only the range First()..Last()
  // need be represented.
  // If Allow_Null is #true, then one extra value per element is allowed
  // so that "null" can be represented (the "all ones" value is used for null).
  // In an instantiation, the Elem_Type should include "optional"
  // if Allow_Null is #true.
    const Word_Size := 64 
    const Debug : Boolean := #false
    const Debug_End_Op : Boolean := #false

    func Num_Bits(Num_Vals : Univ_Integer) -> Univ_Integer is
        for (Bits in 1 .. Word_Size-1; Pow := 2 then Pow + Pow) forward loop
            if Pow >= Num_Vals then
                return Bits
            end if
        end loop
        return Word_Size
    end func Num_Bits

    type Word is Unsigned_64

    //  TBD: the following causes order-of-eval problems:
    //    const Num_Elem_Vals := (Elem_Type::Last() - Elem_Type::First()) + 1
        
    func Num_Elem_Vals() -> Univ_Integer is
        //  Return number of values needed, including one for null if allowed.
        return (Elem_Type::Last() - Elem_Type::First()) +
                  (Allow_Null? 2 : 1)
    end func Num_Elem_Vals

    const Bits_Per_Elem := Num_Bits (Num_Elem_Vals())
    const Elems_Per_Word := Word_Size / Bits_Per_Elem
    const Mask : Word := 2 ** Bits_Per_Elem - 1

    func Compute_Spreader() -> Result : Word is
      // Compute a value which when multiplied by the initial value
      // "spreads" it over the packed array
        if Elems_Per_Word == Word_Size then
           // Special case for bit-vector
           Result := -1
        else
           Result := 0
           for (I in 1 .. Elems_Per_Word;
                One_Bit := 1 then One_Bit << Bits_Per_Elem) forward loop
              Result += One_Bit
           end loop
        end if
    end func Compute_Spreader

    const Spreader : Word := Compute_Spreader()

    type Word_Array is Basic_Array<Word>
    var Data : Word_Array

    func Nth_Elem(Arr : Packed_Array; Index : Indexed_By)
      -> optional Elem_Type is
        const Zero_Based_Index := Index - Arr.Bounds.First
        const Word_Index := Zero_Based_Index / Elems_Per_Word + 1
        const Word_Val := Arr.Data[ Word_Index ]
        const Val_Offset :=
           Mask and (Word_Val >>
             (Zero_Based_Index rem Elems_Per_Word) * Bits_Per_Elem)
        if Debug then
           Println ("Nth_Elem: Index = `(Index), Val_Offset = `(Val_Offset)");
        end if
        if Allow_Null and then Val_Offset == Mask then
           return null
        else
           return Elem_Type::First() + Val_Offset
        end if
    end func Nth_Elem

  exports

    class Packed_Array_Ref is
        ref Arr : Packed_Array;
        const Index : Indexed_By;
        var Elem : Elem_Type;
      exports
        func Create(ref Arr : Packed_Array; Index : Indexed_By)
          -> ref Packed_Array_Ref is
            return (Arr, Index, Elem => Nth_Elem(Arr, Index))
        end func Create
        op "ref"(ref Packed_Array_Ref) -> ref Elem_Type is
            return Packed_Array_Ref.Elem
        end op "ref"
        op "end"(var Packed_Array_Ref) is
            if Debug_End_Op then
               Println ("End op: Index = `(Packed_Array_Ref.Index)" |
                 ", New_Val = `(Packed_Array_Ref.Elem)");
            end if;
            Set(Packed_Array_Ref.Arr, Packed_Array_Ref.Index,
              New_Val => Packed_Array_Ref.Elem)
        end op "end"
    end class Packed_Array_Ref

    func Dump() is
        Println ("Bits_Per_Elem = " | Bits_Per_Elem)
        Println ("Elems_Per_Word = " | Elems_Per_Word)
        Println ("Mask = 0x" | Hex_Image(Mask))
        Println ("Spreader = 0x" | Hex_Image(Spreader))
    end func Dump

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : Elem_Type)
      -> Result : Packed_Array is
        const Num_Words :=
          (Length(Bounds) + Elems_Per_Word - 1) / Elems_Per_Word
        const Adjusted_Val := Initial_Value is null?
                                Mask : Initial_Value - Elem_Type::First()
        if Debug then
           Println("Create(`(Length(Bounds))(*`(Bits_Per_Elem))" |
             ", `(Adjusted_Val))")
        end if
        return (Data => Create(Num_Words, Adjusted_Val * Spreader),
          Bounds => Bounds)
    end func Create

    func Length(Arr : Packed_Array) -> Univ_Integer is
        return Length(Arr.Bounds)
    end func Length

    func Bounds(Arr : Packed_Array) -> Countable_Range<Indexed_By> is
        return Arr.Bounds
    end func Bounds

    op "indexing"(Arr : Packed_Array; Index : Indexed_By)
      -> optional Elem_Type is (Nth_Elem(Arr, Index))

    op "var_indexing"(ref var Arr : Packed_Array; Index : Indexed_By)
      -> ref var Packed_Array_Ref is
        if Index not in Arr.Bounds then
           //  Need to extend the array
           Set (Arr, Index, Allow_Null? null: Elem_Type::First())
        end if
        return Create(Arr, Index)
    end op "var_indexing"

    op "index_set"(Arr : Packed_Array) -> Countable_Range<Indexed_By> is
        return Arr.Bounds
    end op "index_set"

    func Set(var Arr : Packed_Array; Index : Indexed_By; New_Val : Elem_Type) is
        if |Arr.Bounds| == 0 then
            // First element in array
            Arr := Create (Index .. Index, New_Val);
            return
        end if

        if Index < Arr.Bounds.First then
            //  Extending low bound (ugh)
            var Old_Arr <== Arr;
            //  Create a new array, and copy old values over
            Arr := Create (Index .. Old_Arr.Bounds.Last, New_Val);
            for each [I => E] of Old_Arr loop
                Arr[I] := Old_Arr[I]
            end loop
            Old_Arr := null
            return
        end if

        if Index > Arr.Bounds.Last then
            //  Extending high bound
            Arr := (Data <== Arr.Data,
                    Bounds => (First => Arr.Bounds.First, Last => Index))
        end if
        const Zero_Based_Index := Index - Arr.Bounds.First
        const Word_Index := Zero_Based_Index / Elems_Per_Word + 1
        if Word_Index > |Arr.Data| then
            // Need to extend the the word array
            Arr.Data[ Word_Index ] := (Allow_Null? Mask * Spreader: 0)
        end if
        const Elem_Loc : Unsigned_64 :=
          (Zero_Based_Index rem Elems_Per_Word) * Bits_Per_Elem
        const Adjusted_Val : Unsigned_64 := (New_Val is null?
          Mask : New_Val - Elem_Type::First()) << Elem_Loc
        const Elem_Mask := Mask << Elem_Loc
        Arr.Data[ Word_Index ] := (Arr.Data[ Word_Index ] and not Elem_Mask) or
          Adjusted_Val
        if Debug then
           Println("Set: Index = `(Index), New_Val = `(New_Val)" |
             ", Elem_Loc = `(Elem_Loc)" |
             ", Adjusted_Val = `(Adjusted_Val) [0x" | Hex_Image(Adjusted_Val) |
             "], Elem_Mask = 0x" | Hex_Image(Elem_Mask));
           Println("   Arr.Data[`(Word_Index)] = `(Arr.Data[Word_Index]) = 0x"
             | Hex_Image(Arr.Data[Word_Index]))
        end if
    end func Set

    op "<|="(var Left : Packed_Array; var Right : Elem_Type) is
        // Add Right onto Array
        if Length(Left) == 0 then
            Left := (Data => Create(1, 0),
              Bounds => Indexed_By::First() .. Indexed_By::First())
            Set (Left, Indexed_By::First(), Right)
        else
            Set (Left, Left.Bounds.Last + 1, Right)
        end if
    end op "<|="
    
    op "|"(Left : Packed_Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      -> Result : Packed_Array is
        Result := Left
        Set (Result, Right.Key, Right.Value)
    end op "|"

    op "|"(Left, Right : Packed_Array) -> Result : Packed_Array is
        const Left_Len := Length(Left)

        if Left_Len == 0 then
            return Right
        end if

        Result :=
          Create (Left.Bounds.First .. Left.Bounds.Last + Length(Right),
                  Elem_Type::First())

        // Copy the Left elements
        for I in Left.Bounds loop
            Set (Result, I, Left[I]);
        end loop

        // Copy the Right elements
        
        for J in Right.Bounds loop
            Set (Result, Left_Len + J, Right[J]);
        end loop
    end op "|"

    op "[]"() -> Result : Packed_Array is
        return (Data => Create(0, 0),
          Bounds => Indexed_By::First()+1 .. Indexed_By::First())
            // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Packed_Array

func PSL::Test::Test_Packed() is
    type Color is Enum< [#red, #green, #blue] >
    type RCB is Packed_Array
      <optional Integer<Range => 0..0xFF>, Indexed_By => Color,
       Allow_Null => #true>

    RCB::Dump()

    const Red : RCB := [#red => 0x33, #green => 0, #blue => 0]
    const Blue : RCB := [#blue => 0x33, #green => 0, #red => 0]
    const Yellow : RCB := [#green => 0x33, #blue => 0x33, #red => 0] 
    const White : RCB := [0xFF, 0xFF, 0xFF]
    const Partial : RCB := [0xFF, 0xFF, null]
    
    const RCBs : Vector<RCB> := [Red, Blue, Yellow, White, Partial]
    const Names : Vector<Univ_String> :=
      ["Red", "Blue", "Yellow", "White", "Partial"]

    for each [I => C] of RCBs forward loop
        Println(Names[I] | " = [#red => " | C[#red] |
          ", #green => " | C[#green] | ", #blue => " | C[#blue] | "]")
    end loop

    var Arr : RCB := Create(#red .. #blue, 0x77)
    Print("Arr = ")
    for (each [I => X] of Arr; Sep := "[" then ", ") forward loop
        Print(Sep | I | " => " | X)
    end loop
    Println("]")

    Println ("About to update Arr[#green] with 0x33 (= " | 0x33 | ")")
    block
        ref Green_Elem => Arr[#green]
        Green_Elem := 0x32
        Green_Elem += 1

        //  "end"(Green_Elem) should be invoked here
    end block

    Println ("About to update Arr[#blue] with 0x22*5/2 (= " | 0x22*5/2 | ")")

    Arr[#blue] := 0x22
    //  "end"(Arr[#blue]) should be invoked here

    Println ("  Arr[#blue] := 0x22 = `(Arr[#blue])")

    //  Arr[#blue] := Arr[#blue] * 5
    Arr[#blue] *= 5
    //  "end"(Arr[#blue]) should be invoked here

    Println ("  Arr[#blue] *= 5 = `(Arr[#blue])")

    Arr[#blue] := Arr[#blue] / 2
    //  "end"(Arr[#blue]) should be invoked here

    Println ("  Arr[#blue] /= 2 = `(Arr[#blue])")

    Print("Arr now = ")
    for (each [I => X] of Arr; Sep := "[" then ", ") forward loop
        Print(Sep | I | " => " | X)
    end loop
    Println("]")

    const RR : RCB :=
      [#red => Arr[#green],
       #green => "var_indexing"(Arr, #blue),  //  "end" invoked here
       #blue => Arr[#red]]
    Print("RR = ")
    for (each [I => X] of RR; Sep := "[" then ", ") forward loop
        Print(Sep | I | " => " | X)
    end loop
    Println("]")

    var VV : Vector<Univ_Integer> := [3, Arr[#green], Arr[#red] / 5]
    VV := VV | [7, Arr[#blue]]
    Print("VV = ")
    for (each Z of VV; Sep := "[" then ", ") forward loop
        Print (Sep | Z)
    end loop
    Println("]")
    
end func PSL::Test::Test_Packed
interface PSL::Containers::Basic_Packed_Array
  <Elem_Type is Countable<>; Allow_Null : Boolean := #false> is
  // A packed array abstraction indexed by Unsigned_64 1 .. Length().
  // The element type must be countable, and only the range First()..Last()
  // need be represented.
  // If Allow_Null is #true, then one extra value per element is allowed
  // so that "null" can be represented (the "all ones" value is used for null).
  // In an instantiation, the Elem_Type should include "optional"
  // if Allow_Null is #true.

    func Create(Length : Unsigned_64; Initial_Value : Elem_Type)
      -> Basic_Packed_Array

    func Length(Arr : Basic_Packed_Array) -> Univ_Integer
    op "magnitude"(Basic_Packed_Array) -> Univ_Integer is Length

    func Bounds(Arr : Basic_Packed_Array) -> Countable_Range<Unsigned_64>
      is (1 .. |Arr|)
    func First(Arr : Basic_Packed_Array) -> Unsigned_64 is (1)
    func Last(Arr : Basic_Packed_Array) -> Unsigned_64 is (|Arr|)

    op "indexing"(Arr : Basic_Packed_Array; Index : Univ_Integer)
      -> optional Elem_Type
    op "index_set"(Arr : Basic_Packed_Array) -> Countable_Range<Unsigned_64>
      is Bounds
    func Set_Nth_Elem(var Arr : Basic_Packed_Array; Index : Univ_Integer;
                      New_Val : Elem_Type);
    func Dump()
end interface PSL::Containers::Basic_Packed_Array

class PSL::Containers::Basic_Packed_Array is
  // A packed array abstraction indexed by Unsigned_64 1 .. Length().
  // The element type must be countable, and only the range First()..Last()
  // need be represented.
  // If Allow_Null is #true, then one extra value per element is allowed
  // so that "null" can be represented (the "all ones" value is used for null).
  // In an instantiation, the Elem_Type should include "optional"
  // if Allow_Null is #true.
    const Debug : Boolean := #false

    const Word_Size := 64 
    func Num_Bits(Num_Vals : Unsigned_64) -> Unsigned_64 is
        for (Bits in 1 .. Word_Size-1; Pow := 2 then Pow + Pow) forward loop
            if Pow >= Num_Vals then
                return Bits
            end if
        end loop
        {*nyi_unpacked* #false}  //  Can't handle unpacked values, due to null.
        return Word_Size
    end func Num_Bits

    //  TBD: the following causes order-of-eval problems:
    //    const Num_Elem_Vals := (Elem_Type::Last() - Elem_Type::First()) + 1
        
    func Num_Elem_Vals() -> Unsigned_64 is
        //  Return number of values needed, including one for null if allowed.
        return (Elem_Type::Last() - Elem_Type::First()) + (Allow_Null? 2 : 1)
    end func Num_Elem_Vals

    const Bits_Per_Elem := Num_Bits (Num_Elem_Vals())
    const Elems_Per_Word : Unsigned_64 := Word_Size / Bits_Per_Elem
    const Modulus : Unsigned_64 := 2 ** [[Bits_Per_Elem]]
    const Mask := Modulus - 1
    const High_Bit_On := 2 ** [[(Bits_Per_Elem-1)]]
    const Fills_Word : Boolean := (Bits_Per_Elem * Elems_Per_Word == Word_Size)

    func Compute_Spreader() -> Result : Unsigned_64 is
      // Compute a value which when multiplied by the initial value
      // "spreads" it over the packed array
        Result := 0
        if Elems_Per_Word == Word_Size then
           // Special case for bit-vector
           Result := -1
        else
           for (I in 1 .. Elems_Per_Word;
                One_Bit := 1 then One_Bit << Bits_Per_Elem) forward loop
              Result += One_Bit
           end loop
        end if
    end func Compute_Spreader

    const Spreader : Unsigned_64 := Compute_Spreader()

    type Word_Array is Basic_Array<Unsigned_64>
    var Data : Word_Array

    func Nth_Elem(Arr : Basic_Packed_Array; Index : Unsigned_64)
      -> optional Elem_Type is
        const Zero_Based_Index := Index - 1
        const Within_Word_Index := Zero_Based_Index rem Elems_Per_Word
        const Word_Index := Zero_Based_Index / Elems_Per_Word + 1
        const Word_Val := Arr.Data[ Word_Index ]
        var Val_Offset : Unsigned_64

        // Normal case, compute Val_Offset
        Val_Offset :=
          (Word_Val >> (Within_Word_Index * Bits_Per_Elem)) mod Modulus
        if Allow_Null and then Val_Offset == Mask then
           return null
        else
           return Elem_Type::First() + [[Val_Offset]]
        end if
    end func Nth_Elem

  exports

    func Dump() is
        Println ("Bits_Per_Elem = " | Bits_Per_Elem)
        Println ("Elems_Per_Word = " | Elems_Per_Word)
        Println ("Mask = 0x" | Hex_Image(Mask))
        Println ("Spreader = 0x" | Hex_Image(Mask))
    end func Dump

    func Create(Length : Unsigned_64; Initial_Value : Elem_Type)
      -> Result : Basic_Packed_Array is
        const Num_Words :=
          (Length + Elems_Per_Word - 1) / Elems_Per_Word
        const Adjusted_Val := Initial_Value is null?
                                Mask : Initial_Value - Elem_Type::First()
        if Debug then
           Println("Create(" | Length | "(*" | Bits_Per_Elem | "), " |
             Adjusted_Val | ")")
        end if
        return (Data => Create(Num_Words, Adjusted_Val * Spreader))
    end func Create

    func Length(Arr : Basic_Packed_Array) -> Univ_Integer is
        return |Arr.Data|
    end func Length

    op "indexing"(Arr : Basic_Packed_Array; Index : Univ_Integer)
      -> optional Elem_Type is (Nth_Elem(Arr, Index))

    func Set_Nth_Elem(var Arr : Basic_Packed_Array; Index : Univ_Integer;
                      New_Val : Elem_Type) is
        const Zero_Based_Index := Index - 1
        const Word_Index := Zero_Based_Index / Elems_Per_Word + 1
        const Within_Word_Index := Zero_Based_Index rem Elems_Per_Word
        const Elem_Loc :=
          Within_Word_Index * Bits_Per_Elem
        var Adjusted_Val := New_Val is null?
          Mask : New_Val - Elem_Type::First()
        {Adjusted_Val < Modulus}
        if Debug then
           Println("Set_Nth_Elem(Arr, " | Index | ", " | Adjusted_Val | ")")
           Println("Arr.Data[" | Word_Index | "] = " |
             Hex_Image(Arr.Data[Word_Index]))
           Println("Within_Word_Index = " | Within_Word_Index);
        end if
        const Low_Order_Part := Arr.Data[Word_Index] mod
           (Modulus ** [[Within_Word_Index]])
        if Within_Word_Index == Elems_Per_Word-1 then
           //  Setting the high-order element of the word;
           //  nothing to preserve above the new element.
           Arr.Data[Word_Index] := Low_Order_Part +
             (Adjusted_Val << Elem_Loc)
        else
           //  Not setting the high-order element;
           //  we need to preserve the part that is above the new
           //  element.
           const Part_To_Remove :=
             Arr.Data[Word_Index] mod (Modulus ** [[(Within_Word_Index+1)]]) -
               Low_Order_Part
           Arr.Data[ Word_Index ] += 
             (Adjusted_Val << Elem_Loc) - Part_To_Remove
        end if
        if Debug then
           Println("Arr.Data[" | Word_Index | "]' = " |
             Hex_Image(Arr.Data[Word_Index]))
        end if
    end func Set_Nth_Elem

end class PSL::Containers::Basic_Packed_Array

interface PSL::Core::Univ_String<> is
    func Print(Univ_String) is import(#print_string)
        //  Print string on standard output
    func Println(Univ_String) is import(#println_string)
        //  Print string, followed by a newline, on standard output
    func Readln() -> optional Univ_String is import(#read_string)
        //  Read input up to a newline, from standard input.
        //  Return null value when reaching end of file of standard input
        //  (which can happen when standard input is coming from a file,
        //   or when user types control/D on a Unix-like platform).

    op "*"(Left : Univ_Integer; Right : Univ_String) -> Univ_String
        // Produce specified number of "Right" strings in a row
    op "*"(Left : Univ_String; Right : Univ_Integer) -> Univ_String
        // Produce specified number of "Left" strings in a row

    op "|"(Left, Right : optional Univ_String) -> Univ_String 
      is import(#concat_string)

    op "=?"(Left, Right : Univ_String) -> Ordering
      is import(#string_compare)
    func Strict_Compare(Left, Right : Univ_String) -> Ordered::Full_Ordering
      is import(#string_compare)

    op "|="(var Left : Univ_String; Right : optional Univ_String)
      is import(#assign_concat_string)

    op "indexing"(Str : Univ_String; Index : Univ_Integer<>) -> Univ_Character
      is import(#string_indexing)
        // a "read-only" element, indexed 1 .. |Str|

    op "index_set"(Str : Univ_String) -> Countable_Range<Univ_Integer>
        // Return set of indices for string

    func Bounds(Str : Univ_String) -> Countable_Range<Univ_Integer>
      is "index_set"

    op "slicing"(Str : Univ_String;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> Univ_String is import(#string_slicing)
        // a "read-only" slice

    func Length(Str : Univ_String) -> Univ_Integer
      is import(#string_length)

    op "magnitude"(Univ_String) -> Univ_Integer
      is import(#string_length)

    func Hash(Val : Univ_String) -> Unsigned_64
      is import(#hash_string)

    op "|"(Left : optional Univ_String;
           Right : optional Right_Type is Imageable<>) 
      -> Univ_String

    op "|"(Left : optional Left_Type is Imageable<>;
           Right : optional Univ_String)
      -> Univ_String

    op "|="(var Left : Univ_String;
            Right : Right_Type is Imageable<>)

    // Operations to convert to/from a Vector of Univ_Character's
    func To_Vector(Str : Univ_String) -> Vector<Univ_Character>
    func From_Vector(Vec : Vector<Univ_Character>) -> Univ_String

    func Replace(Orig : Univ_String;
      Char : Univ_Character; With : Univ_Character) -> Univ_String
    //  Replace each appearance of Char with "With"

    func Replace(Orig, Str, With : Univ_String) -> Univ_String
     //  Replace any slice matching Str with "With"
     //  Overlapping matches will be replaced only once. Example:
     //    Replace(":::", "::", ".") -> ".:"

    func Hex_Image(Val : optional Univ_Integer) -> Univ_String
      //  Return a base-16 image of Val

  implements for Imageable
    // These operations are needed so Univ_String satifies
    // requirements of "Imageable" interface, but these
    // operations are not directly callable, to avoid ambiguities.

    func To_String(Val : Univ_String) -> Univ_String
      is import (#identity)
    func From_String(Str : Univ_String) -> optional Univ_String
      is import (#identity)

end interface PSL::Core::Univ_String
    
class PSL::Core::Univ_String is
    type Substr_Array is Basic_Array<Univ_String>

    var Parts : optional Substr_Array

    type Field is Enum<[#Hash, #Length, #Kind]>
      //  Low 32 bits = hash
      //  Next 24 bits = length (total number of characters)
      //  Next 3 bits select 0 = array of 8-bit chars,
      //                     1 = array of 16-bit chars,
      //                     2 = array of 31-bit chars,
      //                     3 = array of substrs (Max num sub-strs = 16)
      //                     4 = array of substrs (all sub-strs 8*256 chrs)
      //                     5 = array of substrs (all substrs 8*256^2 chrs)
      //                     6 = array of substrs (all substrs 8*256^3 chrs)

    //  Enumeration of kind of array
    type Kind_Enum is Enum<[#Array_8, #Array_16, #Array_31, #Array_Substr,
      #Array_2K_Substr, #Array_512K_Substr, #Array_128M_Substr]>
    
    //  Number of characters per substr
    const Array_2K_Multiplier := 2**11
    const Array_512K_Multiplier := 2**19
    const Array_128M_Multiplier := 2**27

    //  Packed representation
    type Info_Type is
      Packed_Word<Field, [#Hash => 32, #Length => 24, #Kind => 3]>

    var Info : Info_Type

    const Hash_Modulus := 2**32

    //  (unchecked) conversion routines to array of 8/16/31-bit chars
    func To_Int_Array(ref Substr_Array)
      -> ref Basic_Array<Univ_Integer> is import(#identity)

    type Int8 is Integer<0 .. 2**8-1>
    type Int8_Array is Basic_Packed_Array<Int8>

    func To_Int8_Array(ref Substr_Array) -> ref Int8_Array
      is import(#identity)

    func From_Int8_Array(ref Int8_Array) -> ref Substr_Array
      is import(#identity)

    type Int16 is Integer<0 .. 2**16-1>
    type Int16_Array is Basic_Packed_Array<Int16>

    func To_Int16_Array(ref Substr_Array) -> ref Int16_Array
      is import(#identity)

    func From_Int16_Array(ref Int16_Array) -> ref Substr_Array
      is import(#identity)

    type UChar_Array is
      Basic_Packed_Array<Univ_Character>

    func To_UChar_Array(ref Substr_Array) -> ref UChar_Array
      is import(#identity)

    func From_UChar_Array(ref UChar_Array) -> ref Substr_Array
      is import(#identity)

    const Char_First := Univ_Character::First()

    func Hash_Vec(Vec : Vector<Univ_Character>) -> Unsigned_64 is
       return (for I in 1 .. |Vec| reverse =>
         (<0> * 127 + (Vec[I] - Char_First)) mod Hash_Modulus)
    end func Hash_Vec

  exports
    op "index_set"(Str : Univ_String) -> Countable_Range<Univ_Integer> is
        // Return set of indices for string
        return 1..|Str|
    end op "index_set"

    op "*"(Left : Univ_Integer; Right : Univ_String) -> Univ_String is
        // Produce specified number of "Right" strings in a row
        if Left <= 0 then
            return ""
        elsif Left == 1 then
            return Right
        else
            // Recurse to produce half-length, and then combine
            const Partial : Univ_String := (Left/2) * Right
            if Left mod 2 == 1 then
                return Partial | Partial | Right
            else
                return Partial | Partial
            end if
        end if
    end op "*"

    op "*"(Left : Univ_String; Right : Univ_Integer) -> Univ_String is
        // Produce specified number of "Left" strings in a row
        return Right * Left   // Just pass the buck to other "*"
    end op "*"

    op "|"(Left : optional Univ_String;
           Right : optional Right_Type is Imageable<>) 
      -> Univ_String is
        if Right is null then
            return Left | "null"
        else
            return Left | Right_Type::To_String(Right)
        end if
    end op "|"

    op "|"(Left : optional Left_Type is Imageable<>;
           Right : optional Univ_String)
      -> Univ_String is
        if Left is null then
            return "null" | Right
        else
            return Left_Type::To_String(Left) | Right
        end if
    end op "|"

    op "|="(var Left : Univ_String; Right : Right_Type is Imageable<>) is
        if Right is null then
            Left |= "null"
        else
            Left |= Right_Type::To_String(Right)
        end if
    end op "|="

    func To_Vector(Str : Univ_String) -> Vector<Univ_Character> is
        return [for I in 1 .. |Str| => Str[I]]
    end func To_Vector

    func From_Vector(Vec : Vector<Univ_Character>) -> Result : Univ_String is
        Result := "";
        for each C of Vec forward loop
            Result |= C;
        end loop;
    end func From_Vector;

    func Replace(Orig : Univ_String;
      Char : Univ_Character; With : Univ_Character) -> Result : Univ_String is
    //  Replace each appearance of Char with "With"

       Result := ""

       var Prev_Match := 0
       for each [I => C] of Orig forward loop
          //  Look for a match
          if C == Char then
             // Concatenate on unchanged part and replacement character
             Result |= Orig[Prev_Match <..< I] | With
             Prev_Match := I;
          end if
       end loop

       if Prev_Match == 0 then
          Result := Orig
       elsif Prev_Match < |Orig| then
          Result |= Orig[Prev_Match <.. |Orig|]
       end if
    end func Replace

    func Replace(Orig, Str, With : Univ_String) -> Univ_String is
     //  Replace any slice matching Str with "With"
     //  Overlapping matches will be replaced only once. Example:
     //    Replace(":::", "::", ".") -> ".:"
       const Len_Str  := |Str|;
       const Len_With := |With|;

       case Len_Str of
        [0] =>
          //  Treat this as a no-op
          return Orig;

        [1] =>
          //  Replacing single characters
          if Len_With == 1 then
             //  Replace Char with Char
             return Replace(Orig, Str[1], With[1]);
          else
             //  Replace Char with String of any Length
             var Result : Vector<Univ_Character> := [];
             const Str_Char := Str[1];
             for I in 1 .. |Orig| forward loop
                if Orig[I] == Str_Char then
                   //  Matches
                   Result |= To_Vector(With);
                else
                   //  Does not match
                   Result |= Orig[I];
                end if
             end loop
             return From_Vector(Result);
          end if

        [..] =>
          //  Replace String of Length >= 2 with String of any Length
          var Result : Vector<Univ_Character> := [];
          const Len_Orig := |Orig|;
          for I := 1 while I <= Len_Orig loop
             if I + Len_Str <= Len_Orig + 1
               and then Orig[I ..< I + Len_Str] == Str
             then
                //  Matches
                Result |= To_Vector(With);
                //  Overlapping matches replaced only once
                //  Skip past end of this match
                continue loop with I + Len_Str;
             else
                //  Does not match just add Ith character to Result
                Result |= Orig[I];
                continue loop with I + 1;
             end if
          end loop
          return From_Vector(Result)
       end case
    end func Replace
 
    func Hex_Image(Val : optional Univ_Integer) -> Univ_String is
       const Word_Size := 64;
       var Max_Digits := Word_Size / 4;
       if Val is null then
          return '8' | ((Max_Digits-1)*'0')
       elsif Val == 0 then
          return "0"
       else
          const Abs_Val := abs Val;

          while 16 ** Max_Digits < Abs_Val loop
             Max_Digits += 4;
          end loop;

          var Vec : Vector<Univ_Character> := Create(Max_Digits, ' ')
          for (V := Val while V != 0;
               Index in 1..Max_Digits reverse)
          loop
             const Digit := V mod 16
             if Digit >= 10 then
                Vec[Index] := 'A' + (Digit-10)
             else
                Vec[Index] := '0' + Digit
             end if
    
             if V == Digit then
                return From_Vector(Vec[Index .. Max_Digits])
             else
                continue loop with V => (V - Digit) / 16
             end if
          end loop
          return From_Vector(Vec)
       end if
    end func Hex_Image
    
end class PSL::Core::Univ_String

func PSL::Test::Test_String() is
    const U := "tab\t"
    const T := U[4]
    Println("U = " | U | ", |U| = " | |U| | ", U[4] = '" | T | "'")
    const X := "this is a string"
    const Y := X[3]
    {Y == 'i'} // string indexing problem
    const Z := X[6..7]
    {Z == "is"} // string slicing problem, expected 'is', found Z 
    Println("X = " | X | ", X[3] = " | Y | ", X[6..7] = " | Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " | "hello")

    const Seven_Xs := "x" * 7
    {Seven_Xs == "xxxxxxx"} // Char multiplication check

    Println("Here are seven x's: " | Seven_Xs)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)

    Println("About to iterate over '" | X | "'")
    for each C of X forward loop
        Print(" " | C)
    end loop
    Println("")

    Println("X.Replace('s', With => 'x') = " | X.Replace('s', With => 'x'))
    Println("X.Replace(\"is\", With => \"at\") = " |
      X.Replace("is", With => "at"))
end func PSL::Test::Test_String
interface PSL::Core::Random<> is
    func Start(Seed : Univ_Integer := 1) -> Random
      // Start a new random number sequence with a standard multiplier/modulus

    func Start(Seed : Univ_Integer;
       Mult, Mod : Univ_Integer) -> Random
      // Start a new random number sequence with given multiplier and modulus

    func Next(var Seq : Random) -> Univ_Integer
      // Get next value in random number sequence

    func Next_Real(var Seq : Random) -> Univ_Real
      // Get next Univ_Real value in random number sequence,
      // in range 0.0 ..< 1.0
end interface PSL::Core::Random

class PSL::Core::Random is
    var Last_Value : Univ_Integer
    const Mult : Univ_Integer
    const Mod : Univ_Integer
    const Debugging : Boolean := #false
exports  // check that indent of 0 works
    func Start(Seed : Univ_Integer) -> Random is
      // Start a new random number sequence with a standard multiplier/modulus
        return (Last_Value => Seed,
          Mult => 7**5, Mod => 2**31 - 1)
    end func Start

    func Start(Seed : Univ_Integer;
      Mult, Mod : Univ_Integer) -> Random is
      // Start a new random number sequence with given multiplier and modulus
        if Debugging then
            Println("Random: Seed = " | Seed | ", Mult = " | Mult | 
              ", Mod = " | Mod)
        end if

        //  We want the multiplier to be less than the Modulus,
        //  and no less than 2
        {> Mult in 2 ..< Mod <}

        return (Last_Value => Seed, Mult => Mult, Mod => Mod)
    end func Start

    func Next(var Seq : Random) -> Result : Univ_Integer is
      // Get next value in random number sequence
        Result := Seq.Last_Value * Seq.Mult mod Seq.Mod
        if Result == 0 then
            //  Oh dear, we hit zero, return one instead
            Result := 1
        end if
        Seq.Last_Value := Result;
    end func Next

    func Next_Real(var Seq : Random) -> Univ_Real is
      // Get next Univ_Real value in random number sequence,
      // in range 0.0 ..< 1.0
        return (Int_To_Real (Next(Seq)) - 1.0) / Int_To_Real (Seq.Mod - 1)
    end func Next_Real
end class PSL::Core::Random
abstract interface PSL::Core::Sequence<Element_Type is Assignable<>> is
    func Remove_First(var S : Sequence) -> optional Element_Type
      // Returns null when sequence is empty
end interface PSL::Core::Sequence
interface PSL::Core::Direction<> is
    // This is passed to the "to_sequence" operator to generate
    // appropriate direction of sequence
    op "from_univ"(Lit : Univ_Enumeration)
      {Lit in #unordered | #forward | #reverse | #concurrent} -> Direction 
      is import(#direction_from_univ)

    op "to_univ"(Val : Direction) -> Univ_Enumeration 
      is import(#direction_to_univ)

    op "=?"(Left, Right : Direction) -> Ordering
      is import("=?")
    func Strict_Compare(Left, Right : Direction) -> Ordered::Full_Ordering
      is import("=?")
end interface PSL::Core::Direction
interface PSL::Core::Integer_64 <> is
    //  Normal 64-bit Integer, but with a "null" value.
    op "from_univ"(Lit : Univ_Integer) {Lit in -2**63+1 .. 2**63-1}
      -> Integer_64 
      is import(#integer_from_univ)

    op "to_univ"(Val : Integer_64) -> Univ_Integer 
      is import(#integer_to_univ)

    op "+"(Right : Integer_64) -> Integer_64
      is import(#identity)

    op "-"(Right : Integer_64) -> Integer_64
      is import(#negate)

    op "abs"(Right : Integer_64) -> Integer_64
      is import("abs")

    op "magnitude"(Integer_64) -> Integer_64 is "abs"

    op "+"(Left, Right : Integer_64) -> Result : Integer_64 
      is import("+")

    op "-"(Left, Right : Integer_64) -> Result : Integer_64
      is import("-")

    op "*"(Left, Right : Integer_64) -> Result : Integer_64 
      is import("*")

    op "/"(Left, Right : Integer_64) -> Result : Integer_64
      is import("/")

    op "mod"(Left, Right : Integer_64) -> Integer_64
      is import("mod")

    op "rem"(Left, Right : Integer_64) -> Integer_64
      is import("rem")

    op "**"(Left, Right : Integer_64) -> Result : Integer_64
      is import("**")

    op "+="(var Left : Integer_64; Right : Integer_64) 
      is import("+=")

    op "-="(var Left : Integer_64; Right : Integer_64) 
      is import("-=")

    op "*="(var Left : Integer_64; Right : Integer_64) 
      is import("*=")

    op "/="(var Left : Integer_64; Right : Integer_64) 
      is import("/=")

    op "**="(var Left : Integer_64; Right : Integer_64) 
      is import("**=")

    op "=?"(Left, Right : Integer_64) -> Ordering
      is import("=?")
    func Strict_Compare(Left, Right : Integer_64) -> Ordered::Full_Ordering
      is import("=?")

    op ">>"(Integer_64; Integer_64) -> Integer_64 is import(">>")

    op "<<"(Integer_64; Integer_64) -> Integer_64 is import("<<")

    func Min(Left, Right : optional Integer_64) -> optional Integer_64
      is import(#min)
    func Max(Left, Right : optional Integer_64) -> optional Integer_64
      is import(#max)

    func Hash(Val : Integer_64) -> Unsigned_64
      is import(#identity)

    func To_String(Val : optional Integer_64) -> Univ_String
      is import(#to_string_int)

    func From_String(Str : Univ_String) -> optional Integer_64
      is import(#from_string_int)

    func Print(X : Integer_64) is import(#print_int)
    func Println(X : Integer_64) is (Println(To_String(X)))

    func First() -> Integer_64 is (-2**62+1-2**62)

    func Last() -> Integer_64 is (2**62-1+2**62)

    op "[..]"()->Countable_Range<Integer_64> is in Countable_Range<Integer_64>

    op ".."(Left, Right : Integer_64) -> Countable_Set<Integer_64>
      is in Countable_Set<Integer_64>
    op "<.."(Left, Right : Integer_64) -> Countable_Set<Integer_64>
      is in Countable_Set<Integer_64>
    op "..<"(Left, Right : Integer_64) -> Countable_Set<Integer_64>
      is in Countable_Set<Integer_64>
    op "<..<"(Left, Right : Integer_64) -> Countable_Set<Integer_64>
      is in Countable_Set<Integer_64>
    op "|"(Left, Right : Integer_64) -> Countable_Set<Integer_64>
      is in Countable_Set<Integer_64>
  implements for Countable
    // These operations are needed so Integer_64 satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an integer to an int-literal).

    op "+"(Left : Integer_64; Right : Univ_Integer) -> Result : Integer_64 
      is import(#add_univ)

    op "+"(Left : Univ_Integer; Right : Integer_64) -> Result : Integer_64 
      is (Right + Left)

    op "-"(Left : Integer_64; Right : Univ_Integer) -> Result : Integer_64 
      is (Left + (-Right));

    op "-"(Left, Right : Integer_64) -> Result : Univ_Integer
      is import(#subtract_returns_univ);

    op "+="(var Left : Integer_64; Right : Univ_Integer)
      is import(#assign_add_univ);

    op "-="(var Left : Integer_64; Right : Univ_Integer)
      is import(#assign_subtract_univ);

 implements for Summable

    func From_Int (Int : Univ_Integer) -> Integer_64
      is ("from_univ"(Int))
    func Trunc_To_Int(Val : Integer_64) -> Univ_Integer is
      ("to_univ"(Val))
    func Floor_To_Int(Val : Integer_64) -> Univ_Integer is
      ("to_univ"(Val))
    func Round_To_Int(Val : Integer_64) -> Univ_Integer is
      ("to_univ"(Val))

end interface PSL::Core::Integer_64

interface PSL::Core::Integer
  <Range : Countable_Range<Univ_Integer> :=
              -2**63+1 .. +2**63-1> is
    // NOTE: We leave room for null.
    op "from_univ"(Lit : Univ_Integer) {Lit in Range} -> Integer 
      is import(#integer_from_univ)

    op "to_univ"(Val : Integer) -> Univ_Integer 
      is import(#integer_to_univ)

    op "+"(Right : Integer) -> Integer
      is import(#identity)

    op "-"(Right : Integer) -> Integer
      is import(#negate)

    op "abs"(Right : Integer) -> Integer
      is import("abs")

    op "magnitude"(Integer) -> Integer is "abs"

    op "+"(Left, Right : Integer) -> Result : Integer 
      is import("+")

    op "-"(Left, Right : Integer) -> Result : Integer
      is import("-")

    op "*"(Left, Right : Integer) -> Result : Integer 
      is import("*")

    op "/"(Left, Right : Integer) -> Result : Integer
      is import("/")

    op "mod"(Left, Right : Integer) -> Integer
      is import("mod")

    op "rem"(Left, Right : Integer) -> Integer
      is import("rem")

    op "**"(Left, Right : Integer) -> Result : Integer
      is import("**")

    op "+="(var Left : Integer; Right : Integer) 
      is import("+=")

    op "-="(var Left : Integer; Right : Integer) 
      is import("-=")

    op "*="(var Left : Integer; Right : Integer) 
      is import("*=")

    op "/="(var Left : Integer; Right : Integer) 
      is import("/=")

    op "**="(var Left : Integer; Right : Integer) 
      is import("**=")

    op "=?"(Left, Right : Integer) -> Ordering
      is import("=?")

    func Strict_Compare(Left, Right : Integer) -> Ordered::Full_Ordering
      is import("=?")

    op ">>"(Integer; Integer) -> Integer is import(">>")

    op "<<"(Integer; Integer) -> Integer is import("<<")

    func Min(Left, Right : optional Integer) -> optional Integer
      is import(#min)
    func Max(Left, Right : optional Integer) -> optional Integer
      is import(#max)

    func Hash(Val : Integer) -> Unsigned_64
      is import(#identity)

    func To_String(Val : optional Integer) -> Univ_String
      is import(#to_string_int)

    func From_String(Str : Univ_String) -> optional Integer
      is import(#from_string_int)

    func Print(X : Integer) is import(#print_int)
    func Println(X : Integer) is (Println(To_String(X)))

    func First() -> Integer

    func Last() -> Integer

    op "[..]"()->Countable_Range<Integer> is in Countable_Range<Integer>

    op ".."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "<.."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "<..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "|"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
  implements for Countable
    // These operations are needed so Integer satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an integer to an int-literal).

    op "+"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("+")

    op "+"(Left : Univ_Integer; Right : Integer) -> Result : Integer 
      is import("+")

    op "-"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("-")

    op "-"(Left, Right : Integer) -> Result : Univ_Integer
      is import("-")

    op "+="(var Left : Integer; Right : Univ_Integer)
      is import("+=");

    op "-="(var Left : Integer; Right : Univ_Integer)
      is import("-=");

 implements for Summable

    func From_Int (Int : Univ_Integer) -> optional Integer
      is (Int in Range? "from_univ"(Int) : null)
    func Trunc_To_Int(Val : Integer) -> Univ_Integer is
      ("to_univ"(Val))
    func Floor_To_Int(Val : Integer) -> Univ_Integer is
      ("to_univ"(Val))
    func Round_To_Int(Val : Integer) -> Univ_Integer is
      ("to_univ"(Val))

end interface PSL::Core::Integer

class PSL::Core::Integer is
    const Content : Integer_64;  // So this ends up as a wrapper
  exports
    func First() -> Integer is
        return Range.First
    end func First

    func Last() -> Integer is
        return Range.Last
    end func Last

end class PSL::Core::Integer

interface PSL::Core::List<List_Elem is Assignable<>> is
    var Elem : List_Elem
    var Next : optional List

    op "|"(Left : List_Elem; Right : List_Elem) -> List
    op "|"(Left : List_Elem; Right : List) -> List
    op "|"(Left : List; Right : List) -> List
    op "|"(Left : List; Right : List_Elem) -> List

    op "|="(var Left : List; Right : List)
    op "|="(var Left : List; Right : List_Elem)
    func Length(L : optional List) -> Univ_Integer
    op "magnitude"(L : optional List) -> Univ_Integer is Length

    op "[]"() -> optional List is (null)

    func Remove_First(var L : List) -> optional List_Elem
    func Remove_Last(var L : List) -> optional List_Elem
    func Remove_Any(var L : List) -> optional List_Elem
end interface PSL::Core::List

class PSL::Core::List is
  exports
    op "|"(Left : List_Elem; Right : List_Elem) -> List is
        return (Elem => Left, Next => (Elem => Right, Next => null))
    end op "|"

    op "|"(Left : List_Elem; Right : List) -> List is
        return (Elem => Left, Next => Right)
    end op "|"

    op "|"(Left : List; Right : List) -> List is
        if Left is null then
            // Left is null, so just return Right
            return Right
        else
            // Recurse with tail of left Basic_list
            return (Elem => Left.Elem, Next => Left.Next | Right)
        end if
    end op "|"

    op "|"(Left : List; Right : List_Elem) -> List is
        return Left | (Elem => Right, Next => null)
    end op "|"

    op "|="(var Left : List; Right : List) is
        if Left is null then
            Left := Right
        else
            // Recurse with tail of Basic_list
            Left.Next |= Right
        end if
    end op "|="

    op "|="(var Left : List; Right : List_Elem) is
        // Just pass the buck
        Left |= (Elem => Right, Next => null)
    end op "|="

    func Length(L : optional List) -> Result : Univ_Integer is
        Result := 0
        for Lst := L then Lst.Next while Lst not null loop
            Result += 1
        end loop
    end func Length

    func Remove_First(var L : List) 
      -> Result : optional List_Elem is
        if L is null then
            return null
        else
            Result := L.Elem
            L <== L.Next
              // carve off L.Next and set L to that
        end if
    end func Remove_First

    func Remove_Last(var L : List) 
      -> Result : optional List_Elem is
        if L is null then
            return null
        elsif L.Next is null then
            Result := L.Elem
            L := null
        else
            // Recurse to remove last element
            return Remove_Last(L.Next)
        end if
    end func Remove_Last

    func Remove_Any(var L : List) 
      -> Result : optional List_Elem is
        // Easiest to remove first element
        return Remove_First(L)
    end func Remove_Any

end class PSL::Core::List
func PSL::Test::Test_List(X, Y : Univ_Integer) is
    type Univ_List is List<Univ_Integer>

    func Println(L : Univ_List) is
        // Print a univ Basic_list
        var N := L
        while N not null loop
            const E : Univ_Integer := N.Elem
            Print(E)
            N := N.Next
            if N not null then
                Print(", ")
            end if
        end loop

        Print("\n")
    end func Println

    func Println_It(L : Univ_List) is
        // Print a univ Basic_list using destructive iterator
        Print("Forward: ")
        var F := L
        while F not null loop
            const E : Univ_Integer := Remove_First(F)
            Print(E)
            if F not null then
                Print(", ")
            end if
        end loop

        Print("\n")

        Print("Reverse: ")
        var R := L
        while R not null loop
            const Z : Univ_Integer := Remove_Last(R)
            Print(Z)
            if R not null then
                Print(", ")
            end if
        end loop

        Print("\n")
    end func Println_It

    var L1 : Univ_List := (Elem => X, Next => null)
    var L2 : Univ_List := (Elem => Y, Next => null)
    var L3 := L1 | L2

    Print("X = "); Println(X)
    Print("Y = "); Println(Y)
    Println("Combining " | X | " and " | Y | " produces ")
    Println(L3)
    Println("Combining X | Y | X | X | Y | Y produces ")
    Println_It(L3 | X | L3 | Y)
end func PSL::Test::Test_List
interface PSL::Core::Closed_Interval<Bound_Type is Comparable<>> is
    // This provides a simple "closed" interval X..Y
    // If a type is countable, then half-open or fully open intervals
    // can be converted into the equivalent closed interval.
    var Low : Bound_Type
    var High : Bound_Type
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean
    op "=?"(Left, Right : Closed_Interval) -> Ordering
end interface PSL::Core::Closed_Interval

class PSL::Core::Closed_Interval is
  exports
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean is
        return Left >= Right.Low and then Left <= Right.High
    end op "in"

    op "=?"(Left, Right : Closed_Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.

        if Left.High < Right.Low then
            return #less
        elsif Left.Low > Right.High then
            return #greater
        elsif Left.Low == Right.Low and then
          Left.High == Right.High then
            return #equal
        else
            return #unordered
        end if
    end op "=?"
end class PSL::Core::Closed_Interval
interface PSL::Core::Interval<Bound_Type is Ordered<>> is
    // This supports closed, half-open, and open intervals.
    // This is appropriate for uncountable types where you
    // can't normalize all intervals into closed intervals.
    var Low : Bound_Type
    var Low_Is_Open : Boolean
    var High : Bound_Type
    var High_Is_Open : Boolean

    func Singleton(Val : Bound_Type) -> Interval
      // Return interval consisting of a single value

    func Is_Empty(IV : optional Interval) -> Boolean
      // Return True if interval is null or it represents
      // no values

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean

    op "=?"(Left, Right : Interval) -> Ordering
      // "#greater" means Left is strictly greater than Right
      // "#less" means Left is strictly less than Right
      // "#equal" means Left and Right are the same interval
      // "#unordered" means anything else

    func Strict_Compare(Left, Right : Interval) -> Ordered::Full_Ordering
      //  Return #equal if same interval
      //  Return #less if Left.Low[_Is_Open] < Right.Low[_Is_Open]
      //    or (Left.Low[_Is_Open] == Right.Low[_Is_Open]
      //        and Left.High[_Is_Open] < Right.High[_Is_Open])
      //  Return #greater if Left.Low[_Is_Open] > Right.Low[_Is_Open]
      //    or (Left.Low[_Is_Open] == Right.Low[_Is_Open]
      //        and Left.High[_Is_Open] > Right.High[_Is_Open])
      //  Never return #unordered

    op "and"(Left, Right : Interval) -> optional Interval
      // Return intersection of the two intervals

    op "and="(var Left : optional Interval; Right : Interval)
      // Intersect Right into Left

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> optional Interval
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)}
      // Subtract Right interval from Left

    func Overlaps(Left, Right : optional Interval) -> Boolean
      // Return True if intervals overlap

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval is "or"

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)}
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is "or="

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)}
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.

end interface PSL::Core::Interval

class PSL::Core::Interval is
  exports
    func Singleton(Val : Bound_Type) -> Interval is
      // Return interval consisting of a single value
        return (Low => Val, Low_Is_Open => #false,
          High => Val, High_Is_Open => #false)
    end func Singleton

    func Is_Empty(IV : optional Interval) -> Boolean is
      // Return True if interval is null or it represents
      // no values
        return IV is null or else
          IV.Low > IV.High or else
          (IV.Low == IV.High and then (IV.Low_Is_Open or IV.High_Is_Open))
    end func Is_Empty

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean is
        case Left =? Right.Low of
          [#less] => return #false
          [#equal] => return not Right.Low_Is_Open
          [#greater] =>
            case Left =? Right.High of
              [#less] => return #true
              [#equal] => return not Right.High_Is_Open
              [#greater] => return #false
            end case
        end case
    end op "in"

    op "=?"(Left, Right : Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.
        // Return #unordered if any of the comparisons return #unordered.

        // First check for perfect equality
        if Left.Low == Right.Low and then
          Left.High == Right.High and then
          Left.Low_Is_Open == Right.Low_Is_Open and then
          Left.High_Is_Open == Right.High_Is_Open then
            // NOTE: We are considering X..Y-1 != X..<Y since
            //       we don't require countable elements.
            return #equal
        end if

        case Left.High =? Right.Low of
          [#unordered] =>
            return #unordered
          [#less] =>
            return #less
          [#equal] =>
            if Left.High_Is_Open or else Right.Low_Is_Open then
                // No overlap
                return #less
            else
                // We have already ruled out #equal
                return #unordered
            end if
          [#greater] =>
            // Not clearly less, see whether clearly greater.
            case Left.Low =? Right.High of
              [#unordered] =>
                return #unordered
              [#less] =>
                // We have already ruled out #equal
                return #unordered
              [#equal] =>
                if Left.Low_Is_Open or else Right.High_Is_Open then
                    // No overlap
                    return #greater
                else
                    // We have already ruled out #equal
                    return #unordered
                end if
              [#greater] =>
                return #greater
            end case
        end case
    end op "=?"

    func Strict_Compare(Left, Right : Interval) -> Ordered::Full_Ordering
      //  Return #equal if same interval
      //  Return #less if Left.Low[_Is_Open] < Right.Low[_Is_Open]
      //    or (Left.Low[_Is_Open] == Right.Low[_Is_Open]
      //        and Left.High[_Is_Open] < Right.High[_Is_Open])
      //  Return #greater if Left.Low[_Is_Open] > Right.Low[_Is_Open]
      //    or (Left.Low[_Is_Open] == Right.Low[_Is_Open]
      //        and Left.High[_Is_Open] > Right.High[_Is_Open])
      //  Never return #unordered
    is
       const Low_Comp := Strict_Compare(Left.Low, Right.Low)

       if Low_Comp != #equal then
          return Low_Comp;
       elsif Left.Low_Is_Open != Right.Low_Is_Open then
          return Left.Low_Is_Open =? Right.Low_Is_Open
       else
          const High_Comp := Strict_Compare(Left.High, Right.High)
          if High_Comp != #equal then
             return High_Comp
          else
             //  Invert sense, since High_Is_Open implies the high bound
             //  is High - epsilon
             return Right.High_Is_Open =? Left.High_Is_Open
          end if
       end if
    end func Strict_Compare

    op "and"(Left, Right : Interval) -> optional Interval is
      // Return intersection of the two intervals
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
        
        case Left.Low =? Right.Low of
          [#less] => 
            New_Low := Right.Low
            New_Low_Is_Open := Right.Low_Is_Open
          [#greater] => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open
          [#equal] => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open or Right.Low_Is_Open
          [#unordered] => 
            return null
        end case

        case Left.High =? Right.High of
          [#less] => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open
          [#greater] => 
            New_High := Right.High
            New_High_Is_Open := Right.High_Is_Open
          [#equal] => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open or Right.High_Is_Open
          [#unordered] => 
            return null
        end case

        return (Low => New_Low, Low_Is_Open => New_Low_Is_Open,
          High => New_High, High_Is_Open => New_High_Is_Open)
    end op "and"

    op "and="(var Left : optional Interval; Right : Interval) is
      // Intersect Right into Left
        if Left not null then
            Left := Left and Right
        end if
    end op "and="

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean is
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.
        if Right is null or else Left is null then
            return #false
        end if
        return (Left.Low > Right.Low or else 
          (Left.Low == Right.Low and then Left.Low_Is_Open > Right.Low_Is_Open))
          and then
            (Left.High < Right.High or else
             (Left.High == Right.High and then 
              Left.High_Is_Open > Right.High_Is_Open))
    end func Is_Strictly_Within

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> Result : optional Interval is
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
        
        case Left.Low =? Right.Low of
          [#less] => 
            // Return left part of Left
            Result := (Low => Left.Low, Low_Is_Open => Left.Low_Is_Open,
              High => Right.Low, High_Is_Open => not Right.Low_Is_Open)
          [#greater] => 
            // Return right part of Left
            Result := (Low => Right.High, Low_Is_Open => not Right.High_Is_Open,
              High => Left.High, High_Is_Open => Left.High_Is_Open)
          [#equal] => 
            if Left.Low_Is_Open >= Right.Low_Is_Open then
                // Return right part of Left
                Result := (Low => Right.High, 
                  Low_Is_Open => not Right.High_Is_Open,
                  High => Left.High, 
                  High_Is_Open => Left.High_Is_Open)
            else
                // Only one element is left
                return (Left.Low, #false, Left.Low, #false)
            end if
          [#unordered] => 
            return null
        end case

        if Result.Low > Result.High then
            // Empty interval
            return null
        elsif Result.Low == Result.High and then
          (Result.Low_Is_Open or Result.High_Is_Open) then
            // Empty interval
            return null
        else
            return Result
        end if
    end op "-"

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)} is
      // Subtract Right interval from Left
        if Left not null then
            Left := Left - Right
        end if
    end op "-="

    func Overlaps(Left, Right : optional Interval) -> Boolean is
        if Left is null or else Right is null then
            return #false
        else
            case Left =? Right of
              [#equal | #unordered] => return #true
              [#less | #greater] => return #false
            end case
        end if
    end func Overlaps

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} 
      -> Result : Interval is
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
        
        Result := Left
        Result or= Right
    end op "or"

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end op "or="

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)} is
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.
        if Left is null then
            Left <== Right
        elsif Right not null then
            var Right_Copy <== Right
                // Make copy and null out Right, so
                // we don't end up with Right partially nulled out
            
            case Left.Low =? Right_Copy.Low of
              [#less] => 
                // No change to Left.Low
                null
              [#greater] => 
                Left.Low <== Right_Copy.Low
                Left.Low_Is_Open := Right_Copy.Low_Is_Open
              [#equal] => 
                Left.Low_Is_Open and= Right_Copy.Low_Is_Open
            end case

            case Left.High =? Right_Copy.High of
              [#less] => 
                Left.High <== Right_Copy.High
                Left.High_Is_Open := Right_Copy.High_Is_Open
              [#greater] => 
                // No change to Left.High
                null
              [#equal] => 
                Left.High_Is_Open and= Right_Copy.High_Is_Open
            end case
        end if
    end op "<|="

end class PSL::Core::Interval

func PSL::Test::Test_Interval(X, Y, Z : Univ_Integer) is
    var Y_Up_To_Z : Interval<Univ_Integer> := 
      (Low => Y, Low_Is_Open => #false, High => Z, High_Is_Open => #true)

    Println(X | " in " | Y | "..<" | Z | " = " | (X in Y_Up_To_Z))

    var Y_To_Z : Closed_Interval<Univ_Integer> := (Low => Y, High => Z)

    Println(X | " in " | Y | ".." | Z | " = " | (X in Y_To_Z))

    var One_To_X : Closed_Interval<Univ_Integer> :=
      (Low => 1, High => X)

    Println(1 | ".." | X | "=?" | Y | ".." | Z | " = " | 
      (One_To_X =? Y_To_Z))

end func PSL::Test::Test_Interval
interface PSL::Core::AA_Tree<Element is Ordered<>> is

    // This module implements a balanced "AA" tree, originally
    // described by Arne Andersson in the "Proceedings of the Workshop
    // on Algorithms and Data Structures," pp 60-71, Springer Verlag, 1993.
    // The following algorithm and descriptions were taken from the
    // WikiPedia article on AA_Tree: 
    //       http://en.wikipedia.org/wiki/AA_tree
    // Note that various additional checks for a null tree have been added.

    // Only two operations are needed for maintaining balance in an AA tree.
    // These operations are called skew and split. Skew is a right rotation
    // when an insertion or deletion creates a left horizontal link. Split
    // is a conditional left rotation when an insertion or deletion creates two
    // horizontal right links, which once again corresponds to two
    // consecutive red links in red-black trees.

    op "[]"() -> optional AA_Tree
        // Create an empty tree

    func Insert(var T : optional AA_Tree; X : Element)
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

    func Delete(var T : optional AA_Tree; X : Element)
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

    op "in"(X : Element; T : optional AA_Tree) -> Boolean

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.

    op "|="(var T : optional AA_Tree; X : Element) is Insert

    op "<|="(var T : optional AA_Tree; var X : optional Element)
        // Move X into AA_Tree, leaving X null.

    func First(T : optional AA_Tree) -> optional Element
      // Return first (smallest) element in tree

    func Last(T : optional AA_Tree) -> optional Element
      // Return last (greatest) element in tree

    func Any_Element(T : optional AA_Tree) -> optional Element
      // Return an arbitrary element of tree

    func Next(T : optional AA_Tree; X : Element) -> optional Element
      // Return element after X in tree, or null if no such element.
      // If X is not in tree, returns nearest element above X.

    func Prev(T : optional AA_Tree; X : Element) -> optional Element
      // Return element before X in tree, or null if no such element.
      // If X is not in tree, returns nearest element below X.

    func Min_No_Less(T : optional AA_Tree; X : Element) -> optional Element
      // Return element with minimum value no less than X in tree,
      // or null if no such element.

    func Max_No_Greater(T : optional AA_Tree; X : Element) -> optional Element
      // Return element with maximum value no greater than X in tree,
      // or null if no such element.

    func Remove_First(var T : optional AA_Tree) -> optional Element
      // Remove first (smallest) element in tree

    func Remove_Last(var T : optional AA_Tree) -> optional Element
      // Remove last (greatest) element in tree

    func Remove_Any(var T : optional AA_Tree) -> optional Element
      // Remove some element from tree

    func Count(T : optional AA_Tree) -> Univ_Integer
      // Return a count of the nodes in the tree

    op "magnitude"(AA_Tree) -> Univ_Integer is Count

    func Is_Empty(T : optional AA_Tree) -> Boolean
      // Return True if the tree is empty

    func Unsafe_Indexing(ref T : AA_Tree; X : Element) {X in T} -> ref Element
        // This is an unsafe operation, as it can destroy the integrity of the
        // tree.  If the object referred to by the result is altered, its new
        // value should compare #equal to the input X.  Otherwise, bad things
        // will happen.

end interface PSL::Core::AA_Tree

class PSL::Core::AA_Tree is
    var Value : Element
    var Level : Univ_Integer := 0
    var Left : optional AA_Tree
    var Right : optional AA_Tree

    func Node(var Value : optional Element; Level : Univ_Integer;
      Left, Right : optional AA_Tree) -> AA_Tree is
        // Create a new tree; move Value into it.
        return (Value <== Value, Level => Level, Left => Left, Right => Right)
    end func Node

    func Is_Leaf(T : optional AA_Tree) -> Boolean is
        return T not null and then
          T.Left is null and then T.Right is null
    end func Is_Leaf

    func Leftmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for L => T loop
            if L not null and then L.Left not null then
                // Continue with Left until we reach null
                continue loop with L => L.Left
            else
                // Found left-most
                return L
            end if
        end loop
    end func Leftmost

    func Successor(T : optional AA_Tree) -> optional Element is
        // Return element in tree greater than but closest to T.Value
        if T.Right not null then
            const Succ := Leftmost(T.Right)
            {Succ not null}
            return Succ.Value
        else
            return null
        end if
    end func Successor

    func Rightmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for R => T loop
            if R not null and then R.Right not null then
                // Keep following down Right side
                continue loop with R => R.Right
            else
                // Found right-most
                return R
            end if
        end loop
    end func Rightmost

    func Predecessor(T : optional AA_Tree) -> optional Element is
        // Return element in tree less than but closest to T.Value
        if T.Left not null then
            return Rightmost(T.Left).Value
        else
            return null
        end if
    end func Predecessor

    func Skew(var T : optional AA_Tree) is
      // input: T, a node representing an AA tree that needs to be rebalanced.
      // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Left not null and then
          T.Left.Level == T.Level then
            // The current T.Left becomes new root

            // Exchange value of T.Left with root
            T.Value <=> T.Left.Value
           
            // Move old root and T.Left.Right over to right side of tree
            T.Left.Right <=> T.Right
            T.Left.Left <=> T.Right
            T.Left <=> T.Right
        end if
    end func Skew

    func Split(var T : optional AA_Tree) is
        // input: T, a node representing an AA tree that needs to be rebalanced.
        // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Right not null and then
          T.Right.Right not null and then
          T.Level == T.Right.Right.Level then
            // T.Right becomes the new root
            // Exchange value and level between root and T.Right
            T.Value <=> T.Right.Value
            T.Level <=> T.Right.Level

            // Move old root and T.Right.Left to left side of tree
            T.Left <=> T.Right.Right
            T.Right.Left <=> T.Right.Right
            T.Left <=> T.Right

            // Increment level
            T.Level += 1
        end if
    end func Split

    func Decrease_Level(var T : optional AA_Tree) is
        // input: T, a tree for which we want to remove links that skip levels.
        // output: T with its level decreased.

        if T is null then
            return
        end if
           
        var Should_Be : Univ_Integer := 1

        if T.Left not null then
            Should_Be := T.Left.Level + 1
        end if

        if T.Right not null then
            Should_Be := Min(Should_Be, T.Right.Level + 1)
        end if
            
        if Should_Be < T.Level then
            T.Level := Should_Be
            if T.Right not null and then
              Should_Be < T.Right.Level then
                T.Right.Level := Should_Be
            end if
        end if
    end func Decrease_Level

  exports

    op "[]"() -> optional AA_Tree is
        // Create an empty tree
        return null
    end op "[]"

    // Insertion begins with the normal binary tree search and insertion
    // procedure. Then, as the call stack unwinds (assuming a recursive
    // implementation of the search), it's easy to check the validity of the
    // tree and perform any rotations as necessary. If a horizontal left link
    // arises, a skew will be performed, and if two horizontal right links
    // arise, a split will be performed, possibly incrementing the level of the
    // new root node of the current subtree. Note, in the code as given above,
    // the increment of T.Level. This makes it necessary to continue checking
    // the validity of the tree as the modifications bubble up from the leaves.
    
    op "<|="(var T : optional AA_Tree; var X : optional Element) is
        // Move X into AA_Tree, leaving X null.
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

        // Do the normal binary tree insertion procedure. 
        // Set the result of the recursive call to the correct 
        // child in case a new node was created or the
        // root of the subtree changes.

        if T is null then
            // Create a new leaf node with X.
            T := Node(X, 1, null, null)
            return
        end if

        case Strict_Compare(X, T.Value) of
          [#less] =>
            T.Left <|= X
          [#greater] =>
            T.Right <|= X
          [#equal | #unordered] =>
            // Note that the case of X == T.Value is unspecified. 
            // As given, an insert will have no effect. 
            // The implementor may desire different behavior.
            X := null
            return
        end case

        // Perform skew and then split. 
        // The conditionals that determine whether or
        // not a rotation will occur or not are inside 
        // of the procedures, as given above.

        Skew(T)
        Split(T)
    end op "<|="

    func Insert(var T : optional AA_Tree; X : Element) is
        // Just pass the buck to the "<|=" operation
        var X_Copy for T := X
        T <|= X_Copy
    end func Insert

    // As in most balanced binary trees, the deletion of an internal node can
    // be turned into the deletion of a leaf node by swapping the internal node
    // with either its closest predecessor or successor, depending on which are
    // in the tree or on the implementor's whims. Retrieving a predecessor is
    // simply a matter of following one left link and then all of the remaining
    // right links. Similarly, the successor can be found by going right once
    // and left until a null pointer is found. Because of the AA property of
    // all nodes of level greater than one having two children, the successor
    // or predecessor node will be in level 1, making their removal trivial.
    // 
    // To re-balance a tree, there are a few approaches. The one described by
    // Andersson in his original paper is the simplest, and it is described
    // here, although actual implementations may opt for a more optimized
    // approach. After a removal, the first step to maintaining tree validity
    // is to lower the level of any nodes whose children are two levels below
    // them, or who are missing children. Then, the entire level must be skewed
    // and split. This approach was favored, because when laid down
    // conceptually, it has three easily understood separate steps:
    // 
    //     Decrease the level, if appropriate.
    //     Skew the level.
    //     Split the level.
    // 
    // However, we have to skew and split the entire level this time instead of
    // just a node, complicating our code.

    func Delete(var T : optional AA_Tree; X : Element) is
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

        if T is null then
            // Not in tree -- should we complain?
            return
        end if

        case Strict_Compare(X, T.Value) of
          [#less] =>
            Delete(T.Left, X)
          [#greater] =>
            Delete(T.Right, X)
          [#equal] =>
            // If we're a leaf, easy, otherwise reduce to leaf case. 
            if Is_Leaf(T) then
                T := null
            elsif T.Left is null then
                // Get successor value and delete it from right tree,
                // and set root to have that value
                const Succ := Successor(T)
                Delete(T.Right, Succ)
                T.Value := Succ
            else
                // Get predecessor value and delete it from left tree,
                // and set root to have that value
                const Pred := Predecessor(T)
                Delete(T.Left, Pred)
                T.Value := Pred
            end if
          [#unordered] =>
            // Not in tree; should we complain?
            return
        end case

        // Rebalance the tree. Decrease the level of all nodes in this level if
        // necessary, and then skew and split all nodes in the new level.

        if T is null then
            return
        end if

        Decrease_Level(T)
        Skew(T)
        Skew(T.Right)
        if T.Right not null then
            Skew(T.Right.Right)
        end if
        Split(T)
        Split(T.Right)
    end func Delete

    op "in"(X : Element; T : optional AA_Tree) -> Result : Boolean is
        for P => T while P not null loop
            case Strict_Compare(X, P.Value) of
              [#less] =>
                continue loop with P => P.Left
              [#greater] =>
                continue loop with P => P.Right
              [#equal] =>
                return #true
              [#unordered] =>
                return #false
            end case
        end loop
        return #false   // Not found
    end op "in"

    func First(T : optional AA_Tree) -> optional Element is
      // Return first (smallest) element in tree
        if T is null then
            return null
        else 
            return Leftmost(T).Value
        end if
    end func First

    func Last(T : optional AA_Tree) -> optional Element is
      // Return last (greatest) element in tree
        if T is null then
            return null
        else
            return Rightmost(T).Value
        end if
    end func Last

    func Any_Element(T : optional AA_Tree) -> optional Element is
      // Return an arbitrary element of tree
        if T is null then
            return null
        end if
        return T.Value
    end func Any_Element

    func Next(T : optional AA_Tree; X : Element) -> optional Element is
      // Return element after X in tree, or null if no such element.
      // If X is not in tree, returns nearest element above X.
        if T is null then
            return null
        else
            case Strict_Compare(X, T.Value) of
              [#less] =>
                //  Recurse on Left half
                const Result := Next(T.Left, X)
                if Result not null then
                    //  Recursion found the result
                    return Result
                else
                    //  Found nearest element above X
                    return T.Value
                end if
              [#greater] =>
                //  Recurse on Right half
                return Next(T.Right, X)
              [#equal] =>
                return Successor(T)
              [#unordered] =>
                return Successor(T)
            end case
        end if
    end func Next

    func Prev(T : optional AA_Tree; X : Element) -> optional Element is
      // Return element before X in tree, or null if no such element.
      // If X is not in tree, returns nearest element below X.
        if T is null then
            return null
        else
            case Strict_Compare(X, T.Value) of
              [#less] =>
                //  Recurse on Left half
                return Prev(T.Left, X)
              [#greater] =>
                //  Recurse on Right half
                const Result := Prev(T.Right, X)
                if Result not null then
                    //  Recursion found the result
                    return Result
                else
                    //  This is nearest element below X
                    return T.Value
                end if
              [#equal] =>
                return Predecessor(T)
              [#unordered] =>
                return Predecessor(T)
            end case
        end if
    end func Prev

    func Min_No_Less(T : optional AA_Tree; X : Element) -> optional Element is
      // Return element with minimum value no less than X in tree,
      // or null if no such element.
        if T is null then
            return null
        else
            case Strict_Compare(X, T.Value) of
              [#less] =>
                //  Recurse on Left half
                const Result := Min_No_Less(T.Left, X)
                if Result not null then
                    //  Recursion found the result
                    return Result
                else
                    //  Found min element above X
                    return T.Value
                end if
              [#greater] =>
                //  Recurse on Right half
                return Min_No_Less(T.Right, X)
              [#equal] =>
                // Perfect match is fine
                return T.Value
              [#unordered] =>
                // Close enough!
                return T.Value
            end case
        end if
    end func Min_No_Less

    func Max_No_Greater(T : optional AA_Tree; X : Element)
      -> optional Element is
      // Return element with maximum value no greater than X in tree,
      // or null if no such element.
        if T is null then
            return null
        else
            case Strict_Compare(X, T.Value) of
              [#less] =>
                //  Recurse on Left half
                return Max_No_Greater(T.Left, X)
              [#greater] =>
                //  Recurse on Right half
                const Result := Max_No_Greater(T.Right, X)
                if Result not null then
                    //  Recursion found the result
                    return Result
                else
                    //  This is max element below X
                    return T.Value
                end if
              [#equal] =>
                // Perfect match is fine
                return T.Value
              [#unordered] =>
                // Close enough!
                return T.Value
            end case
        end if
    end func Max_No_Greater

    func Remove_First(var T : optional AA_Tree) -> Result : optional Element is
      // Remove first (smallest) element in tree
        if T is null then
            return null
        elsif T.Left is null then
            //  Fast path
            Result := T.Value
            if T.Right is null then
                //  Fast path
                T := null
                return
            end if
        else
            Result := First(T)
        end if
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_First

    func Remove_Last(var T : optional AA_Tree) -> Result : optional Element is
      // Remove last (greatest) element in tree
        if T is null then
            return null
        elsif T.Right is null then
            // Fast path
            Result := T.Value
            if T.Left is null then
                // Fast path
                T := null
                return
            end if
        else
            Result := Last(T)
        end if
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_Last

    func Remove_Any(var T : optional AA_Tree) -> Result : optional Element is
      // Remove some element from tree
        if T is null then
            return null
        end if
        Result := T.Value
        if Result not null then
            if T.Left is null and then T.Right is null then
                //  Fast path the single-range case
                T := null
            else
                Delete(T, Result)
            end if
        end if
    end func Remove_Any

    func Is_Empty(T : optional AA_Tree) -> Boolean is
      // Return True if the tree is empty
        return T is null
    end func Is_Empty

    func Count(T : optional AA_Tree) -> Univ_Integer is
      // Return a count of the nodes in the tree
        if T is null then
            return 0
        else
            return Count(T.Left) + Count(T.Right) + 1
        end if
    end func Count

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element is
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.
        if T is null or else T.Value is null then
            return null
        else
            case X =? T.Value of
              //  Note -- we do *not* want to use Strict_Compare here
              //  as this is mainly used for Range_Set where "=?" on
              //  the intervals that make up a Range_Set has a particular
              //  meaning for "=?" which is a *partial* ordering.
              [#less] =>
                return Overlapping(T.Left, X)
              [#greater] =>
                return Overlapping(T.Right, X)
              [#equal | #unordered] =>
                // Close enough
                return T.Value
            end case
        end if
    end func Overlapping

    func Unsafe_Indexing(ref T : AA_Tree; X : Element) {X in T}
      -> ref Element is
        // This is an unsafe operation, as it can destroy the integrity of the
        // tree.  If the object referred to by the result is altered, its new
        // value should compare #equal to the input X.  Otherwise, bad things
        // will happen.

        {T not null and then T.Value not null}

        case Strict_Compare(X, T.Value) of
          [#less] =>
            return Unsafe_Indexing(T.Left, X)
          [#greater] =>
            return Unsafe_Indexing(T.Right, X)
          [#equal | #unordered] =>
            // Close enough
            return T.Value
        end case
        
    end func Unsafe_Indexing

end class PSL::Core::AA_Tree

func PSL::Test::Test_AA_Tree
  (A : Univ_Integer; B : Univ_Integer; C : Univ_Integer) is
    type Univ_Tree is AA_Tree<Univ_Integer>
    var T : Univ_Tree := []
    var X : Univ_Integer := A

    Insert(T, A)
    Println("Count = " | Count(T) | " after insert of " | A)
    Insert(T, B)
    Println("Count = " | Count(T) | " after insert of " | B)
    Insert(T, C)
    Println("Count = " | Count(T) | " after insert of " | C)

    Insert(T, A)
    Println("Count = " | Count(T) | " after another insert of " | A)

    Println(A | " in T = " | (A in T))
    Println(B | " in T = " | (B in T))
    Println(C | " in T = " | (C in T))
    Println("7 in T = " | (7 in T))

    for E := Remove_First(T) then Remove_First(T) while E not null loop
        Println("Remove_First = " | E)
    end loop

    Println("Count after loop : " | Count(T))

    for I in 1..10 forward loop
        Insert(T, I)
        Println("Count = " | Count(T) | " after insert of " | I)
    end loop

    for L := Remove_Last(T) then Remove_Last(T) while L not null loop
        Println("Remove_Last = " | L)
    end loop

    Println("Count after loop : " | Count(T))

    for J in 1..10 reverse loop
        Insert(T, J)
        Println("Count = " | Count(T) | " after insert of " | J)
    end loop

    Println("Count after loop : " | Count(T))

    Println("Overlapping(T, 5) = " | Overlapping(T, 5))

    for Z := Remove_Any(T) then Remove_Any(T) while Z not null loop
        Println("Remove_Any = " | Z)
    end loop

    Println("Count after loop : " | Count(T))

    for K in 1..10 loop
        Insert(T, K)
        Println("Count = " | Count(T) | " after insert of " | K)
    end loop

    for F := Remove_First(T) then Remove_First(T) while F not null loop
        Println("Remove_First = " | F)
    end loop

    Println("Count after loop : " | Count(T))

end func PSL::Test::Test_AA_Tree
abstract interface PSL::Containers::Keyed<Key_Type is Hashable<>> is
    func Key_Of(ref const KV : Keyed) -> ref const Key_Type
    func Has_Value(KV : Keyed) -> Boolean
        // Return #true if Keyed object has a non-null value
    func Key_Only(Key : Key_Type) -> Keyed
        // Return a Keyed object given a key, having no associated value
end interface PSL::Containers::Keyed

interface PSL::Containers::Basic_Key_Value
  <Key_Type is Assignable<>; Value_Type is Assignable<>>  is
  // This supports the use of [Key => Value] as a way to
  // add a single element to an existing indexable container of some sort.
    var Key : optional Key_Type
    var Value : optional Value_Type
    op "[]"() -> Basic_Key_Value is ((Key => null, Value => null))
    op "var_indexing"(ref var KV : Basic_Key_Value; Index : Key_Type) 
      -> ref var Value_Type
end interface PSL::Containers::Basic_Key_Value

class PSL::Containers::Basic_Key_Value is
  exports
    op "var_indexing"(ref var KV : Basic_Key_Value; Index : Key_Type) 
      -> ref var Value_Type is
        KV.Key := Index
        return KV.Value
    end op "var_indexing"
end class PSL::Containers::Basic_Key_Value

interface PSL::Containers::Key_Value
  extends Basic_Key_Value
  implements Keyed<Key_Type> is
  // This supports the use of [Key => Value] as a way to
  // add a single element to an existing indexable container of some sort.
    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type
    func Has_Value(KV : Key_Value) -> Boolean
        // Return #true if Key_Value object has a non-null value
    func Key_Only(Key : Key_Type) -> Key_Value is ((Key => Key, Value => null))
        // Return a Key_Value object given a key, having no associated value
end interface PSL::Containers::Key_Value

class PSL::Containers::Key_Value is
  exports
    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type is
        return KV.Key
    end func Key_Of

    func Has_Value(KV : Key_Value) -> Boolean is
        // Return #true if Key_Value object has a non-null value
        return KV.Value not null
    end func Has_Value
end class PSL::Containers::Key_Value

interface PSL::Containers::Basic_Map<KV_Type is Keyed<>> is
  // A basic hashed-map module

    op "[]"() -> Basic_Map

    op "|="(var Left : Basic_Map; Right : KV_Type)
        // Add Key=>Value to Basic_Map, replacing pre-existing Basic_Mapping
        // for Key, if any.

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type)
        // Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
        // for Key, if any, leaving Right null.

    op "+="(var Left : Basic_Map; Right : KV_Type) is "|="
        // A synonym for adding a key=>value KV_Type

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean
        // Return True if given key has a Basic_Mapping in the Basic_Map

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type)   // aka Exclude
        // Remove Basic_Mapping for Right, if present

    op "index_set"(M : Basic_Map) -> Set<KV_Type::Key_Type>
        // Return set of keys with Basic_Mappings

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type
        // Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Basic_Map) -> optional KV_Type
        // Remove one Basic_Mapping from the Basic_Map.  
        // Return null if Basic_Map is empty

    func Any_Element(M : Basic_Map) -> optional KV_Type
        // Return one Basic_Mapping from the Basic_Map.
        // Return null if Basic_Map is empty

    func Count(M : Basic_Map) -> Univ_Integer
        // Number of Basic_Mappings in the table

    op "magnitude"(Basic_Map) -> Univ_Integer is Count

    func Is_Empty(M : Basic_Map) -> Boolean
        // Return True if map has no mappings

    func Dump_Statistics(M : Basic_Map)
      // A debugging routine to show bucket sizes of Basic_Map

end interface PSL::Containers::Basic_Map

class PSL::Containers::Basic_Map is
  // A basic hashed-map module

  // A Basic_Map is represented as a hash table, where each bucket is 
  // a linked list of key/value KV_Types.
  // We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface Hash_Bucket<> is
      // a simple linked-list is used as a hash bucket
        var Elem : optional KV_Type
        var Tail : optional Hash_Bucket
    end interface Hash_Bucket

    var Count : Univ_Integer
    var Table : optional Basic_Array<optional Hash_Bucket<>>
    const Initial_Table_Size := 4
    const Debugging : Boolean := #false
    
    func Empty(Table_Size : Univ_Integer) -> Basic_Map is
        // Create an empty Basic_Map with the given table size
        return (Count => 0, Table => Create(Table_Size, null))
    end func Empty

    func Move_One(var To : Basic_Map; var Elem : optional KV_Type) is
        // Move Element into table, without expanding table.
        // Elem is set to null as a result.
        const Index := Hash(Key_Of(Elem)) mod |To.Table| + 1
        ref Bucket => To.Table[Index]

        if Bucket is null then
            // Bucket is now empty, so create bucket
            // with Elem as its only element.
            Bucket := (Elem <== Elem, Tail => null)
        else
            // See whether Elem already in bucket
            var Has_Empty_Slot : Boolean := #false
            for B => Bucket then B.Tail while B not null loop
                if B.Elem is null then
                    // Remember there is an empty slot
                    Has_Empty_Slot := #true
                elsif Key_Of(Elem) == Key_Of(B.Elem) then
                    // Already there; replace it in case Value is different.
                    B.Elem <== Elem
                    return
                end if
            end loop

            if Has_Empty_Slot then
                // Fill in the empty slot
                for B => Bucket then B.Tail while B not null loop
                    if B.Elem is null then
                        // Use the empty slot
                        B.Elem <== Elem
                        exit loop
                    end if
                end loop
            else
                // Make old bucket the new tail of the new bucket.
                Bucket := (Elem <== Elem, Tail <== Bucket)
            end if
        end if

        To.Count += 1
    end func Move_One

    func Add_One(var To : Basic_Map; Elem : KV_Type) is
        // Add Element to table, without expanding it
        var Elem_Copy for To := Elem

        // Just pass the buck to "Move_One"
        Move_One(To, Elem_Copy)
    end func Add_One

    func Expand_Table(var Expanding : Basic_Map) is
        // Expand table of given Basic_Map.
        if Debugging then
            Println(" Expanding hash table, Count = " | Expanding.Count | 
              ", Length = " | |Expanding.Table|)
        end if
        var Old_Basic_Map <== Expanding
        Expanding := Empty(2 * |Old_Basic_Map.Table|)
        // Move elements into new table
        loop
            var Elem for Expanding := Remove_Any(Old_Basic_Map)
                // "for Expanding" means to allocate Elem in
                // region associated with Expanding.
            if Elem is null then
                exit loop
            end if
            Move_One(Expanding, Elem)
        end loop
        if Debugging then
            Println(" After expansion, Count = " | Expanding.Count |
              ", Length = " | |Expanding.Table|)
        end if
    end func Expand_Table

  exports
    op "[]"() -> Basic_Map is
        return (Count => 0, Table => null)
    end op "[]"

    op "|="(var Left : Basic_Map; Right : KV_Type) is
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            // Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if
        Add_One(Left, Right)
    end op "|="

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type) is
        // Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
        // for Key, if any, leaving Right null.
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            // Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if
        Move_One(Left, Right)
    end op "<|="

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean is
        if Right.Count == 0 then
            // Empty Basic_Map
            return #false
        end if
        const Index := Hash(Left) mod Length(Right.Table) + 1
        ref Bucket => Right.Table[Index]
        if Bucket is null then
            // Hash bucket is empty
            return #false
        end if
        // Scan for Elem in hash bucket
        for B => Bucket then B.Tail while B not null loop 
            if B.Elem not null and then
              Key_Of(B.Elem) == Left then
                // Found it
                return #true
            end if
        end loop
        // Not in Basic_Map
        return #false
    end op "in"

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type) is
      // Remove the given key from the Basic_Map, if present
        if M.Count == 0 then
            // Empty Basic_Map
            return
        end if

        const Index := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        if Bucket is null then
            // Hash bucket is empty
            return
        end if

        // Scan for Key in bucket
        for B => Bucket then B.Tail while B not null loop
            if B.Elem not null and then
              Key_Of(B.Elem) == Key then
                // Found it.  Map it to null, and decrement Basic_Map count.
                B.Elem := null
                M.Count -= 1
                return
            end if
        end loop
        // Not found
    end op "-="
   
    op "index_set"(M : Basic_Map) -> Result : Set<KV_Type::Key_Type> is
        // Return set of keys with non-null Basic_Mappings
        Result := []
        if M.Count == 0 then
            return
        end if
        for each Bucket of M.Table loop
            for B => Bucket then B.Tail while B not null loop
                if B.Elem not null then
                    Result |= Key_Of(B.Elem)
                end if
            end loop
        end loop
    end op "index_set"

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type is
        // Used for references to M[Key]; requires the Key to be in M.
        {M not null; M.Count > 0}
        const Index := Hash(Key) mod Length(M.Table) + 1
        // Scan for Key in bucket
        for B => M.Table[Index] then B.Tail while B not null loop
            if B.Elem not null and then Key_Of(B.Elem) == Key then
               // Found it.  Return reference to element of KV_Type
               return B.Elem
            end if
        end loop
        {#false}
    end op "indexing"

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type is
        // Used for assignments to M[Key]; Key is added to M if not present
        if M.Table not null then
            const Index := Hash(Key) mod Length(M.Table) + 1
            // Scan for Key in bucket
            for B => M.Table[Index] then B.Tail while B not null loop
                if B.Elem not null and then
                  Key_Of(B.Elem) == Key
                then
                    // Found it.  Return reference to element of KV_Type
                    return B.Elem
                end if
            end loop
        end if

        // Not in table.  Add it, and then return reference
        if M.Table is null then
            M := Empty(Initial_Table_Size)
        elsif M.Count >= 2*Length(M.Table) then
            // Expand table if averaging 2 or more per hash bucket
            Expand_Table(M)
        end if

        // Add [Key => null] to front of appropriate bucket.
        const Index := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        Bucket := (Elem => Key_Only(Key), Tail <== Bucket)
        M.Count += 1

        // Return ref to new element
        return Bucket.Elem
    end op "var_indexing"

    func Count(M : Basic_Map) -> Univ_Integer is
        if M is null then
            return 0
        else
            return M.Count
        end if
    end func Count

    func Is_Empty(M : Basic_Map) -> Boolean is
        // Return True if map has no mappings
        return M.Count == 0
    end func Is_Empty

    func Remove_Any(var M : Basic_Map) -> Result : optional KV_Type is
        if M.Count == 0 then
            // Basic_Map is empty
            return null
        else
            // Find a non-empty bucket and pull out an item.
            for each Bucket of M.Table loop
                if Bucket not null then
                    for B => Bucket then B.Tail while B not null loop 
                        if B.Elem not null then
                            // Found an item, remove from Bucket and return
                            Result <== B.Elem
                            M.Count -= 1
                            return
                        end if
                    end loop
                    // This bucket is completely empty, so might
                    // as well empty it out.
                    Bucket := null
                end if
                // Go on to the next bucket, this one's empty
            end loop
            // Should never get here
            return null
        end if
    end func Remove_Any

    func Any_Element(M : Basic_Map) -> optional KV_Type is
        // Return one Basic_Mapping from the Basic_Map.
        // Return null if Basic_Map is empty
        if M.Count == 0 then
            // Basic_Map is empty
            return null
        else
            // Find a non-empty bucket and return first item found
            for each Bucket of M.Table loop
                if Bucket not null then
                    for B => Bucket then B.Tail while B not null loop 
                        if B.Elem not null then
                            // Found an item; return it.
                            return B.Elem
                        end if
                    end loop
                end if
                // Go on to the next bucket, this one's empty
            end loop
            // Should never get here
            return null
        end if
    end func Any_Element

    func Dump_Statistics(M : Basic_Map) is
      // A debugging routine to show bucket sizes of Basic_Map
        Println("Basic_Map statistics: Count = " | M.Count)
        if M.Table is null then
            Println(" Table is null")
        else
            Println(" Table of length " | Length(M.Table))
            for each [I => Bucket] of M.Table forward loop
                Print("  Bucket #" | I)
                if Bucket is null then
                    Println(" is null")
                else
                    var Len := 0
                    var Holes := 0
                    for B => Bucket then B.Tail while B not null loop
                        Len += 1
                        if B.Elem is null then
                            // This list has a hole
                            Holes += 1
                        end if
                    end loop
                    if Holes > 0 then
                        Println(" of length " | Len | " with " | 
                          Holes | " holes")
                    else
                        Println(" of length " | Len)
                    end if
                end if
            end loop
        end if
    end func Dump_Statistics

end class PSL::Containers::Basic_Map

func PSL::Test::Test_Basic_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    type Enum_String_KV_Type is Key_Value<Univ_Enumeration, Univ_String>
    type Enum_String_Basic_Map is Basic_Map<Enum_String_KV_Type>

    var M : Enum_String_Basic_Map := [X => [X => Y], A => [A => B]]

    Println("Count = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
        Println(K | " in M = " | (K in M))
    end loop

    Println("#xy in M = " | (#xy in M))
    
    M -= X

    Println("Count after deletion = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    M -= A

    Println("Count after deletion = " | Count(M))

    for each KV of M loop
        ref const K => KV.Key
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
    end loop

    var Ran := Random::Start(Hash(A))
    var MUI : Basic_Map<Key_Value<Univ_Integer, Univ_Integer>> := []

    Println("Adding 100 random KV_Typeings to Basic_Map.")
    for I in 1..100 loop
        const Key := Next(Ran) mod 100
        const Value := Next(Ran) mod 100
        MUI[Key] := [Key => Value]
    end loop
    Println("Basic_Map is now of count = " | Count(MUI))

    for each [K => KV] of MUI loop
        ref const V => KV.Value
        Println("Basic_Mapping " | K | " => " | V)
        Println("MUI[" | K | "] = " | MUI[K].Value)
    end loop

    var I := 0
    for KV_Type in MUI loop
        I += 1
        Print(" [" | Key_Of(KV_Type) | " => " | KV_Type.Value | "]")
        if I mod 5 == 0 then
            Print('\n')
        end if
    end loop
    if I mod 5 != 0 then
        Print('\n')
    end if

end func PSL::Test::Test_Basic_Map
class PSL::Containers::Set is
  // A hashed-set module

  // A Set is represented as a hash table, where each bucket is a linked list.
  // When elements are deleted from the Set they end up a "null"s in the
  // list.  We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface KV_Wrapper<> implements Keyed<Element_Type> is
      // Create a wrapper for a key that implements the Keyed interface
        var Key : Element_Type
        func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type
        func Has_Value(KV : KV_Wrapper) -> Boolean
            // Return #true if KV_Wrapper object has a non-null value
        func Key_Only(Key : Element_Type) -> KV_Wrapper
            // Return a KV_Wrapper object given a key, 
            // having no associated value
    end interface KV_Wrapper

    class KV_Wrapper is
      // Create a wrapper for a key that implements the Keyed interface
      exports
        func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type is
            return KV.Key
        end func Key_Of

        func Has_Value(KV : KV_Wrapper) -> Boolean is
            // Return #true if KV_Wrapper object has a non-null value
            return #true
        end func Has_Value

        func Key_Only(Key : Element_Type) -> KV_Wrapper is
            // Return a KV_Wrapper object given a key, 
            // having no associated value.
            // NOTE: This is not really meaningful for sets, since there
            //       isn't a value.
            return (Key => Key)
        end func Key_Only
    end class KV_Wrapper
        
    var Data : Basic_Map<KV_Wrapper<>>
        // Set is represented as a map from keys to nothing.

  exports
    op "[]"() -> Set is
        return (Data => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Set is
        Result := []
        Result.Data |= (Key => Elem)
    end func Singleton

    op "|"(Left, Right : Element_Type) -> Result : Set is
        Result := []
        Result.Data |= (Key => Left)
        Result.Data |= (Key => Right)
    end op "|"

    op "|"(Left : Set; Right : Element_Type) -> Result : Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Set) -> Result : Set is
        Result := Right
        Result |= Left
    end op "|"

    op "|"(Left : Set; Right : Set) -> Result : Set is
        // Union, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            Result := Right
            Result |= Left
        else
            Result := Left
            Result |= Right
        end if
    end op "|"

    op "|="(var Left : Set; Right : Set) is
        if Count(Left.Data) == 0 then
            Left := Right
        else
            for Elem in Right loop
                Left |= Elem
            end loop
        end if
    end op "|="

    op "|="(var Left : Set; Right : Element_Type) is
        Left.Data |= (Key => Right)
    end op "|="

    op "<|="(var Left : Set; var Right : optional Element_Type) is
        // Move Right into Set Left
        var KV : KV_Wrapper := (Key <== Right)
        Left.Data <|= KV
    end op "<|="

    op "<|="(var Left : Set; var Right : Set) is
        // Move all elements of Right into Left, leaving Right empty.
        loop
            // Extract element from Right, in region for Left
            var Elem for Left := Remove_Any(Right)
            if Elem is null then
                // All done
                return
            end if
            // Move element into Left
            Left <|= Elem
        end loop
    end op "<|="

    op "in"(Left : Element_Type; Right : Set) -> Boolean is
        return Left in Right.Data
    end op "in"

    op "=?"(Left, Right : Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right.Data) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right.Data) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    op "and"(Left, Right : Set) -> Result : Set is
        // Intersection, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            // Left is smaller
            Result := []
            for Elem in Left loop
                if Elem in Right then
                    Result |= Elem
                end if
            end loop
        else
            // Left is bigger
            Result := Left
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
        end if
    end op "and"

    op "and="(var Left : Set; Right : Set) is
        // Intersection, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            // Left is smaller
            for Elem in Left loop
                if Elem not in Right then
                    Left -= Elem
                end if
            end loop
        else
            // Left is bigger
            var Result : Set for Left := []
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
            Left <== Result
        end if
    end op "and="

    op "xor"(Left, Right : Set) -> Result : Set is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        if Count(Left.Data) < Count(Right.Data) then
            // Swap order to shorten iteration
            Result := Right
            Result xor= Left
        else
            Result := Left
            Result xor= Right
        end if
    end op "xor"
    
    op "xor="(var Left : Set; Right : Set) is
        // Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end op "xor="

    op "-"(Left, Right : Set) -> Result : Set is
        // Set difference, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            // Left is smaller, build up 
            Result := []
            for Elem in Left loop
                if Elem not in Right then
                    Result |= Elem
                end if
            end loop
        else
            // Left is bigger, tear down
            Result := Left
            Result -= Right
        end if
    end op "-"

    op "-="(var Left : Set; Right : Set) is
        // Compute Set difference
        for Elem in Right loop
            Left -= Elem
        end loop
    end op "-="

    op "-="(var S : Set; Elem : Element_Type) is
      // Remove the given element from the Set, if present
        S.Data -= Elem
    end op "-="
   
    func Count(S : Set) -> Univ_Integer is
        return Count(S.Data)
    end func Count

    func Is_Empty(S : Set) -> Boolean is
        return Is_Empty(S.Data)
    end func Is_Empty

    func Remove_Any(var S : Set) -> Result : optional Element_Type is
        var Result_Wrapper for Result := Remove_Any(S.Data)
        if Result_Wrapper is null then
            return null
        else
            Result <== Result_Wrapper.Key
        end if
    end func Remove_Any

    func Any_Element(S : Set) -> Result : optional Element_Type is
      // Return an arbitrary element of the Set S;
      // return null if S is empty.
        const Result_Wrapper for Result := Any_Element(S.Data)
        if Result_Wrapper is null then
            return null
        else
            return Result_Wrapper.Key
        end if
    end func Any_Element

    //  Provide custom streaming operations
    op "write" (var Output_Object_Stream;
                Obj : optional Set;
                Is_Optional : Boolean) is
       Write_Optional_Default (Output_Object_Stream, Obj);
    end op "write";

    op "read"  (var Input_Object_Stream;
                var Obj : optional Set;
                Is_Optional : Boolean) is
       Read_Optional_Default (Input_Object_Stream, Obj);
    end op "read";

    optional func Dump_Statistics(S : Set) is
      // A debugging routine to show bucket sizes of Set
        Dump_Statistics(S.Data)
    end func Dump_Statistics

end class PSL::Containers::Set

func PSL::Test::Test_Set(A, X, Y, Z : Univ_Integer) is
    var S : Set<Univ_Integer> := X | Y | Z
    if A in S then
        Println(A | " is in " | X | "|" | Y | "|" | Z)
    else
        Println(A | " is *not* in " | X | "|" | Y | "|" | Z)
    end if

    const Save_Set := S

    const CSet : Set<Univ_Integer> := [Z, Y, X]
    Println("[Z, Y, X] =? (X | Y | Z) --> " |
      ( CSet =? S ))

    var Ran := Random::Start(A)
    Println("Adding 100 random digits to Set.")
    for I in 1..100 loop
        const N := Next(Ran) mod 100
        S |= N
        S |= N  // Make sure it doesn't produce duplicates
    end loop
    Println("Set is now of count = " | Count(S))
    Println("Contents of Set:")
    var I := 1
    for Elem in S loop
        Print(Elem | " ")
        if I mod 10 == 0 then
            Print('\n')
        end if
        I += 1
    end loop
    if Count(S) mod 10 != 0 then
        Print('\n')
    end if
    Println("S Before adding random elements =? now --> " |
      (Save_Set =? S))
    Println("S =? S --> " | (S =? S))

    var Small_Set : Set<Univ_Integer> := []
    Small_Set += -1
    Small_Set or= [2]

    Println("S =? (-1 | 2) --> " | (S =? Small_Set))
    Println("[2 , -1] =? (-1 | 2) --> " | ([2, -1] =? Small_Set))

    Println("S =? [] --> " | (S =? []))

    Println("Count(S) = " | Count(S))
    
    const Before_Exclude := S
    S -= X
    Println("After Exclude(S, " | X | "), Count(S) = " | Count(S))
    Println("Before_Exclude =? After Exclude --> " | (Before_Exclude =? S))

    Dump_Statistics(S)
end func PSL::Test::Test_Set
class PSL::Containers::Countable_Set is
    //  A set of values of a "countable" type (e.g. integer or enum),
    //  where we can efficiently represent intervals (i.e. contiguous ranges)
    //  of values of the type, allowing large sets to be handled.

    type Element_Interval is Countable_Range<Element_Type>

    func Saturating_Plus(Left, Right : Univ_Integer) -> Univ_Integer is
       //  Do a "careful" plus to avoid overflow
        const Half := Left/2 + Right/2
        if Half >= Univ_Integer::Last()/2 then
            return Univ_Integer::Last()
        elsif Half <= Univ_Integer::First()/2 then
            return Univ_Integer::First()
        else
            return Left + Right
        end if
    end func Saturating_Plus

    func Len(IV : Element_Interval) -> Univ_Integer is
       // Return length of interval (last - first + 1)
       // but avoid returning a value > Univ_Integer::Last()
       if IV.First + Univ_Integer::Last()/2 <=
         IV.Last - Univ_Integer::Last()/2
       then
          //  Overflow -- TBD: Someday Univ_Integer will be inf. precision
          return Univ_Integer::Last()
       else
          return IV.Last - IV.First + 1
       end if
    end func Len

    var Items : optional AA_Tree<Element_Interval>

    func Is_Subset(IV : Element_Interval; Set : Countable_Set) -> Boolean is
      //  Return #true if all of IV is in Set
       if IV.First > IV.Last then
          //  Empty set is a subset of anything
          return #true
       else
          const OV := Overlapping(Set.Items, IV)

          if OV is null then
             //  No overlapping inteval
             return #false
          elsif IV.First < OV.First
            and then not Is_Subset(IV.First ..< OV.First, Set)
          then
             //  Part on left is not in Set
             return #false
          elsif OV.Last < IV.Last
            and then not Is_Subset(OV.Last <.. IV.Last, Set)
          then
             //  Part on right is not in Set
             return #false
          else
             //  IV is fully contained in Set
             return #true
          end if
       end if
    end func Is_Subset

    func Intersect(IV : Element_Interval; Set : Countable_Set)
      -> Result : Countable_Set is
      //  Return intersection of interval and set as a set
       if IV.First > IV.Last then
          //  Empty set
          return []
       else
          const OV := Overlapping(Set.Items, IV)

          if OV is null then
             //  No overlapping inteval
             return []
          end if

          var Low := OV.First
          var High := OV.Last

          if IV.First < OV.First then
             //  Include Left part
             Result := Intersect(IV.First ..< OV.First, Set)
          else
             Result := []
             Low := IV.First
          end if

          if OV.Last < IV.Last then
             //  Intersect in right part
             Result |= Intersect(OV.Last <.. IV.Last, Set)
          else
             High := IV.Last
          end if

          //  Include common part of IV and OV
          Insert(Result.Items, Low .. High)

       end if
        
    end func Intersect

  exports
    op "[]"() -> Countable_Set is
        return (Items => [])
    end op "[]"

    op "[..]"() -> Countable_Set is
        return Element_Type::First() .. Element_Type::Last()
    end op "[..]"

    func Singleton(Elem : Element_Type) -> Result : Countable_Set is
        Result := []
        Result.Items |= (First => Elem, Last => Elem)
    end func Singleton

    op ".."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (First => Left, Last => Right)
        end if
    end op ".."
    
    op "<.."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (First => Left+1, Last => Right)
        end if
    end op "<.."
    
    op "<..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right-1 then
            Result.Items |= (First => Left+1, Last => Right-1)
        end if
    end op "<..<"
    
    op "..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (First => Left, Last => Right-1)
        end if
    end op "..<"
    
    op "|"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left >= Right-1 and then Left <= Right + 1 then
            // Can combine elements into a single interval
            if Left <= Right then
                Result.Items |= (First => Left, Last => Right)
            else
                Result.Items |= (First => Right, Last => Left)
            end if
        else
            // Make each element its own interval
            Result.Items |= (First => Left, Last => Left)
            Result.Items |= (First => Right, Last => Right)
        end if
    end op "|"

    op "|"(Left : Countable_Set; Right : Element_Type) 
      -> Result : Countable_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Countable_Set) -> Countable_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Countable_Set; Right : Countable_Set) 
      -> Result : Countable_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Countable_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := (First => Right, Last => Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end op "|="

    op "<|="(var Left : Countable_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
        // NOTE: No copy minimization done for countable types.
        Left |= Right
        Right := null
    end op "<|="

    op "<|="(var Left : Countable_Set; var Right : Countable_Set) is
        // Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items
        else
            // Iterate through the tree
            loop
                // Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)

                if Right_IV is null then
                    return   // All done
                end if

                // See whether it overlaps with an existing interval
                // in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    if Left_IV.First <= Right_IV.First and then
                      Left_IV.Last >= Right_IV.Last then
                        // Right_IV is subsumed; nothing to add in
                        Right_IV := null
                        exit loop
                    else
                        // Need to delete Left_IV and incorporate
                        // into Right_IV
                        Delete(Left.Items, Left_IV)
                        if Left_IV.First < Right_IV.First then
                            Right_IV :=
                              (First => Left_IV.First, Last => Right_IV.Last)
                        end if
                        if Left_IV.Last > Right_IV.Last then
                            Right_IV :=
                              (First => Right_IV.First, Last => Left_IV.Last)
                        end if

                        // Now see if there is anything still overlapping
                        Left_IV := Overlapping(Left.Items, Right_IV)
                    end if
                end loop

                if Right_IV not null then
                    // Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end op "<|="

    op "|="(var Left : Countable_Set; Right : Countable_Set) is
        // Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end op "|="

    op "-"(Left, Right : Countable_Set) -> Result : Countable_Set is
      // Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-"(Left : Countable_Set; Right : Element_Type)
      -> Result : Countable_Set is
      // Remove one element
        Result := Left
        Result -= Right
    end op "-"
        
    op "-="(var S : Countable_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
        const IV := Overlapping(S.Items, (First => Elem, Last => Elem))
          // Get interval, if any, which overlaps given element

        if IV not null then
            // Delete interval and put back after removing Elem
            Delete(S.Items, IV)
            if IV.Last > IV.First then
                // We need to put something back
                if IV.First == Elem then
                    S.Items |= (First => IV.First + 1, Last => IV.Last)
                elsif IV.Last == Elem then
                    S.Items |= (First => IV.First, Last => IV.Last-1)
                else
                    // Elem is in the middle, put back intervals
                    // on either side.
                    S.Items |= (First => IV.First, Last => Elem-1)
                    S.Items |= (First => Elem+1, Last => IV.Last)
                end if
            end if
        end if

    end op "-="

    op "-="(var Left : Countable_Set; Right : Countable_Set) is
      // Remove all elements of Right from Left, if present
        for Right_IV in Right.Items loop
            loop
                const IV := Overlapping(Left.Items, Right_IV)
                  // Get next interval, if any, which overlaps Right_IV

                if IV is null then
                    exit loop
                end if

                // Delete interval and put back after removing Right_IV
                Delete(Left.Items, IV)
                if IV.Last > IV.First then
                    // We need to put something back
                    if IV.First >= Right_IV.First then
                        //  First part of IV removed
                        if IV.Last > Right_IV.Last then
                            Left.Items |=
                              (First => Right_IV.Last + 1, Last => IV.Last)
                        end if
                    elsif IV.Last <= Right_IV.Last then
                        //  Last part of IV removed
                        Left.Items |=
                          (First => IV.First, Last => Right_IV.First - 1)
                    else
                        // Right_IV is in the middle, put back intervals
                        // on either side.
                        Left.Items |=
                          (First => IV.First, Last => Right_IV.First - 1)
                        Left.Items |=
                          (First => Right_IV.Last + 1, Last => IV.Last)
                    end if
                end if
            end loop
        end loop

    end op "-="

    op "and"(Left, Right : Countable_Set) -> Result : Countable_Set is
        // Intersection
        Result := []
        for Left_IV in Left.Items loop
           Result |= Intersect(Left_IV, Right)
        end loop
    end op "and"

    op "and="(var Left : Countable_Set; Right : Countable_Set) is
        // Intersection
        Left := Left and Right
    end op "and="

    op "xor"(Left, Right : Countable_Set) -> Result : Countable_Set is
        // Symmetric difference
        Result := Left
        Result xor= Right
    end op "xor"

    op "xor="(var Left : Countable_Set; Right : Countable_Set) is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        if Count(Left) > Count(Right) then
           for Elem in Right loop
               if Elem in Left then
                   Left -= Elem
               else
                   Left += Elem
               end if
           end loop
        else
           var New_Left for Left := Right
           for Elem in Left loop
              if Elem in Right then
                 New_Left -= Elem
              else
                 New_Left += Elem
              end if
           end loop
           Left <== New_Left
        end if
    end op "xor="

    op "in"(Left : Element_Type; Right : Countable_Set) -> Boolean is
        return Overlapping(Right.Items, (First => Left, Last => Left)) not null
    end op "in"

    op "=?"(Left, Right : Countable_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        const Left_Is_Subset_Of_Right :=
          (for all Left_IV in Left.Items => Is_Subset(Left_IV, Right))
        const Right_Is_Subset_Of_Left :=
          (for all Right_IV in Right.Items => Is_Subset(Right_IV, Left))

        if Left_Is_Subset_Of_Right then
           if Right_Is_Subset_Of_Left then
              return #equal
           else
              return #less
           end if
        else
           if Right_Is_Subset_Of_Left then
              return #greater
           else
              return #unordered
           end if
        end if
    end op "=?"

    func Strict_Compare(Left, Right : Countable_Set) -> Ordered::Full_Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less or #greater based on a lexicographical ordering
        // Never return #unordered
    is
        for (Left_Elem in Left; Right_Elem in Right) forward loop
           const Result := Strict_Compare(Left_Elem, Right_Elem);
           if Result != #equal then
              return Result
           end if
        end loop
        return |Left| =? |Right|
    end func Strict_Compare

    func Count(S : Countable_Set) -> Result : Univ_Integer is
        // Return count of items in set

        Result := 0

        // Iterate through them to build up count
        for Next_IV in S.Items loop
            Result := Saturating_Plus(Result, Len (Next_IV))
        end loop
    end func Count

    func Is_Empty(S : Countable_Set) -> Boolean is
        return Is_Empty(S.Items)
    end func Is_Empty

    func First(S : Countable_Set) -> optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.First
        end if
    end func First

    func Last(S : Countable_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.Last
        end if
    end func Last

    func Any_Element(S : Countable_Set) -> optional Element_Type is
        const Any_IV := Any_Element(S.Items)
        if Any_IV is null then
            return null
        elsif (Any_IV.Last - Any_IV.First) mod 2 == 0 then
            // Return high bound when high-low is even
            // NOTE: We do this to avoid having algorithms become
            //       dependent on always getting values in ascending 
            //       or descending order.
            return Any_IV.Last
        else
            // Return low bound when high-low is odd
            return Any_IV.First
        end if
    end func Any_Element

    op "indexing"(S : Countable_Set; Index : Univ_Integer)
      -> optional Element_Type is
         //  Return "Index"th element of set S, counting 1 .. Count(S)
         if Index <= 0 then
             return null
         end if

         var Start_Offset := Index - 1

         for IV in S.Items forward loop
             const IV_Len := Len (IV)
             if Start_Offset < IV_Len then
                 //  It is in this interval
                 return IV.First + Start_Offset
             end if
             Start_Offset -= IV_Len
         end loop

         return null
    end op "indexing"

    op "slicing"(S : Countable_Set; 
      Index_Set : Countable_Range<Univ_Integer>) -> Result : Countable_Set is
         //  Return subset of set S, elements S[Index_Set.First] through
         //  S[Index_Set.Last], counting 1 .. Count(S)
         var Start_Offset := Index_Set.First - 1
         var End_Offset := Index_Set.Last - 1

         Result := []

         if Start_Offset < 0 then
             Start_Offset := 0
         end if

         if End_Offset < Start_Offset then
             return
         end if

         for IV in S.Items forward loop
             const IV_Len := Len (IV)
             if Start_Offset < IV_Len then
                 //  It starts in this interval
                 if End_Offset < IV_Len then
                     //  It ends in this interval as well
                     Result.Items |=
                        (First => IV.First + Start_Offset,
                         Last => IV.First + End_Offset)
                     return
                 else
                     //  It extends to the next interval
                     Result.Items |=
                        (First => IV.First + Start_Offset,
                         Last => IV.Last)
                     Start_Offset := 0
                 end if
             else
                 Start_Offset -= IV_Len
             end if
             End_Offset -= IV_Len
         end loop
    end op "slicing"

    op "/"(Set : Countable_Set; Num_Pieces : Univ_Integer)
      -> Result : Vector<Countable_Set> is
       // Divide a set into a vector of sets, each of similar size
        {> Num_Pieces > 0 <}

        if Num_Pieces <= 1 then
            //  Return a vector of length 1 if Num_Pieces is 1 (or less)
            return Create(1, Set)
        end if

        const Size := Count(Set)
        const Small_Piece_Size := Size / Num_Pieces
        const Big_Piece_Size := Small_Piece_Size + 1
        const Num_Big_Pieces := Size rem Num_Pieces

        //  Create the result
        Result := Create(Num_Pieces, [])

        //  Fill in the elements of the result vector with slices of the set.
        var Index := 1

        //  Big pieces first
        for I in 1 .. Num_Big_Pieces forward loop
            Result[I] := Set[Index .. Index + Big_Piece_Size - 1]
            Index += Big_Piece_Size
        end loop

        //  Small pieces next
        if Small_Piece_Size > 0 then
            for I in Num_Big_Pieces + 1 .. Num_Pieces forward loop
                Result[I] := Set[Index .. Index + Small_Piece_Size - 1]
                Index += Small_Piece_Size
            end loop
        end if

        {> Index == Size + 1 <}
            
    end op "/"

    func Remove_First(var S : Countable_Set) 
      -> Result : optional Element_Type is
        // Return first element of set

        // Get first interval in tree
        var First_IV := Remove_First(S.Items)
        if First_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if First_IV.Last > First_IV.First then
            // Need to put back the remainder
            S.Items |= (First => First_IV.First+1, Last => First_IV.Last)
        end if

        // Return first item
        return First_IV.First
    end func Remove_First

    func Remove_Last(var S : Countable_Set) -> Result : optional Element_Type is
        // Remove last element of set

        // Get Last interval in tree
        var Last_IV := Remove_Last(S.Items)
        if Last_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if Last_IV.Last > Last_IV.First then
            // Need to put back the remainder
            S.Items |= (First => Last_IV.First, Last => Last_IV.Last-1)
        end if

        // Return Last item
        return Last_IV.Last
    end func Remove_Last

    func Remove_Any(var S : Countable_Set) -> optional Element_Type is
        // Remove any element of set

        // Get any interval in tree
        var Any_IV := Remove_Any(S.Items)
        if Any_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if Any_IV.Last > Any_IV.First then
            // Need to remove one to return and put back the remainder
            if (Any_IV.Last - Any_IV.First) mod 2 == 0 then
                // Return high bound when high-low is even
                // NOTE: We do this to avoid having algorithms become
                //       dependent on always getting values in ascending 
                //       or descending order.
                S.Items |= (First => Any_IV.First, Last => Any_IV.Last-1)
                return Any_IV.Last
            else
                // Return low bound when high-low is odd
                S.Items |= (First => Any_IV.First+1, Last => Any_IV.Last)
                return Any_IV.First
            end if
        else
            // Return only item in interval
            return Any_IV.First
        end if

    end func Remove_Any

    func Ranges(S : Countable_Set) ->
      Result : Ordered_Set<Countable_Range<Element_Type>> is
        // Return set of disjoint ranges that represent the set of values in S
        Result := []
        var Cur_Range : Countable_Range<Element_Type> for Result := []
        var Copy_Of_Items for Result := S.Items
        var Next_Range for Result := Remove_First(Copy_Of_Items)

        while Next_Range not null loop
            if Cur_Range.Last < Cur_Range.First then
                //  Was empty range, remember first range
                Cur_Range <== Next_Range
            elsif Cur_Range.Last+1 == Next_Range.First then
                //  Combine contiguous ranges
                Cur_Range :=
                  (First => Cur_Range.First, Last => Next_Range.Last)
            else
                //  Discontiguous ranges, add Cur_Range to result and update
                Result <|= Cur_Range
                Cur_Range <== Next_Range
            end if
            Next_Range := Remove_First(Copy_Of_Items)
        end loop

        if Cur_Range.Last >= Cur_Range.First then
            //  Include last range
            Result <|= Cur_Range
        end if
    end func Ranges

end class PSL::Containers::Countable_Set

func PSL::Test::Test_Countable_Set(A, X, Y, Z : Integer) is
    var S : Countable_Set<Integer> := X | Y..Z
    Println(A | " in " | X | "|" | Y | ".." | Z | "=" | ( A in S ))

    const Agg : Countable_Set<Integer> := [X, Y, Z]
    const Or : Countable_Set<Integer> := Y | Z | X

    Println(" [X, Y, Z] =? (Y | Z | X) --> " | ( Agg =? Or ))

    for J in S loop 
        Println("Remove_Any(S) = " | J)
    end loop

    S := []

    for I in 1..10 forward loop
        S += I
        Println("Adding " | I | " to S, Count = " | Count(S))
    end loop

    for K in S loop 
        Println("Remove_Any(S) = " | K)
    end loop

    Println("Count(S) = " | Count(S))
    S -= 7
    Println("After S -= 7, Count(S) = " | Count(S))

    var Xor := S xor [2, 5, 12, 15]
    Print("S xor [2, 5, 12, 15] = ")
    for J in Xor forward loop
        Print(J | " ")
    end loop
    Print('\n')

    for I in -1 .. 11 forward loop
       Println("S[" | I | "] = " | S[I])
    end loop

    for I in -1 .. 11 forward loop
        for J in I-2 .. I + 5 forward loop
            Print("S[" | I | " .. " | J | "] = ")
            const Slice := S[I .. J]
            for K in Slice forward loop
                Print(K | " ")
            end loop
            Print('\n')
        end loop
    end loop

    for Num in 1 .. 11 forward loop
       Print("S / " | Num | " =")
       for each Piece of S / Num forward loop
          Print (" {")
          for J in Piece forward loop
              Print(J | " ")
          end loop
          Print ("}")
       end loop
       Print('\n')
    end loop
end func PSL::Test::Test_Countable_Set
interface PSL::Containers::Range_Set<Element_Type is Ordered<>> is
  // A set abstraction that supports efficiently storing potentially
  // large ranges of values

    op "[]"() -> Range_Set

    func Singleton(Elem : Element_Type) -> Range_Set
        // Return a set consisting of a single element

    func Single_Interval(Ival : Interval<Element_Type>) -> Range_Set
        // Return a set consisting of a single interval

    op ".."(Left, Right : Element_Type) -> Range_Set
        // Closed interval of values
    op "<.."(Left, Right : Element_Type) -> Range_Set
        // Open-Closed interval of values
    op "..<"(Left, Right : Element_Type) -> Range_Set
        // Closed-Open interval of values
    op "<..<"(Left, Right : Element_Type) -> Range_Set
        // Open interval of values

    op "|"(Left, Right : Element_Type) -> Range_Set
    op "|"(Left : Range_Set; Right : Element_Type) -> Range_Set
    op "|"(Left : Element_Type; Right : Range_Set) -> Range_Set
    op "|"(Left : Range_Set; Right : Range_Set) -> Range_Set

    op "|="(var Left : Range_Set; Right : Element_Type)
    op "|="(var Left : Range_Set; Right : Range_Set)
    op "|="(var Left : Range_Set; Right : Interval<Element_Type>)

    op "<|="(var Left : Range_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Range_Set; var Right : Range_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Range_Set) -> Range_Set
      // Set difference
    op "-="(var S : Range_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Range_Set; Right : Range_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Range_Set; Right : Range_Set) 
      -> Range_Set is "|"   // union
    op "or="(var Left : Range_Set; Right : Range_Set) is "|="

    op "+"(Left : Range_Set; Right : Range_Set) 
      -> Range_Set is "|"   // Union
    op "+="(var Left : Range_Set; Right : Range_Set) is "|="
    op "+="(var Left : Range_Set; Right : Element_Type) is "|="

    //  TBD: op "+="(var Left : Range_Set; Right : Interval<Element_Type>) is "|="
   
    op "and"(Left, Right : Range_Set) -> Range_Set
        // Intersection
    op "and="(var Left : Range_Set; Right : Range_Set)

    op "xor"(Left, Right : Range_Set) -> Range_Set
        // Symmetric difference
    op "xor="(var Left : Range_Set; Right : Range_Set)

    op "in"(Left : Element_Type; Right : Range_Set) -> Boolean

    op "=?"(Left, Right : Range_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
    func Strict_Compare(Left, Right : Range_Set) -> Ordered::Full_Ordering
        //  Return #equal if same interval
        //  Return #less if Left.Low[_Is_Open] < Right.Low[_Is_Open]
        //    or (Left.Lower_Bound[_Is_Open] == Right.Lower_Bound[_Is_Open]
        //        and Left.Upper_Bound[_Is_Open] < Right.Upper_Bound[_Is_Open])
        //  Return #greater if Left.Lower_Bound[_Is_Open] >
        //                         Right.Lower_Bound[_Is_Open]
        //    or (Left.Lower_Bound[_Is_Open] == Right.Lower_Bound[_Is_Open]
        //        and Left.Upper_Bound[_Is_Open] > Right.Upper_Bound[_Is_Open])
        //  Never return #unordered

    func Is_Empty(S : Range_Set) -> Boolean

    func Lower_Bound(S : Range_Set) -> optional Element_Type
        // Lower bound of set
    func Lower_Bound_Is_Open(S : Range_Set) -> Boolean
        // Whether lower bound is "open" or "closed"

    func Upper_Bound(S : Range_Set) -> optional Element_Type
        // Upper bound of set
    func Upper_Bound_Is_Open(S : Range_Set) -> Boolean
        // Whether upper bound is "open" or "closed"

    func Remove_First(var S : Range_Set) -> optional Interval<Element_Type>
        // Remove first interval of set (lowest low bound)

    func Remove_Last(var S : Range_Set) -> optional Interval<Element_Type>
        // Remove last interval of set (highest high bound)

    func Remove_Any(var S : Range_Set) -> optional Interval<Element_Type>
        // Remove an arbitrary interval of set

    func Add_Interval
      (var Left : Range_Set; var Right : Interval<Element_Type>)
       // Move all elements of Right into Left, leaving Right empty.
       // See whether Right overlaps with an existing interval
       // in Left tree

end interface PSL::Containers::Range_Set

class PSL::Containers::Range_Set is

    type Element_Interval is Interval<Element_Type>

    var Items : optional AA_Tree<Element_Interval>

    func Remove_Interval(var S : Range_Set; Remove_IV : Element_Interval) is
      // Remove the given interval from the set, if present
        if Remove_IV.Low > Remove_IV.High then
            // Nothing to remove
            return
        end if

          // Find an interval within the AA_Tree that overlaps
        for Remaining_IV := Remove_IV while Remaining_IV not null loop
            // Get overlap, if any
            var IV := Overlapping(S.Items, Remaining_IV)

            if IV is null then
                // No overlap, nothing left to remove
                exit loop
            end if
        
            // Found an overlapping interval; delete and add back what's left
            Delete(S.Items, IV)
            if Is_Strictly_Within(Remaining_IV, IV) then
                // Add back left and right remnants
                // Remaining_IV is fully subsumed.
                S.Items |= (Low => IV.Low, Low_Is_Open => IV.Low_Is_Open, 
                  High => Remaining_IV.Low, 
                  High_Is_Open => not Remaining_IV.Low_Is_Open)
                S.Items |= (Low => Remaining_IV.High, 
                  Low_Is_Open => not Remaining_IV.High_Is_Open,
                  High => IV.High, 
                  High_Is_Open => IV.High_Is_Open)
                // we are all done now
                exit loop
            end if

            // May be something left
            const Overlap := IV and Remaining_IV
            IV -= Overlap

            if not Is_Empty(IV) then
                // Worth putting the interval back
                S.Items |= IV
            end if

            continue loop with Remaining_IV => Remaining_IV - Overlap

        end loop

    end func Remove_Interval

    func Is_Subset(Left, Right : Range_Set) -> Boolean is
        // Return True if Left is a subset of Right
        for Left_IV in Left loop
            for Remaining_IV := Left_IV while not Is_Empty(Remaining_IV) loop
                const Right_IV := Overlapping(Right.Items, Remaining_IV)
                if Right_IV is null then
                    // Found some values that are not in Right
                    return #false
                end if

                // Loop around with what is left
                continue loop with Remaining_IV => Remaining_IV - Right_IV
            end loop
        end loop
        // Everything in Left was found in Right
        return #true
    end func Is_Subset

  exports
    op "[]"() -> Range_Set is
        return (Items => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Range_Set is
        // Return a set consisting of a single element
        Result := []
        Result.Items |= Singleton(Elem)
    end func Singleton

    func Single_Interval(Ival : Interval<Element_Type>)
      -> Result : Range_Set is
        // Return a set consisting of a single interval
        Result := []
        Result.Items |= Ival
    end func Single_Interval

    op ".."(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false, 
              High => Right, High_Is_Open => #false)
        end if
    end op ".."
    
    op "<.."(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
              High => Right, High_Is_Open => #false)
        end if
    end op "<.."
    
    op "<..<"(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
              High => Right, High_Is_Open => #true)
        end if
    end op "<..<"
    
    op "..<"(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false,
              High => Right, High_Is_Open => #true)
        end if
    end op "..<"
    
    op "|"(Left, Right : Element_Type) -> Result : Range_Set is
        Result := []
        Result |= Left
        if Left != Right then
            Result |= Right
        end if
    end op "|"

    op "|"(Left : Range_Set; Right : Element_Type) 
      -> Result : Range_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Range_Set) -> Range_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Range_Set; Right : Range_Set) 
      -> Result : Range_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Range_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := Singleton(Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end op "|="

    op "<|="(var Left : Range_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
        // TBD: No copy minimization done at the moment
        Left |= Right
        Right := null
    end op "<|="

    op "|="(var Left : Range_Set; Right : Range_Set) is
        if Count(Left.Items) == 0 then
            Left := Right
        else
            // Make a copy of the Right set
            var Right_Copy for Left := Right

            // Merge all of its intervals into Left
            Left <|= Right_Copy
        end if
    end op "|="

    op "<|="(var Left : Range_Set; var Right : Range_Set) is
        // Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items
        else
            // Iterate through the tree
            loop
                // Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)
                if Right_IV is null then
                    return
                end if

                Add_Interval (Left, Right_IV);
            end loop
        end if
    end op "<|="

    op "|="(var Left : Range_Set; Right : Interval<Element_Type>) is
        if Count(Left.Items) == 0 then
            Left := Single_Interval(Right)
        else
            // Make a copy of the Right set
            var Right_Copy for Left := Right

            // Merge all of its intervals into Left
            Add_Interval (Left, Right_Copy)
        end if
    end op "|="

    op "-"(Left, Right : Range_Set) -> Result : Range_Set is
      // Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-="(var S : Range_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
        Remove_Interval(S, Singleton(Elem))
    end op "-="

    op "-="(var Left : Range_Set; Right : Range_Set) is
      // Remove all intervals of Right from Left, if present
        for IV in Right loop
            Remove_Interval(Left, IV)
        end loop
    end op "-="

    op "and"(Left, Right : Range_Set) -> Result : Range_Set is
        // Intersection

        // Add elements that are in both Right and Left into result
        Result := []

        var Right_Pieces := Right;

        for Right_IV := Remove_Any(Right_Pieces) then Remove_Any(Right_Pieces)
          while Right_IV not null
        loop
            var Left_IV := Overlapping(Left.Items, Right_IV)

            if Left_IV is null then
                continue loop
            end if

            // Compute overlap and add into result
            const Overlap := Right_IV and Left_IV

            Result.Items |= Overlap

            //  Create a set out of Right_IV and remove interval Overlap
            //  from it, and then add what is left back into Right_Pieces.
            var Right_IV_Set for Right_Pieces := Single_Interval(Right_IV);

            Remove_Interval(Right_IV_Set, Overlap);
            Right_Pieces <|= Right_IV_Set;
        end loop
    end op "and"

    op "and="(var Left : Range_Set; Right : Range_Set) is
        // Intersection
        Left := Left and Right
    end op "and="

    op "xor"(Left, Right : Range_Set) -> Range_Set is
        // Symmetric difference

        return (Left - Right) or (Right - Left)
    end op "xor"

    op "xor="(var Left : Range_Set; Right : Range_Set) is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        const Only_In_Right := Right - Left
        Left -= Right
        Left += Only_In_Right
    end op "xor="

    op "in"(Left : Element_Type; Right : Range_Set) -> Boolean is
        return Overlapping(Right.Items, Singleton(Left)) not null
    end op "in"

    op "=?"(Left, Right : Range_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        if Is_Subset(Left, Right) then
            if Is_Subset(Right, Left) then
                return #equal
            else
                return #less
            end if
        elsif Is_Subset(Right, Left) then
            return #greater
        else
            return #unordered
        end if
    end op "=?"

    func Strict_Compare(Left, Right : Range_Set) -> Ordered::Full_Ordering
        //  Return #equal if same interval
        //  Return #less if Left.Low[_Is_Open] < Right.Low[_Is_Open]
        //    or (Left.Lower_Bound[_Is_Open] == Right.Lower_Bound[_Is_Open]
        //        and Left.Upper_Bound[_Is_Open] < Right.Upper_Bound[_Is_Open])
        //  Return #greater if Left.Lower_Bound[_Is_Open] >
        //                         Right.Lower_Bound[_Is_Open]
        //    or (Left.Lower_Bound[_Is_Open] == Right.Lower_Bound[_Is_Open]
        //        and Left.Upper_Bound[_Is_Open] > Right.Upper_Bound[_Is_Open])
        //  Never return #unordered
    is
        const Low_Comp :=
          Strict_Compare(Left.Lower_Bound(), Right.Lower_Bound())

        if Low_Comp != #equal then
           return Low_Comp;
        elsif Left.Lower_Bound_Is_Open() != Right.Lower_Bound_Is_Open() then
           return Left.Lower_Bound_Is_Open() =? Right.Lower_Bound_Is_Open()
        else
           const High_Comp :=
             Strict_Compare(Left.Upper_Bound(), Right.Upper_Bound())
           if High_Comp != #equal then
              return High_Comp
           else
              //  Invert sense, since High_Is_Open implies the high bound
              //  is High - epsilon
              return Right.Upper_Bound_Is_Open() =? Left.Upper_Bound_Is_Open()
           end if
        end if
    end func Strict_Compare

    func Is_Empty(S : Range_Set) -> Boolean is
        // Return count of items in set
        return Count(S.Items) == 0
    end func Is_Empty

    func Lower_Bound(S : Range_Set) -> optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end func Lower_Bound

    func Lower_Bound_Is_Open(S : Range_Set) -> Boolean is
        const First_IV := First(S.Items)
        if First_IV is null then
            return #true   // TBD: or null?
        else
            return First_IV.Low_Is_Open
        end if
    end func Lower_Bound_Is_Open

    func Upper_Bound(S : Range_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end func Upper_Bound

    func Upper_Bound_Is_Open(S : Range_Set) -> Boolean is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return #true   // TBD: or null?
        else
            return Last_IV.High_Is_Open
        end if
    end func Upper_Bound_Is_Open

    func Remove_First(var S : Range_Set) 
      -> optional Interval<Element_Type> is
        // Remove first interval of set (lowest low bound)
        return Remove_First(S.Items)
    end func Remove_First

    func Remove_Last(var S : Range_Set) 
      -> optional Interval<Element_Type> is
        // Remove last interval of set (highest high bound)
        return Remove_Last(S.Items)
    end func Remove_Last

    func Remove_Any(var S : Range_Set) 
      -> optional Interval<Element_Type> is
        // Remove an arbitrary interval of set
        return Remove_Any(S.Items)
    end func Remove_Any

    func Add_Interval
      (var Left : Range_Set; var Right : Interval<Element_Type>) is
       // Move all elements of Right into Left, leaving Right empty.
       // See whether Right overlaps with an existing interval
       // in Left tree
       var Left_IV for Left := Overlapping(Left.Items, Right)
       while Left_IV not null loop
           // Incorporate left interval into Right
           Right |= Left_IV

           if Right == Left_IV then
               // Right fully subsumed by existing interval
               Right := null
               exit loop
           end if

           // Need to delete Left_IV 
           Delete(Left.Items, Left_IV)

           // Now see if there is anything still overlapping
           Left_IV := Overlapping(Left.Items, Right)
       end loop

       if not Is_Empty(Right) then
           // Add Right
           Left.Items <|= Right
       end if
    end func Add_Interval

end class PSL::Containers::Range_Set

func PSL::Test::Test_Range_Set(A, X, Y, Z : Univ_Real) is
    var S : Range_Set<Univ_Real> := X | Y..Z
    Println(A | " in " | X | "|" | Y | ".." | Z | "=" | ( A in S ))

    const Agg : Range_Set<Univ_Real> := [X, Y, Z]
    const Or : Range_Set<Univ_Real> := Y | Z | X
    const Open_Ind : Map<Boolean, Univ_String> := [#false => "", #true => "<"]

    Println(" [X, Y, Z] =? (Y | Z | X) --> " | ( Agg =? Or ))

    S := []

    var R := 0.0
    for I in 1..10 forward loop
        R += 1.0
        S += R
        Println("Adding " | R | " to S, Is_Empty(S) = " | Is_Empty(S))
    end loop

    var Xor := S xor [2.0, 5.0, 12.0, 15.0]
    Print("S xor [2.0, 5.0, 12.0, 15.0] = ")
    for IV in Xor forward loop
        if IV.Low != IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] | ".." | 
              Open_Ind[IV.High_Is_Open] | IV.High | " ")
        else
            Print(IV.Low | " ")
        end if
    end loop
    Print('\n')
end func PSL::Test::Test_Range_Set
interface PSL::Core::Univ_Real<> is
    op "+"(Right : Univ_Real) -> Univ_Real
      is import(#identity)

    op "-"(Right : Univ_Real) -> Univ_Real
      is import(#real_negate)

    op "abs"(Right : Univ_Real) -> Univ_Real
      is import(#real_abs)

    op "magnitude"(Univ_Real) -> Univ_Real is "abs"

    op "+"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_add)

    op "-"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_subtract)

    op "*"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_multiply)

    op "*"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_int_multiply)

    op "*"(Left : Univ_Integer; Right : Univ_Real) -> Univ_Real

    op "/"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_divide)

    op "/"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_int_divide)

    op "**"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_exp)

    op "+="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_add)

    op "-="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_subtract)

    op "*="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_multiply)

    op "/="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_divide)

    op "**="(var Left : Univ_Real; Right : Univ_Integer) 
      is import(#real_assign_exp)


    op "=?"(Left, Right : Univ_Real) -> Ordering
      is import(#real_compare)
    func Strict_Compare(Left, Right : Univ_Real) -> Ordered::Full_Ordering
      is import(#real_compare)

    func Min(Left, Right : optional Univ_Real) -> optional Univ_Real
      is import(#real_min)
    func Max(Left, Right : optional Univ_Real) -> optional Univ_Real
      is import(#real_max)

    func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Univ_Real
      is import(#real_sqrt)

    func Hash(Val : Univ_Real) -> Unsigned_64
      is import(#identity)

    func To_String(Val : optional Univ_Real) -> Univ_String
      is import(#to_string_real)

    func From_String(Str : Univ_String) -> optional Univ_Real
      is import(#from_string_real)

    func Print(X : Univ_Real) is import(#print_real)
    func Println(X : Univ_Real) is (Println(To_String(X)))

    func Round_To_Int(Real : Univ_Real) -> Univ_Integer
      is import(#round_to_int)

    func Trunc_To_Int(Real : Univ_Real) -> Univ_Integer
      is import(#trunc_to_int)

    func Floor_To_Int(Real : Univ_Real) -> Univ_Integer
      is import(#floor_to_int)

    func Int_To_Real(Int : Univ_Integer) -> Univ_Real
      is import(#int_to_real)

    op "in"(Left : Univ_Real; Right : Range_Set<Univ_Real>) -> Boolean
      is in Range_Set<Univ_Real>

end interface PSL::Core::Univ_Real

class PSL::Core::Univ_Real is
  exports
    op "*"(Left : Univ_Integer; Right : Univ_Real) -> Univ_Real is
        // Hand off to built-in real * int op
        return Right * Left
    end op "*"

    // func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Result : Univ_Real is
    //     {Val >= 0.0}
    //     Result := Val / 2.0
    //     while Result > 0.0 and then Result * Result / Val 
    //       not in 0.9999999999999 .. 1.00000000000001 loop
    //         Result := (Val / Result + Result)/2.0
    //     end loop
    // end func Sqrt

end class PSL::Core::Univ_Real
    
func PSL::Test::Test_Real() is
    var X := 3.5
    var Y := 5.22
    var Z := X + Y

    Println("X = " | X | ", Y = " | Y | ", X + Y = " | Z)
    var Teeny := 0.000023
    Println("Teeny = " | Teeny)
    var Small := 0.005
    Println("Small = " | Small)
    var Medium := 235.123
    Println("Medium = " | Medium)
    var Big := 11.0**5
    Println("Big = " | Big)
    var Huge := 13.0**15
    Println("Huge = " | Huge)

    Println("Y in 1.0 .. 6.0 = " | ( Y in 1.0 .. 6.0 ))
    
    Println("Y in 1.0 ..< 5.22 = " | ( Y in 1.0 ..< 5.22 ))

    Println("Sqrt(2.0) = " | Sqrt(2.0))

    var Neg := -2.0;
    Println("Sqrt(-2.0) = " | Sqrt(Neg))
end func PSL::Test::Test_Real

interface PSL::Core::Rational<> is
    //  Infinite precision rational numbers
    func Create (Num, Den : Univ_Integer) -> Rational;

    const Zero : Rational := Create (Num => 0, Den => 1);
    const One : Rational := Create (Num => 1, Den => 1);
    const Two : Rational := Create (Num => 2, Den => 1);
    const One_Half : Rational := Create (Num => 1, Den => 2);
    
    func Num (Rational) -> Univ_Integer;
    func Den (Rational) -> Univ_Integer;

    func Inf () -> Rational is (Create (1, 0));
    func Minus_Inf () -> Rational is (Create (-1, 0));

    op "+"(Right : Rational) -> Rational is (Right);

    op "-"(Right : Rational) -> Rational

    op "abs"(Right : Rational) -> Rational

    op "magnitude"(Rational) -> Rational is "abs"

    op "+"(Left, Right : Rational) -> Result : Rational 

    op "-"(Left, Right : Rational) -> Result : Rational

    op "*"(Left, Right : Rational) -> Result : Rational 

    op "*"(Left : Rational; Right : Univ_Integer) -> Rational

    op "*"(Left : Univ_Integer; Right : Rational) -> Rational

    op "/"(Left, Right : Rational) -> Result : Rational

    op "/"(Left : Rational; Right : Univ_Integer) -> Rational

    op "**"(Left : Rational; Right : Univ_Integer) -> Rational

    op "+="(var Left : Rational; Right : Rational) 

    op "-="(var Left : Rational; Right : Rational) 

    op "*="(var Left : Rational; Right : Rational) 

    op "/="(var Left : Rational; Right : Rational) 

    op "**="(var Left : Rational; Right : Univ_Integer) 


    func Strict_Compare(Left, Right : Rational)
      -> Ordered::Full_Ordering
    op "=?"(Left, Right : Rational) -> Ordering is Strict_Compare

    func Min(Left, Right : optional Rational) -> optional Rational
    func Max(Left, Right : optional Rational) -> optional Rational

    func Sqrt(Val : Rational {Val >= Zero}) -> Rational;

    func Hash(Val : Rational) -> Unsigned_64;

    func To_String(Val : optional Rational) -> Univ_String

    func From_String(Str : Univ_String) -> optional Rational

    op "from_univ" (Val : Univ_Real) -> Rational is import(#float_to_rat)
    op "to_univ" (Val : Rational) -> Univ_Real is import(#rat_to_float)

    func Print(X : Rational)
    func Println(X : Rational) is (Println(To_String(X)))

    func Round_To_Int(Rational : Rational) -> Univ_Integer

    func Trunc_To_Int(Rational : Rational) -> Univ_Integer

    func Floor_To_Int(Rational : Rational) -> Univ_Integer

    func Int_To_Rational(Int : Univ_Integer) -> Rational

    op "in"(Left : Rational; Right : Range_Set<Rational>) -> Boolean
      is in Range_Set<Rational>

end interface PSL::Core::Rational

class PSL::Core::Rational is
    const Num : Univ_Integer;
    const Den : Univ_Integer;

    func Reduce (Num, Den : Univ_Integer) -> Rational is
       //  Reduce by GCD
       case Den =? 0 of
         [#less] =>
          return Reduce (-Num, -Den);
         [#equal] =>
          return (Num => Num / abs(Num), Den => 0);
         [#greater] =>
          const Div := GCD (Num, Den);

          return (Num => Num / Div, Den => Den / Div);
       end case;
    end func Reduce;

  exports

    func Create (Num, Den : Univ_Integer) -> Rational is
      (Reduce (Num => Num, Den => Den));

    func Num (Rational) -> Univ_Integer is (Rational.Num);
    func Den (Rational) -> Univ_Integer is (Rational.Den);

    op "-"(Right : Rational) -> Rational is
      (Reduce (-Right.Num, Right.Den));

    op "abs"(Right : Rational) -> Rational is
      ((Num => abs(Right.Num), Den => Right.Den));

    op "+"(Left, Right : Rational) -> Result : Rational is
      (Reduce (Left.Num * Right.Den + Left.Den * Right.Num,
               Left.Den * Right.Den));

    op "-"(Left, Right : Rational) -> Result : Rational is
      (Reduce (Left.Num * Right.Den - Left.Den * Right.Num,
               Left.Den * Right.Den));

    op "*"(Left, Right : Rational) -> Result : Rational is
      (Reduce (Left.Num * Right.Num, Left.Den * Right.Den));

    op "*"(Left : Rational; Right : Univ_Integer) -> Rational is
      (Reduce (Left.Num * Right, Left.Den));

    op "*"(Left : Univ_Integer; Right : Rational) -> Rational is
      (Reduce (Left * Right.Num, Right.Den));

    op "/"(Left, Right : Rational) -> Result : Rational is
      (Reduce (Left.Num * Right.Den, Left.Den * Right.Num));

    op "/"(Left : Rational; Right : Univ_Integer) -> Rational is
      (Reduce (Left.Num, Left.Den * Right));

    op "**"(Left : Rational; Right : Univ_Integer) -> Rational is
      (Reduce (Left.Num ** Right, Left.Den ** Right));

    op "+="(var Left : Rational; Right : Rational) is
       Left := Left + Right;
    end op "+=";

    op "-="(var Left : Rational; Right : Rational) is
       Left := Left - Right;
    end op "-=";

    op "*="(var Left : Rational; Right : Rational) is
       Left := Left * Right;
    end op "*=";

    op "/="(var Left : Rational; Right : Rational) is
       Left := Left / Right;
    end op "/=";

    op "**="(var Left : Rational; Right : Univ_Integer) is
       Left := Left ** Right;
    end op "**=";


    func Strict_Compare(Left, Right : Rational) -> Ordering is
       const Diff := Left - Right;

       return Diff.Num =? 0;
    end func Strict_Compare;

    func Min(Left, Right : optional Rational) -> optional Rational is
       if Left is null then
          return Right;
       elsif Right is null
         or else Left < Right
       then
          return Left;
       else
          return Right;
       end if;
    end func Min;

    func Max(Left, Right : optional Rational) -> optional Rational is
       if Left is null then
          return Right;
       elsif Right is null
         or else Left > Right
       then
          return Left;
       else
          return Right;
       end if;
    end func Max;


    func Sqrt(Val : Rational {Val >= Zero}) -> Result : Rational is
        const Epsilon : Rational := (Num => 1, Den => 2 ** 100);
        const Low := One - Epsilon;
        const High := One + Epsilon;

        Result := Val / Two
        while Result.Num > 0
          and then
           Result * Result / Val not in Low .. High
        loop
            Result := (Val / Result + Result)/Two
        end loop
    end func Sqrt


    func Hash(Val : Rational) -> Unsigned_64 is
       return Univ_Integer::Hash (Val.Num) + Univ_Integer::Hash (Val.Den);
    end func Hash;

    func To_String(Val : optional Rational) -> Univ_String is
       return Univ_Real::To_String ([[Val]]);  //  TBD
    end func To_String;

    func From_String(Str : Univ_String) -> optional Rational is
       return Univ_Real::From_String (Str); // TBD
    end func From_String;

    func Print(X : Rational) is
       Print (To_String (X));
    end func Print;

    func Round_To_Int(Rational : Rational) -> Univ_Integer is
       return (Rational.Num * 2 + Rational.Den) / (2 * Rational.Den);
    end func Round_To_Int;

    func Trunc_To_Int(Rational : Rational) -> Univ_Integer is
       return Rational.Num / Rational.Den;
    end func Trunc_To_Int;

    func Floor_To_Int(Rational : Rational) -> Univ_Integer is
       if Rational.Num < 0 then
          return (Rational.Num - Rational.Den + 1) / Rational.Den;
       else
          return Rational.Num / Rational.Den;
       end if;
    end func Floor_To_Int;

    func Int_To_Rational(Int : Univ_Integer) -> Rational is
       return (Num => Int, Den => 1);
    end func Int_To_Rational;

end class PSL::Core::Rational
    
func PSL::Test::Test_Rational() is
    var X : Rational := 3.5
    var Y : Rational := 5.22
    var Z : Rational := X + Y

    Println("X = " | X | ", Y = " | Y | ", X + Y = " | Z)
    var Teeny : Rational := 0.000023
    Println("Teeny = " | Teeny)
    var Small : Rational := 0.005
    Println("Small = " | Small)
    var Medium : Rational := 235.123
    Println("Medium = " | Medium)
    var Big : Rational := 11.0**5
    Println("Big = " | Big)
    var Huge : Rational := 13.0**15
    Println("Huge = " | Huge)

    Println("Y in 1.0 .. 6.0 = " | ( Y in 1.0 .. 6.0 ))
    
    Println("Y in 1.0 ..< 5.22 = " | ( Y in 1.0 ..< 5.22 ))

    Println("Sqrt(2.0) = " | Sqrt(2.0))

    var Neg : Rational := -2.0;
    Println("Sqrt(-2.0) = " | Sqrt(Neg))
end func PSL::Test::Test_Rational

abstract interface PSL::Core::Indexable
  <Elem_Type is Assignable<>; Index_Type is Countable<>> is
    // An indexable container
    op "indexing"(ref A : Indexable; Index : Index_Type) -> ref Elem_Type
    func Length(A : Indexable) -> Univ_Integer
    op "magnitude"(Indexable) -> Univ_Integer is Length
    op "index_set"(A : Indexable) -> Countable_Range<Index_Type>
    func Bounds(A : Indexable) -> Countable_Range<Index_Type> is "index_set"
end interface PSL::Core::Indexable
interface PSL::Containers::Basic_Array<Element_Type is Assignable<>> is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
    func Create(Length : Univ_Integer<>; Val : optional Element_Type) 
      -> Basic_Array 
      is import(#basic_array_create)
    op "[]"() -> Basic_Array is (Create(0, null))
    op "indexing"(ref V : Basic_Array; Index : Univ_Integer<>) -> 
      ref Element_Type is import(#basic_array_indexing)
    op "var_indexing"(ref var V : Basic_Array; Index : Univ_Integer<>) -> 
      ref var Element_Type is import(#basic_array_indexing)
    func Length(V : Basic_Array) -> Univ_Integer<>
      is import(#basic_array_length)
    op "magnitude"(Basic_Array) -> Univ_Integer<> is Length
    op "|"(Left, Right : Basic_Array) -> Basic_Array
    op "index_set"(A : Basic_Array) -> Countable_Range<Univ_Integer>
    op "<|="(var Left : Basic_Array; var Right : optional Element_Type)
end interface PSL::Containers::Basic_Array

class PSL::Containers::Basic_Array is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
  exports
    op "|"(Left, Right : Basic_Array) -> Result : Basic_Array is
        const Left_Len := Length(Left)

        if Left_Len == 0 then
            return Right
        end if

        Result := Create(Left_Len + Length(Right), null)

        // Copy the Left elements
        for I in 1..Left_Len loop
            Result[I] := Left[I]
        end loop

        // Copy the Right elements
        
        for J in 1..Length(Right) loop
            Result[Left_Len + J] := Right[J]
        end loop
    end op "|"
            
    op "index_set"(A : Basic_Array) -> Countable_Range<Univ_Integer> is
        return 1..Length(A)
    end op "index_set"

    op "<|="(var Left : Basic_Array; var Right : optional Element_Type) is
        const Left_Len := |Left|
        var Result : Basic_Array for Left := Create(Left_Len+1, null)

        for I in 1 .. Left_Len loop
            Result[I] <== Left[I]
        end loop

        Result[Left_Len+1] <== Right

        Left <== Result
    end op "<|="
end class PSL::Containers::Basic_Array

func PSL::Test::Test_Basic_Array() is
    var A : Basic_Array<Univ_Integer<>> := Create(3, 7)
    A[1] := 42
    A[2] += 6
    A[3] += A[2]
    Print("The answer is: " | A[1] + A[2] + A[3] | "\n")
    Print("Length(A) = " | Length(A) | "\n")

    var B := A | A
    Print("Length(B) = " | Length(B) | ", B[5] = " | B[5] | "\n")
    for I in 1..Length(B) forward loop
        Print("B[" | I | "] = " | B[I] | ", ")
    end loop
    Print("\n")

    const C : Basic_Array<Univ_Integer> := [1, 3, 5, 7];
    Print("C = [")
    for each [I => E] of C forward loop
        Print((I > 1? ", " : "") | E)
    end loop
    Println("]")
    Println("|C| = " | |C|)
end func PSL::Test::Test_Basic_Array
interface PSL::Core::Vector<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Extendable Vector, indexed by Univ_Integer, 1..Length
    op "[]"() -> Vector
    func Create(Length : Univ_Integer {Length >= 0}; Value : Element_Type)
      -> Vector
    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type
    op "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      -> Vector  // a "read-only" slice
    op "index_set"(V : Vector) -> Countable_Range<Univ_Integer>
    func Bounds(V : Vector) -> Countable_Range<Univ_Integer> is "index_set"
    op "|="(var V : Vector; Elem : Element_Type)
    op "|="(var V : Vector; Right : Vector)
    op "<|="(var V : Vector; var Elem : optional Element_Type)
    op "|"(Left, Right : Vector) -> Vector
    op "|"(Left : Vector; Right : Element_Type) -> Vector
    func Length(V : Vector) -> Univ_Integer
    op "magnitude"(Vector) -> Univ_Integer is Length
end interface PSL::Core::Vector
    
class PSL::Core::Vector is
  // Extendable Vector, indexed by Univ_Integer, 1..Length
    const Debug := #false;
    const Initial_Size := 4
    const Leaf_Vec_Capacity := 1024
    const Vec_Of_Vec_Length := 1024
    const Subvec_Capacity : Basic_Array<Univ_Integer> :=
      // Capacity of each subvec at given level
      [Leaf_Vec_Capacity,
       Vec_Of_Vec_Length * Leaf_Vec_Capacity,
       Vec_Of_Vec_Length ** 2 * Leaf_Vec_Capacity]
    const Ordinal : Basic_Array<Univ_String> :=
      ["th","st","nd","rd","th","th","th","th","th","th"]

    const Level : Univ_Integer        //  Level = 0 means only Data array
    var Count   : Univ_Integer := 0   //  Overall count
    var Width   : Univ_Integer := 0   //  Num Subvecs in use; is 0 if level = 0
    var Data    : optional Basic_Array<optional Element_Type> := null
    var Subvecs : optional Basic_Array<optional Vector> := null

//    func Rep_Ok(V : Vector; ID : Univ_Integer) is
//        //if Debug then
//        //    Println("ID: " | ID);
//        //end if;
//        {V.Count >= 0};
//        if V.Level == 0 then
//            {V.Width == 0};
//            {V.Subvecs is null};
//            if V.Data not null then
//                {V.Data.Length() >= V.Count};
//            end if;
//        else
//            {V.Width >= 0};
//            {V.Subvecs not null};
//            {V.Data is null};
//        end if;
//    end func Rep_Ok;

    func Expand_Count(var V : Vector; Amount : Univ_Integer := 1) is
        // Expand count by "Amount"
        {> Amount > 0 <}
        //Rep_Ok(V, 1)
        const New_Count := V.Count + Amount;

        loop
            var Next_Count := New_Count

            if V.Level == 0 then
                //  A single Basic_Array of elements
                Next_Count := Min (New_Count, Leaf_Vec_Capacity)
                if V.Data is null then
                    //  Very first element
                    if Debug then
                        Println("Very first element");
                    end if;
                    V.Data := Create(Max(Initial_Size, Next_Count), null)
                    //Rep_Ok(V, 5555);
                elsif V.Count == Length(V.Data) or New_Count > Length(V.Data)
                then
                    //  Double the size if below capacity, else add a level
                    if V.Count < Leaf_Vec_Capacity then
                        // Double the size (up to the max)
                        if Debug then
                            Println("Doubling Data, V.Count was " | V.Count)
                        end if
                        var Old_Data <== V.Data
                        V.Data := Create(Min (Max (2*V.Count, Next_Count),
                                              Leaf_Vec_Capacity), null)
                        for I in 1..V.Count loop
                            V.Data[I] <== Old_Data[I]
                        end loop
                        Old_Data := null
                        //Rep_Ok(V, 6666);
                    else
                        // Reached maximum, add one level
                        {> Next_Count == V.Count <}
                        //Rep_Ok(V, 3333);
                        if Debug then
                            Println("Adding second level, V.Count was " |
                              V.Count)
                        end if;
                        var Old_V <== V
                        V := (Level => 1,
                              Count => Next_Count,
                              Width => 2,
                              Subvecs => Create (Vec_Of_Vec_Length, null))
                        V.Subvecs[1] <== Old_V
                        V.Subvecs[2] :=
                          (Level => 0, Data => Create(Leaf_Vec_Capacity, null))
                        //  Will loop around to extend this two-level structure
                        //Rep_Ok(V, 4444);
                    end if;
                else
                    if Debug then
                        Println(Next_Count | ", " | New_Count);
                    end if;
                end if
            else
                //  Multi-level structure, expand last subvec or add another
                if V.Width > 0 and then
                    V.Subvecs[V.Width].Count < Subvec_Capacity[V.Level]
                then
                    //  Can expand this subvec up to its capacity
                    if Debug then
                        Println("Expand Subvec " | V.Width |
                          ", V.Count was " | V.Count)
                    end if;
                    ref Last_Subvec => V.Subvecs[V.Width]
                    const Subvec_Increase := Min (New_Count - V.Count,
                      Subvec_Capacity[V.Level] - Last_Subvec.Count)
                    Expand_Count (Last_Subvec, Subvec_Increase);
                    //  Compute next value for V.Count
                    Next_Count := V.Count + Subvec_Increase;
                    //Rep_Ok(V, 7777);
                elsif V.Width < Vec_Of_Vec_Length then
                    //  Add another subvec
                    V.Width += 1
                    if V.Level == 1 then
                        //  Add another leaf vec
                        //  Compute amount in this new leaf vec
                        const Amount_In_New_Leaf := Min (Leaf_Vec_Capacity,
                          New_Count - V.Count)

                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " leaf vec, V.Count was " | V.Count |
                                ", adding " | Amount_In_New_Leaf |
                                " in new leaf")
                        end if;

                        V.Subvecs[V.Width] :=
                          (Level => 0, Count => Amount_In_New_Leaf,
                           Data => Create(Leaf_Vec_Capacity, null))

                        //  Compute total count of vector
                        Next_Count := V.Count + Amount_In_New_Leaf
                        //Rep_Ok(V, 8888);
                    else
                        //  Add another multi-level subvec
                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " level " | V.Level-1 |
                                " sub vec, V.Count was " | V.Count)
                        end if;
                        V.Subvecs[V.Width] :=
                          (Level => V.Level-1,
                           Width => 0,
                           Subvecs => Create(Vec_Of_Vec_Length, null))
                        //Rep_Ok(V, 9999);

                        //  Count not increased yet
                        Next_Count := V.Count
                    end if
                else
                    //  Must add another level
                    if Debug then
                        Println("Adding another level, V.Level was " |
                          V.Level | ", V.Count was " | V.Count |
                          ", Next_Count = " | Next_Count)
                    end if;
                    var Old_V <== V
                    V := (Level => Old_V.Level+1,
                          Count => Old_V.Count,
                          Width => 1,
                          Subvecs => Create (Vec_Of_Vec_Length, null))
                    V.Subvecs[1] <== Old_V

                    //  Count not increased yet
                    Next_Count := V.Count
                    //  Will loop around to extend this multi-level structure
                end if
            end if
            //Rep_Ok(V, 1212);
            V.Count := Next_Count
            //Rep_Ok(V, 2323);
            if Next_Count == New_Count then
                exit loop
            end if
            if Debug then
                Println("Trying again, Next_Count = " | Next_Count |
                  ", New_Count = " | New_Count)
                Println("V.Level = " | V.Level | ", V.Width = " | V.Width);
            end if;
            //Rep_Ok(V, 2);
        end loop
        //Rep_Ok(V, 2222);
    end func Expand_Count

    func Report_Indexing_Error (V : Vector; Index : Univ_Integer) is
        var IO := IO::Get_IO();
        IO.Stderr.Println("Vector index " | Index |
          " out of bounds 1 .. " | V.Count)
    end func Report_Indexing_Error

  exports
    op "[]"() -> Vector is
        return (Level => 0, Count => 0, Data => null)
    end op "[]"

    func Create(Length : Univ_Integer; Value : Element_Type)
        -> Vector is

        if Length <= Leaf_Vec_Capacity then
            return (Level => 0,
                    Count => Length, Data => Create (Length, Value))
        else
            const More_Needed := Length - Leaf_Vec_Capacity;

            var Result : Vector :=
                (Level => 0, Count => Leaf_Vec_Capacity,
                 Data => Create (Leaf_Vec_Capacity, Value))
            Result.Expand_Count(More_Needed);
            if Value not null then
                for I in 1 .. More_Needed loop
                    Result[Leaf_Vec_Capacity + I] := Value
                end loop
            end if;
            //Rep_Ok(Result, 3);
            return Result;
        end if;

    end func Create

    func Length(V : Vector) -> Univ_Integer is
        //Rep_Ok(V, 4);
        return V.Count
    end func Length

    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type is
        //Rep_Ok(V, 5);
        if Index <= 0 or else Index > V.Count then
           Report_Indexing_Error(V, Index)
           {*vector_index_out_of_bounds* Index > 0 and then Index <= V.Count}
           //  NOTE: not using "1 .. V.Count" to avoid creating a set object
        end if
        case V.Level of
          [0] =>
            //  Simple case
            return V.Data[Index]
          [1] =>
            //  One-level tree
           const Which_Subvec := (Index-1) / Leaf_Vec_Capacity + 1
           const Subvec_Index := (Index-1) mod Leaf_Vec_Capacity + 1
           //  Index into appropriate subvec
           return V.Subvecs[Which_Subvec].Data[Subvec_Index]
          [..] =>
           //  More than one level deep
           const Subvec_Size := Subvec_Capacity[V.Level]
           const Which_Subvec := (Index-1) / Subvec_Size + 1
           const Subvec_Index := (Index-1) mod Subvec_Size + 1
           //  Recurse with appropriate subvec
           return V.Subvecs[Which_Subvec][Subvec_Index]
        end case;
    end op "indexing"

    op "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      -> Vector is
      // a "read-only" slice
        //Rep_Ok(V, 6);
        return [for I in Index_Set => V[I]]
    end op "slicing"

    op "index_set"(V : Vector) -> Countable_Range<Univ_Integer> is
        //Rep_Ok(V, 7);
        return 1..Length(V)
    end op "index_set"

    op "<|="(var V : Vector; var Elem : optional Element_Type) is
        //Rep_Ok(V, 8);
        Expand_Count(V, Amount => 1)
        //Rep_Ok(V, 9);
        V[V.Count] <== Elem
        //Rep_Ok(V, 10);
    end op "<|="

    op "|="(var V : Vector; Elem : Element_Type) is
        //Rep_Ok(V, 11);
        Expand_Count(V, Amount => 1)
        //Rep_Ok(V, 12);
        V[V.Count] := Elem
        //Rep_Ok(V, 13);
    end op "|="
    
    op "|="(var V : Vector; Right : Vector) is
        //Rep_Ok(V, 14);
        const Orig_Count := V.Count
        if Orig_Count == 0 then
            // Just copy right
            V := Right;
        elsif Right.Count > 0 then
            // Grow V, and then copy in Right
            Expand_Count(V, Right.Count)
            for I in 1..Right.Count loop
                //Rep_Ok(V, 15);
                if Debug then
                    Println(V.Level | ", " | V.Count | ", " | V.Width);
                end if;
                V[I+Orig_Count] := Right[I]
                //Rep_Ok(V, 16);
            end loop
        end if
        //Rep_Ok(V, 17);
    end op "|="

    op "|"(Left, Right : Vector) -> Result : Vector is
        //Rep_Ok(Left, 18);
        //Rep_Ok(Right, 19);
        // Copy left into result, and then add in the Right elements
        if Left.Count == 0 then
            // Left is null Vector; result is determined by Right
            Result := Right
        else
            // Start with Left
            Result := Left
            //Rep_Ok(Result, 20);
            Result |= Right
        end if
        //Rep_Ok(Result, 21);
    end op "|"

    op "|"(Left : Vector; Right : Element_Type) -> Result : Vector is
        //Rep_Ok(Left, 22);
        Result := Left
        //Rep_Ok(Result, 23);
        Result |= Right
        //Rep_Ok(Result, 24);
    end op "|"

end class PSL::Core::Vector

func PSL::Test::Test_Vector() is
    var V : Vector<Univ_Integer> := []
    var U : Vector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " | V[1] | ", " | V[2])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 1..Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    Println("\"indexing\"(V, 12) := 33;")
    "indexing"(V, 12) := 33
    for I in 1..Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 1..Length(Slice) forward loop
        Println("Slice[" | I | "] = " | Slice[I])
    end loop

    func Equal(Left, Right : Vector<Univ_Integer>) -> Boolean is
        if |Left| == |Right| then
            for each [I => L] of Left loop
                if L != Right[I] then
                    return #false;
                end if;
            end loop;
        else
            return #false;
        end if;
        return #true;
    end func Equal;

    var W : Vector<Univ_Integer> := Create(1021, 1)
    const Correct : Vector<Univ_Integer> := [1, 1, 2, 2, 2, 2];
    W |= 2; W |= 2; W |= 2; W |= 2
    {Length(W) == 1025}
    {Equal(W[1020 .. 1025], Correct)}

    var Y : Vector<Univ_Integer> := Create(1024, 1)
    //Y |= 2; Y |= 2; Y |= 2; Y |= 2
    Y |= [2, 2, 2, 2];
    {Length(Y) == 1028}
    {Equal(Y[1023 .. 1028], Correct)}
    W |= Y;

    var Z : Vector<Univ_Integer> := Create(1100, 1)
    Z |= 2; Z |= 2; Z |= 2; Z |= 2
    {Length(Z) == 1104}
    {Equal(Z[1099 .. 1104], Correct)}
    Z |= Correct;
    Z |= W;
    Z[1025] := 4;
    const J := Z[1];
    var H := Z[12];

    var X : Vector<Univ_Integer> := [1];
    const XX : Vector<Univ_Integer> := Create(1025, 1);
    X |= XX;

    var Strings : Vector<Univ_String> := [];
    Strings |= "hi";
    Strings |= "ho";
    Strings := Strings | "hi";
    Strings |= "";
    Strings[|Strings|] := "ho";
    Strings |= ["it's", "off", "to"];
    const To_Add : Vector<Univ_String> := [] | "work" | "we" | "go";
    Strings |= To_Add;
    for (each S of Strings; Sep := "" then " ") forward loop
        Print(Sep | S);
    end loop;
    Print('\n');

    var LL : Vector<Vector<Univ_String>> := [];
    LL |= ["one", "two", "three"];
    LL |= ["ten", "twenty", "thirty"];
    for each Vec of LL forward loop
        for each S of Vec forward loop
            Print(S);
        end loop
    end loop
    Print('\n');
end func PSL::Test::Test_Vector

func PSL::Test::Test_Big_Vector () is
    var Big_V : Vector<Univ_Integer> := []
    var Ran := Random::Start()
    const N := 2_000_000
    Println("Building a vector of length " | N);
    for I in 1..N forward loop
        Big_V |= Ran.Next() mod N
        if |Big_V| mod (N/40) == 0 then
            Println("Big_V[" | |Big_V| | "] = " | Big_V[|Big_V|])
        end if
    end loop
    Println("|Big_V| = " | |Big_V|)
end func PSL::Test::Test_Big_Vector

interface PSL::Core::ZVector<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Extendable vector, indexed by Univ_Integer, 0..Length-1
    op "[]"() -> ZVector
    func Create(Length : Univ_Integer; Value : Element_Type) -> ZVector
    op "indexing"(ref V : ZVector; Index : Univ_Integer) -> 
      ref Element_Type
    op "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      -> ZVector
      // a "read-only" slice
    op "index_set"(V : ZVector) -> Countable_Range<Univ_Integer>
    op "|="(var V : ZVector; Elem : Element_Type)
    op "|="(var V : ZVector; Right : ZVector)
    op "<|="(var V : ZVector; var Elem : optional Element_Type)
    op "|"(Left, Right : ZVector) -> ZVector
    op "|"(Left : ZVector; Elem : Element_Type) -> Result : ZVector
    func Length(V : ZVector) -> Univ_Integer
    op "magnitude"(ZVector) -> Univ_Integer is Length
end interface PSL::Core::ZVector
    
class PSL::Core::ZVector is
  // Extendable ZVector, indexed by Univ_Integer, 0..Length-1
    var Vec : Vector<Element_Type>

  exports
    op "[]"() -> ZVector is
        return (Vec => [])
    end op "[]"

    func Create(Length : Univ_Integer; Value : Element_Type) -> ZVector is
        return (Vec => Create(Length, Value))
    end func Create

    func Length(V : ZVector) -> Univ_Integer is
        return Length(V.Vec)
    end func Length

    op "indexing"(ref V : ZVector; Index : Univ_Integer) -> 
      ref Element_Type is
        {Index >= 0 and then Index < Length(V.Vec)}  // Index out of bounds
        return V.Vec[Index+1]
    end op "indexing"

    op "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      -> ZVector is
      // a "read-only" slice
        return [for I in Index_Set => V[I]]
    end op "slicing"

    op "index_set"(V : ZVector) -> Countable_Range<Univ_Integer> is
        return 0..<Length(V.Vec)
    end op "index_set"

    op "<|="(var V : ZVector; var Elem : optional Element_Type) is
        V.Vec <|= Elem
    end op "<|="

    op "|="(var V : ZVector; Elem : Element_Type) is
        V.Vec |= Elem
    end op "|="

    op "|="(var V : ZVector; Right : ZVector) is
        V.Vec |= Right.Vec
    end op "|="
    
    op "|"(Left, Right : ZVector) -> Result : ZVector is
        return (Vec => Left.Vec | Right.Vec)
    end op "|"

    op "|"(Left : ZVector; Elem : Element_Type) -> Result : ZVector is
        return (Vec => Left.Vec | Elem)
    end op "|"

end class PSL::Core::ZVector

func PSL::Test::Test_ZVector() is
    var V : ZVector<Univ_Integer> := []
    var U : ZVector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " | V[0] | ", " | V[1])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 0..<Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    Println("\"indexing\"(V, 11) := 33;")
    "indexing"(V, 11) := 33
    for I in 0..<Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 0..<Length(Slice) forward loop
        Println("Slice[" | I | "] = " | Slice[I])
    end loop
end func PSL::Test::Test_ZVector
interface PSL::Core::ZString<> is
  // A universal string with characters indexed starting at 0
    op "from_univ"(Univ : Univ_String) -> ZString
      is import(#identity)
    op "to_univ"(ZStr : ZString) -> Univ_String
      is import(#identity)

    func Print(ZString) is import(#print_string)
    func Println(ZString) is import(#println_string)
    func Readln() -> optional ZString is import(#read_string)
        //  Read input up to a newline, from standard input.
        //  Return null value when reaching end of file of standard input
        //  (which can happen when standard input is coming from a file,
        //   or when user types control/D on a Unix-like platform).

    op "*"(Left : Univ_Integer; Right : ZString) -> ZString
        // Produce specified number of "Right" strings in a row
    op "*"(Left : ZString; Right : Univ_Integer) -> ZString
        // Produce specified number of "Left" strings in a row

    op "|"(Left, Right : optional ZString) -> ZString 
      is import(#concat_string)

    op "=?"(Left, Right : ZString) -> Ordering
      is import(#string_compare)
    func Strict_Compare(Left, Right : ZString) -> Ordered::Full_Ordering
      is import(#string_compare)

    op "|="(var Left : ZString; Right : ZString)
      is import(#assign_concat_string)

    op "indexing"(Str : ZString; Index : Univ_Integer<>) -> Univ_Character
        // a "read-only" element, indexed 0..<Length(Str)

    op "index_set"(Str : ZString) -> Countable_Range<Univ_Integer>
        // Return set of indices for string

    op "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> ZString
        // a "read-only" slice

    func Length(Str : ZString) -> Univ_Integer
      is import(#string_length)

    op "magnitude"(ZString) -> Univ_Integer is Length

    func Hash(Val : ZString) -> Unsigned_64
      is import(#hash_string)

    op "|"(Left : optional ZString; Right : optional Right_Type is Imageable<>) 
      -> ZString

    op "|"(Left : optional Left_Type is Imageable<>; Right : optional ZString)
      -> ZString

    op "|="(var Left : ZString; Right : Right_Type is Imageable<>)

    // Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) -> ZVector<Univ_Character>
    func From_ZVector(Vec : ZVector<Univ_Character>) -> ZString

    func Replace(Orig : ZString;
      Char : Univ_Character; With : Univ_Character) -> ZString
    //  Replace each appearance of Char with "With"

    func Replace(Orig, Str, With : ZString) -> ZString
     //  Replace any slice matching Str with "With"
     //  Overlapping matches will be replaced only once. Example:
     //    Replace(":::", "::", ".") -> ".:"
end interface PSL::Core::ZString
    
class PSL::Core::ZString is
  // A universal string with characters indexed starting at 0
    var U_Str : Univ_String

  exports
    op "indexing"(Str : ZString; Index : Univ_Integer<>) -> Univ_Character is
        // a "read-only" element, indexed 0..<Length(Str)
        return Str.U_Str[Index+1]
    end op "indexing"

    op "index_set"(Str : ZString) -> Countable_Range<Univ_Integer> is
        // Return set of indices for string
        return 0 ..< |Str.U_Str|
    end op "index_set"

    op "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> ZString is
        // a "read-only" slice
        return (U_Str => Str.U_Str[Index_Set.First <.. Index_Set.Last+1])
    end op "slicing"

    op "*"(Left : Univ_Integer; Right : ZString) -> ZString is
        // Produce specified number of "Right" strings in a row
        return (U_Str => Left * Right.U_Str)
    end op "*"

    op "*"(Left : ZString; Right : Univ_Integer) -> ZString is
        // Produce specified number of "Left" strings in a row
        return Right * Left   // Just pass the buck to other "*"
    end op "*"

    op "|"(Left : optional ZString; Right : optional Right_Type is Imageable<>) 
      -> ZString is
        if Left is null then
            return (U_Str => "null" | Right)
        elsif Right is null then
            return (U_Str => Left.U_Str | "null")
        else
            return (U_Str => Left.U_Str | Right_Type::To_String(Right))
        end if
    end op "|"

    op "|"(Left : optional Left_Type is Imageable<>; Right : optional ZString)
      -> ZString is
        if Right is null then
            return (U_Str => Left | "null")
        elsif Left is null then
            return (U_Str => "null" | Right.U_Str)
        else
            return (U_Str => Left_Type::To_String(Left) | Right.U_Str)
        end if
    end op "|"

    op "|="(var Left : ZString; Right : Right_Type is Imageable<>) is
        if Right is null then
            Left.U_Str |= "null"
        else
            Left.U_Str |= Right_Type::To_String(Right)
        end if
    end op "|="

    // Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) -> ZVector<Univ_Character> is
        return [for I in 0 ..< Length(Str) => Str[I]]
    end func To_ZVector

    func From_ZVector(Vec : ZVector<Univ_Character>) -> ZString is
        var Result : ZString := "";
        for each C of Vec forward loop
            Result |= C;
        end loop;
        return Result;
    end func From_ZVector;

    func Replace(Orig : ZString;
      Char : Univ_Character; With : Univ_Character) -> Result : ZString is
    //  Replace each appearance of Char with "With"

       Result := ""

       var Prev_Match := -1
       for each [I => C] of Orig forward loop
          //  Look for a match
          if C == Char then
             // Concatenate on unchanged part and replacement character
             Result |= Orig[Prev_Match <..< I] | With
             Prev_Match := I;
          end if
       end loop

       if Prev_Match < 0 then
          Result := Orig
       elsif Prev_Match < |Orig|-1 then
          Result |= Orig[Prev_Match <..< |Orig|]
       end if
    end func Replace

    func Replace(Orig, Str, With : ZString) -> ZString is
     //  Replace any slice matching Str with "With"
     //  Overlapping matches will be replaced only once. Example:
     //    Replace(":::", "::", ".") -> ".:"
       const Len_Str  := |Str|;
       const Len_With := |With|;

       case Len_Str of
        [0] =>
          //  Treat this as a no-op
          return Orig;

        [1] =>
          //  Replacing single characters
          if Len_With == 1 then
             //  Replace Char with Char
             return Replace(Orig, Str[0], With[0]);
          else
             //  Replace Char with String of any Length
             var Result : ZVector<Univ_Character> := [];
             const Str_Char := Str[0];
             for I in 0 ..< |Orig| forward loop
                if Orig[I] == Str_Char then
                   //  Matches
                   Result |= To_ZVector(With);
                else
                   //  Does not match
                   Result |= Orig[I];
                end if
             end loop
             return From_ZVector(Result);
          end if

        [..] =>
          //  Replace String of Length >= 2 with String of any Length
          var Result : ZVector<Univ_Character> := [];
          const Len_Orig := |Orig|;
          for I := 0 while I < Len_Orig loop
             if I + Len_Str <= Len_Orig
               and then Orig[I ..< I + Len_Str] == Str
             then
                //  Matches
                Result |= To_ZVector(With);
                //  Overlapping matches replaced only once
                //  Skip past end of this match
                continue loop with I + Len_Str;
             else
                //  Does not match just add Ith character to Result
                Result |= Orig[I];
                continue loop with I + 1;
             end if
          end loop
          return From_ZVector(Result)
       end case
    end func Replace
 
end class PSL::Core::ZString

func PSL::Test::Test_ZString() is
    const U : ZString := "tab\t"
    const T := U[3]
    Println("U = " | U | ", Length(U) = " | Length(U) | ", U[4] = '" | T | "'")
    const X : ZString := "this is a string"
    const Y := X[2]
    {Y == 'i'} // string indexing problem
    const Z := X[5..6]
    {Z == "is"} // string slicing problem, expected 'is', found Z 
    Println("X = " | X | ", X[2] = " | Y | ", X[5..6] = " | Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " | "hello")

    const Seven_Xs :ZString := "x" * 7
    {Seven_Xs == "xxxxxxx"} // Char multiplication check

    Println("Here are seven x's: " | Seven_Xs)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)
    Println("X.Replace('s', With => 'x') = " | X.Replace('s', With => 'x'))
    Println("X.Replace(\"is\", With => \"at\") = " |
      X.Replace("is", With => "at"))
end func PSL::Test::Test_ZString
interface PSL::Containers::Slice<Array_Type is Indexable<>> is
  // A sliceable array.
    const First : Array_Type::Index_Type
    const Last : Array_Type::Index_Type

    func Length(S : Slice) -> Univ_Integer
        // Return length of slice (i.e. Last - First + 1)

    op "magnitude"(Slice) -> Univ_Integer is Length
        // Allows use of |...| operator

    op "slicing"(ref A : Array_Type) -> ref Slice
        // Convert an array into a slice covering 1..Length(A)

    op "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice
        // Slice of an array

    op "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice
        // Slice of a slice

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type
        // Index into a slice

    op "index_set"(S : Slice) -> Countable_Range<Array_Type::Index_Type>
end interface PSL::Containers::Slice

class PSL::Containers::Slice is
    ref Arr : Array_Type
  exports
    func Length(S : Slice) -> Univ_Integer is
        // Return length of slice (i.e. Last - First + 1)
        return S.Last - S.First + 1
    end func Length

    op "slicing"(ref A : Array_Type) -> ref Slice is
        // Convert an array into a slice covering whole array
        const A_Bounds := "index_set"(A)
        return (First => A_Bounds.First, Last => A_Bounds.Last, Arr => A)
    end op "slicing"

    op "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of an array
        const A_Bounds := "index_set"(A)
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= A_Bounds.First and then 
            Bounds.Last <= A_Bounds.Last)} //slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => A)
    end op "slicing"

    op "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of a slice
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= S.First and then Bounds.Last <= S.Last)}
          // slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => S.Arr)
    end op "slicing"

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type is
        // Index into a slice
        {Index >= S.First and then Index <= S.Last}
          // array index out of bounds
        return S.Arr[Index]
    end op "indexing"
    
    op "index_set"(S : Slice) -> Countable_Range<Array_Type::Index_Type> is
        return S.First .. S.Last
    end op "index_set"
end class PSL::Containers::Slice
interface PSL::Core::Enum<Literals : Vector<Univ_Enumeration>> is
    op "from_univ"(Univ : Univ_Enumeration) 
      {*"Literal not defined for Enum type"*
       (for some Lit of Literals => Lit == Univ)}
      -> Enum
    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)}

    op "=?"(Left, Right : Enum) -> Ordering
      is import("=?")
    func Strict_Compare(Left, Right : Enum) -> Ordered::Full_Ordering
      is import("=?")

    // Functions for Imageable
    func To_String(Val : optional Enum) -> Univ_String
    func From_String(Str : Univ_String) -> optional Enum

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Enum) -> Enum 
      is import("+")
    op "+"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("+")
    op "-"(Left, Right : Enum) -> Univ_Integer 
      is import("-")
    op "-"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("-")
    op "+="(var Left : Enum; Right : Univ_Integer)
      is import("+=");
    op "-="(var Left : Enum; Right : Univ_Integer)
      is import("-=");

    // TBD: These should be properties some day (e.g. Color#first).
    func First()->Enum
    func Last()->Enum
    func Range()->Countable_Range<Enum> is "[..]" in Countable_Range<Enum>

    op "[..]"() -> Countable_Range<Enum> is in Countable_Range<Enum>

    func Hash(Val : Enum) -> Unsigned_64
      is import(#identity)

    op ".."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "<.."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "<..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "|"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "in"(Left : Enum; Right : Countable_Set<Enum>) -> Boolean
      is in Countable_Set<Enum>

    func Min(Left, Right : optional Enum) -> optional Enum
      is import(#min)
    func Max(Left, Right : optional Enum) -> optional Enum
      is import(#max)
end interface PSL::Core::Enum

class PSL::Core::Enum is
    const Value : Univ_Integer
  exports
    op "from_univ"(Univ : Univ_Enumeration) 
      -> Enum is
        for I in 1 .. |Literals| loop
            if Literals[I] == Univ then
                return (Value => I-1)
            end if
        end loop
        var IO := IO::Get_IO()
        IO.Stderr.Println("Error: Bad enum literal: " | Univ)
        IO.Stderr.Println("Info: Should be one of: " |
          (for each Lit of Literals forward => <""> | " " | Lit))
        {*"Literal not defined for Enum type"* #false}
        return (Value => 0)
    end op "from_univ"

    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)} is
        if Val is null then
            return null
        else
            return Literals[Val.Value+1]
        end if
    end op "to_univ"

    // Functions for Imageable
    func To_String(Val : optional Enum) -> Univ_String is
        return Univ_Enumeration::To_String([[Val]])
    end func To_String

    func From_String(Str : Univ_String) -> optional Enum is
        return Univ_Enumeration::From_String(Str)
    end func From_String

    func First()->Enum is
        return (Value => 0)
    end func First

    func Last()->Enum is
        return (Value => |Literals| - 1)
    end func Last

end class PSL::Core::Enum

func PSL::Test::Test_Enum() is
    type Color is Enum< [#red, #green, #blue] >
    type Day_Of_Week is 
       Enum< [#Monday, #Tuesday, #Wednesday, #Thursday, 
        #Friday, #Saturday, #Sunday] >

    for C : Color in Color::First() .. Color::Last() forward loop
        Println("Next color = " | C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " | C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " | D3)
    end loop

    {#Monday in Day_Of_Week}

end func PSL::Test::Test_Enum
func Test_Enum() is
    PSL::Test::Test_Enum()
end func Test_Enum
interface PSL::Containers::Map
  <Key_Type is Hashable<>; Value_Type is Assignable<>> 
  implements Custom_Streaming<>
is
  // A hashed-map module
    type Pair is Key_Value<Key_Type, Value_Type>

    op "[]"() -> Map

    op "|="(var Left : Map; Right : Pair)
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.

    op "|"(Left : Map; Right : Pair) -> Map
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.

    op "<|="(var Left : Map; var Right : optional Pair)
        // Move Key/Value pair into map, leaving Right null

    op "<|="(var Left : Map; var Right : Map)
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.

    op "+="(var Left : Map; Right : Pair) is "|="
        // A synonym for adding a key=>value pair

    op "in"(Left : Key_Type; Right : Map) -> Boolean
        // Return True if given key has a mapping in the Map

    op "-="(var M : Map; Key : Key_Type)   // aka Exclude
        // Remove mapping for Right, if present

    op "index_set"(M : Map) -> Set<Key_Type>
        // Return set of keys with mappings

    func Keys(M : Map) -> Set<Key_Type> is "index_set"

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type
        // Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Map) -> optional Pair
        // Remove one mapping from the Map.  Return null if Map is empty

    func Count(M : Map) -> Univ_Integer
        // Number of mappings in the table

    op "magnitude"(Map) -> Univ_Integer is Count

    func Is_Empty(M : Map) -> Boolean
        // Return True if no mappings in the table

    //  Provide custom streaming operations
    op "write" (var Output_Object_Stream;
                Obj : optional Map;
                Is_Optional : Boolean);

    op "read"  (var Input_Object_Stream;
                var Obj : optional Map;
                Is_Optional : Boolean);

    func Dump_Statistics(M : Map)
      // A debugging routine to show bucket sizes of Map

end interface PSL::Containers::Map

class PSL::Containers::Map is
  // A hashed-map module

    var Data : Basic_Map<Key_Value<Key_Type, Value_Type>>

  exports
    op "[]"() -> Map is
        return (Data => [])
    end op "[]"

    op "|"(Left : Map; Right : Pair) -> Result : Map is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.
        Result := Left
        Result.Data |= Right
    end op "|"

    op "|="(var Left : Map; Right : Pair) is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.
        Left.Data |= Right
    end op "|="

    op "<|="(var Left : Map; var Right : optional Pair) is
        // Move Key/Value pair into map, leaving Right null
        Left.Data <|= Right
    end op "<|="

    op "<|="(var Left : Map; var Right : Map) is
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.
        loop
            var Right_Elem for Left := Remove_Any(Right)
            if Right_Elem is null then
                return   // All done
            end if

            Left.Data <|= Right_Elem
        end loop
    end op "<|="

    op "in"(Left : Key_Type; Right : Map) -> Boolean is
        return Left in Right.Data
    end op "in"

    op "-="(var M : Map; Key : Key_Type) is
      // Remove the given key from the Map, if present
        M.Data -= Key
    end op "-="
   
    op "index_set"(M : Map) -> Result : Set<Key_Type> is
        // Return set of keys with mappings
        if M.Data is null then
            return []
        else
           return "index_set"(M.Data)
        end if
    end op "index_set"

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type is
        // Used for references to M[Key]; requires the Key to be in M.
        return M.Data[Key].Value
    end op "indexing"

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type is
        // Used for assignments to M[Key]; Key is added to M if not present
        return "var_indexing"(M.Data, Key).Value
    end op "var_indexing"

    func Count(M : Map) -> Univ_Integer is
        return Count(M.Data)
    end func Count

    func Is_Empty(M : Map) -> Boolean is
        // Return True if no mappings in the table
        return Is_Empty(M.Data)
    end func Is_Empty

    func Remove_Any(var M : Map) -> Result : optional Pair is
        return Remove_Any(M.Data)
    end func Remove_Any

    //  Provide custom streaming operations
    op "write" (var Output_Object_Stream;
                Obj : optional Map;
                Is_Optional : Boolean) is
       Write_Optional_Default (Output_Object_Stream, Obj);
    end op "write";

    op "read"  (var Input_Object_Stream;
                var Obj : optional Map;
                Is_Optional : Boolean) is
       Read_Optional_Default (Input_Object_Stream, Obj);
    end op "read";

    func Dump_Statistics(M : Map) is
      // A debugging routine to show bucket sizes of Map
        Dump_Statistics(M.Data)
    end func Dump_Statistics

end class PSL::Containers::Map

func PSL::Test::Test_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    type Enum_String_Map is Map<Univ_Enumeration, Univ_String>

    var M : Enum_String_Map := [X => Y, A => B]

    Println("Count = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
        Println(K | " in M = " | (K in M))
    end loop

    Println("#xy in M = " | (#xy in M))

    M -= X

    Println("Count after deletion = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    M -= A

    Println("Count after deletion = " | Count(M))

    for each [K => V] of M loop
        Println("Mapping " | K | " => " | V)
    end loop

    var Ran := Random::Start(Hash(A))
    var MUI : Map<Univ_Integer, Univ_Integer> := []

    Println("Adding 100 random pairings to Map.")
    for I in 1..100 loop
        const Key := Next(Ran) mod 100
        const Value := Next(Ran) mod 100
        MUI[Key] := Value
    end loop
    Println("Map is now of count = " | Count(MUI))

    for each [K => V] of MUI loop
        Println("Mapping " | K | " => " | V)
        Println("MUI[" | K | "] = " | MUI[K])
    end loop

    for (Pair in MUI; I in 1..60 forward) loop
        Print(" [" | Pair.Key | " => " | Pair.Value | "]")
        if I mod 5 == 0 then
            Print('\n')
        end if
    end loop

    if Count(MUI) > 60 then
        Println(" ...")
    elsif Count(MUI) mod 5 != 0 then
        Print('\n')
    end if

end func PSL::Test::Test_Map
interface PSL::Containers::Two_Way_Map
  <Key_Type is Imageable<>; Value_Type is Imageable<>>   // TBD: use Hashable
  extends Forward : Map<Key_Type, Value_Type> is
    type Pair2 is Key_Value<Key_Type, Value_Type>

    op "[]"() -> Two_Way_Map

    op "|="(var Left : Two_Way_Map; Right : Pair2)
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any.

    op "|"(Left : Two_Way_Map; Right : Pair2) -> Two_Way_Map
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any in result.

    op "<|="(var Left : Two_Way_Map; var Right : optional Pair2)
        // Move Key/Value pair into Two_Way_map, leaving Right null

    op "<|="(var Left : Two_Way_Map; var Right : Two_Way_Map)
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.

    op "-="(var M : Two_Way_Map; Key : Key_Type)   // aka Exclude
        // Remove mapping for Right, if present

    op "var_indexing"(ref var M : Two_Way_Map; Key : Key_Type) 
      -> ref var optional Value_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Key_Of (M : Two_Way_Map; Value : Value_Type) -> optional Key_Type
        // Use reverse mapping to determine key given value

    func Rev_Map (M : Two_Way_Map) -> Map<Value_Type, Key_Type>
        // Return a copy of the reverse map

end interface PSL::Containers::Two_Way_Map

class PSL::Containers::Two_Way_Map is
    var Reverse : Map<Value_Type, Key_Type>
    var Unreversed : Set<Key_Type>  //  Keys not yet in Reverse map

    func Add_Unreversed(var M : Two_Way_Map) is
      //  Add Unreversed Keys into M.Reverse
        while not Is_Empty (M.Unreversed) loop
            var Key := Remove_Any(M.Unreversed)
            M.Reverse |= [M.Forward[Key] => Key]
        end loop
    end func Add_Unreversed

  exports

    op "[]"() -> Two_Way_Map is
        return (Forward => [], Reverse => [], Unreversed => [])
    end op "[]"

    op "|="(var Left : Two_Way_Map; Right : Pair2) is
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any.
        Add_Unreversed (Left)
        Left.Forward |= Right
        Left.Reverse |= [Right.Value => Right.Key]
    end op "|="

    op "|"(Left : Two_Way_Map; Right : Pair2) -> Result : Two_Way_Map is
        // Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
        // for Key, if any in result.
        Result := Left
        Add_Unreversed (Result)
        Result |= Right
    end op "|"

    op "<|="(var Left : Two_Way_Map; var Right : optional Pair2) is
        // Move Key/Value pair into Two_Way_map, leaving Right null
        Add_Unreversed (Left)
        Left.Reverse |= [Right.Value => Right.Key]
        Left.Forward <|= Right
    end op "<|="

    op "<|="(var Left : Two_Way_Map; var Right : Two_Way_Map) is
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.
        Add_Unreversed (Left)
        loop
            var KV := Remove_Any(Right)
            if KV is null then
                exit loop
            end if
            Left <|= KV
        end loop
    end op "<|="

    op "-="(var M : Two_Way_Map; Key : Key_Type) is   // aka Exclude
        // Remove mapping for Right, if present
        Add_Unreversed (M)
        if Key in M.Forward then
           M.Reverse -= M.Forward[Key]
           M.Forward -= Key
        end if
    end op "-="

    op "var_indexing"(ref var M : Two_Way_Map; Key : Key_Type) 
      -> ref var optional Value_Type is
        // Used for assignments to M[Key]; Key is added to M if not present
        Add_Unreversed (M)
        if Key not in M then
            //  Don't have value of Key so can't add to M.Reverse yet
            M.Unreversed |= Key
        end if
        return "var_indexing"(M.Forward, Key)
    end op "var_indexing"

    func Key_Of (M : Two_Way_Map; Value : Value_Type) -> optional Key_Type is
        // Use reverse mapping to determine key given value
        if Value in M.Reverse then
           // Found in reverse mapping
           return M.Reverse[Value]
        else
           // Search through Unreversed keys
           for K in M.Unreversed loop
               if M.Forward[K] == Value then
                   return K
               end if
           end loop
           // Not there
           return null
        end if
    end func Key_Of

    func Rev_Map (M : Two_Way_Map) -> Result : Map<Value_Type, Key_Type> is
        // Return a copy of the reverse map, after adding the unreversed keys
        var Copy for Result := M;
        Add_Unreversed (Copy)
        
        Result <== Copy.Reverse
        Copy := null
    end func Rev_Map

end class PSL::Containers::Two_Way_Map
interface PSL::Core::Float<Digits : Univ_Integer := 15> is
  // A floating point type that provides at least the
  // given number of digits of precision.

    op "from_univ"(Univ : Univ_Real) -> Float
      is import(#identity)

    op "to_univ"(Val : Float) -> Univ_Real
      is import(#identity)

    op "+"(Right : Float) -> Float
      is import(#identity)

    op "-"(Right : Float) -> Float
      is import(#real_negate)

    op "abs"(Right : Float) -> Float
      is import(#real_abs)

    op "magnitude"(Float) -> Float is "abs"

    op "+"(Left, Right : Float) -> Result : Float 
      is import(#real_add)

    op "-"(Left, Right : Float) -> Result : Float
      is import(#real_subtract)

    op "*"(Left, Right : Float) -> Result : Float 
      is import(#real_multiply)

    op "*"(Left : Float; Right : Univ_Integer) -> Result : Float 
      is import(#real_int_multiply)

    op "*"(Left : Univ_Integer; Right : Float) -> Result : Float

    op "/"(Left, Right : Float) -> Result : Float
      is import(#real_divide)

    op "/"(Left : Float; Right : Univ_Integer) -> Result : Float
      is import(#real_int_divide)

    op "**"(Left : Float; Right : Univ_Integer) -> Float
      is import(#real_exp)

    op "+="(var Left : Float; Right : Float) 
      is import(#real_assign_add)

    op "-="(var Left : Float; Right : Float) 
      is import(#real_assign_subtract)

    op "*="(var Left : Float; Right : Float) 
      is import(#real_assign_multiply)

    op "/="(var Left : Float; Right : Float) 
      is import(#real_assign_divide)

    op "**="(var Left : Float; Right : Univ_Integer) 
      is import(#real_assign_exp)


    op "=?"(Left, Right : Float) -> Ordering
      is import(#real_compare)
    func Strict_Compare(Left, Right : Float) -> Ordered::Full_Ordering
      is import(#real_compare)

    func Min(Left, Right : optional Float) -> optional Float
      is import(#real_min)
    func Max(Left, Right : optional Float) -> optional Float
      is import(#real_max)

    func Sqrt(Val : Float {Val >= 0.0}) -> Float
      is import(#real_sqrt)
      // is (Univ_Real::Sqrt([[Val]]))     

    func Hash(Val : Float) -> Unsigned_64
      is import(#identity)

    func Round_To_Int(Val : Float) -> Univ_Integer
      is import(#round_to_int)

    func Trunc_To_Int(Val : Float) -> Univ_Integer
      is import(#trunc_to_int)

    func Floor_To_Int(Val : Float) -> Univ_Integer
      is import(#floor_to_int)

    func Int_To_Float(Int : Univ_Integer) -> Float
      is import(#int_to_real)

    func To_String(Val : optional Float) -> Univ_String
      is import(#to_string_real)

    func From_String(Str : Univ_String) -> optional Float
      is import(#from_string_real)

    func Print(X : Float) is import(#print_real)
    func Println(X : Float) is (Println(To_String(X)))

    op "in"(Left : Float; Right : Range_Set<Float>) -> Boolean
      is in Range_Set<Float>
        // "in" defined in Range_Set

 implements for Summable

    func From_Int (Int : Univ_Integer) -> Float

end interface PSL::Core::Float

class PSL::Core::Float is
    const Value : Univ_Real
  exports
    op "*"(Left : Univ_Integer; Right : Float) -> Result : Float is
        // Hand off to built-in real*int op
        return Right * Left
    end op "*"

 implements for Summable
    func From_Int (Int : Univ_Integer) -> Float is
       return Int_To_Float(Int)
    end func From_Int
end class PSL::Core::Float
    
func PSL::Test::Test_Float() is
    type My_Float is Float<Digits => 8>

    var X : My_Float := 3.5
    var Y : My_Float := 5.22
    var Z : My_Float := X + Y

    Println("X = " | X | ", Y = " | Y | ", X + Y = " | Z)
    var Teeny := 0.000023
    Println("Teeny = " | Teeny)
    var Small := 0.005
    Println("Small = " | Small)
    var Medium := 235.123
    Println("Medium = " | Medium)
    var Big := 11.0**5
    Println("Big = " | Big)
    var Huge := 13.0**15
    Println("Huge = " | Huge)

    var X2 : My_Float := 3.5 * 2

    Println("X * 2 = " | X * 2 | ", 2 * X = " | 2 * X | ", X2 = " | X2)
    Println("X / 2 = " | X / 2 )

    if X in 1.5 ..< 3.6 then
        Println("X *is* in 1.5 ..< 3.6")
    else
        Println("X *not* in 1.5 ..< 3.6??")
    end if

    Println("X in 1.5 ..< 3.5 = " | (X in 1.5 ..< 3.5) )
end func PSL::Test::Test_Float
interface PSL::Core::Fixed<Delta : Univ_Real> is
  // Fixed point types, represented as an integer
  // multiple of the given Delta
    op "from_univ"(Univ : Univ_Real) -> Fixed
    op "to_univ"(Val : optional Fixed) -> optional Univ_Real

    op "+"(Right : Fixed) -> Fixed
      is import(#identity)

    op "-"(Right : Fixed) -> Fixed
      is import(#negate)

    op "abs"(Right : Fixed) -> Fixed
      is import("abs")

    op "magnitude"(Fixed) -> Fixed is "abs"

    op "+"(Left, Right : Fixed) -> Fixed
      is import("+")
    op "-"(Left, Right : Fixed) -> Fixed
      is import("-")
    op "*"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_mul)
    op "*"(Left : Univ_Real; Right : Fixed) -> Fixed
      is import(#real_fixed_mul)
    op "*"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("*")
    op "*"(Left : Univ_Integer; Right : Fixed) -> Fixed
      is import("*")
    op "/"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_div)
    op "/"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("/")

    op "+="(var Left : Fixed; Right : Fixed) 
      is import("+=")

    op "-="(var Left : Fixed; Right : Fixed) 
      is import("-=")

    op "*="(var Left : Fixed; Right : Fixed) 
      is import("*=")

    op "/="(var Left : Fixed; Right : Univ_Integer) 
      is import("/=")

    op "/="(var Left : Fixed; Right : Univ_Real)

    op "=?"(Left, Right : Fixed) -> Ordering
      is import(#univ_compare)

    func Strict_Compare(Left, Right : Fixed) -> Ordered::Full_Ordering
      is import(#univ_compare)

    func Min(Left, Right : optional Fixed) -> optional Fixed
      is import(#min)
    func Max(Left, Right : optional Fixed) -> optional Fixed
      is import(#max)

    func Hash(Val : Fixed) -> Unsigned_64
      is import(#identity)

    func Round_To_Int(Val : Fixed) -> Univ_Integer

    func To_String(Val : optional Fixed) -> Univ_String

    func From_String(Str : Univ_String) -> optional Fixed

    func Print(X : Fixed)
    func Println(X : Fixed) is (Println(To_String(X)))

    op "in"(Left : Fixed; Right : Range_Set<Fixed>) 
      -> Boolean is in Range_Set<Fixed>
    
end interface PSL::Core::Fixed

class PSL::Core::Fixed is
    const Value : Univ_Integer

  exports
    op "from_univ"(Univ : Univ_Real) -> Fixed is
        return (Value => Univ_Real::Round_To_Int(Univ/Delta))
    end op "from_univ"

    op "to_univ"(Val : optional Fixed) -> optional Univ_Real is
        if Val is null then
            return null
        else
            return Delta * Int_To_Real(Val.Value)
        end if
    end op "to_univ"

    op "/="(var Left : Fixed; Right : Univ_Real) is
        Left := Left / Right
    end op "/="

    func Print(X : Fixed) is
        var Val : Univ_Real := [[X]]
        Print(Val)
    end func Print

    func To_String(Val : optional Fixed) -> Univ_String is
        return Univ_Real::To_String([[Val]])
    end func To_String

    func From_String(Str : Univ_String) -> optional Fixed is
        return Univ_Real::From_String(Str)
    end func From_String

    func Round_To_Int(Val : Fixed) -> Univ_Integer is
        return Univ_Real::Round_To_Int([[Val]])
    end func Round_To_Int

end class PSL::Core::Fixed

func PSL::Test::Test_Fixed(X : Univ_Real) is
    type My_Fixed is Fixed<Delta => 1.0E-6>

    var XTI : My_Fixed := X
    const Minute : My_Fixed := 60.0
    Println("X = " | XTI)
    Println("X * 2 = " | (XTI*2))
    Println("X + X = " | (XTI + XTI))
    Println("X - X = " | (XTI - XTI))
    Println("X / 2 = " | (XTI / 2))
    Println("X / 2.0 = " | (XTI / 2.0))
    Println("X * 3.0 = " | (XTI * 3.0))
    Println("5.0 * X = " | (5.0 * XTI))
    Println("-5.0 * X = " | (-5.0 * XTI))
    Println("-5.0 = " | -5.0)
    Println("Minute = " | Minute)
    Println("-5.0*Minute = " | -5.0*Minute)

    Println("Round_To_Int(X) = " | Round_To_Int(XTI))

    const Rng : Range_Set<My_Fixed> := 1.0 ..< 5.0

    Print("Rng = ")
    const Open_Ind : Map<Boolean, Univ_String> := [#false => "", #true => "<"]
    for IV in Rng forward loop
        if IV.Low != IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] | ".." | 
              Open_Ind[IV.High_Is_Open] | IV.High | " ")
        else
            Print(IV.Low | " ")
        end if
    end loop
    Print('\n')

    Println("X = " | XTI)
    Println("X in Rng = " | (XTI in Rng))

    if XTI in 1.0 ..< 5.0 then
        Println("X in 1.0 ..< 5.0")
    else
        Println("X not in 1.0 ..< 5.0")
    end if

    Println("X in 1.0 ..< 5.0 = " | (XTI in 1.0 ..< 5.0))

end func PSL::Test::Test_Fixed
interface PSL::Containers::Array
  <Elem_Type is Assignable<>; Indexed_By is Countable<>> 
  implements Indexable<Elem_Type, Indexed_By> is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    const Bounds : Countable_Range<Indexed_By>

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Array

    func Length(Arr : Array) -> Univ_Integer
    op "magnitude"(Array) -> Univ_Integer is Length

    func Bounds(Arr : Array) -> Countable_Range<Indexed_By>

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type
    op "index_set"(Arr : Array) -> Countable_Range<Indexed_By> is Bounds
    op "<|="(var Left : Array; var Right : optional Elem_Type)
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) -> Array
    op "|"(Left, Right : Array) -> Array;
    op "[]"() -> Array
end interface PSL::Containers::Array

class PSL::Containers::Array is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    type Elem_Array is Basic_Array<Elem_Type>
    var Data : Elem_Array
  exports

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Array is
        return (Data => Create(Length(Bounds), Initial_Value),
          Bounds => Bounds)
    end func Create

    func Length(Arr : Array) -> Univ_Integer is
        return Length(Arr.Data)
    end func Length

    func Bounds(Arr : Array) -> Countable_Range<Indexed_By> is
        return Arr.Bounds
    end func Bounds

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type is
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type is
        if Length(Arr) == 0 then
            // Create a one-element array
            Arr := (Data => Create(1, null),
              Bounds => Index .. Index)
        elsif Index < Arr.Bounds.First then
            // Extend below
            Arr := (Data => 
              Elem_Array::Create(Arr.Bounds.First - Index, null) | Arr.Data,
              Bounds => Index .. Arr.Bounds.Last)
        elsif Index > Arr.Bounds.Last then
            // Extend above
            Arr := (Data => 
              Arr.Data | Elem_Array::Create(Index - Arr.Bounds.Last, null),
              Bounds => Arr.Bounds.First .. Index)
        end if
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end op "var_indexing"

    op "<|="(var Left : Array; var Right : optional Elem_Type) is
        // Add Right onto Array
        if Length(Left) == 0 then
            Left := (Data => Create(1, null),
              Bounds => Indexed_By::First() .. Indexed_By::First())
            Left[Indexed_By::First()] <== Right
        else
            Left[Left.Bounds.Last + 1] <== Right
        end if
    end op "<|="
    
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      -> Result : Array is
        Result := Left
        Result[Right.Key] := Right.Value
    end op "|"

    op "|"(Left, Right : Array) -> Result : Array is
        const Left_Len := Length(Left)

        if Left_Len == 0 then
            return Right
        end if

        Result :=
          Create(Left.Bounds.First .. Left.Bounds.Last + Length(Right), null)

        // Copy the Left elements
        for I in Left.Bounds loop
            Result[I] := Left[I]
        end loop

        // Copy the Right elements
        
        for J in Right.Bounds loop
            Result[Left_Len + J] := Right[J]
        end loop
    end op "|"

    op "[]"() -> Result : Array is
        const First := Indexed_By::First()
        return (Data => Create(0, null), Bounds => First + 1 .. First)
            // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Array

func PSL::Test::Test_Array() is
    type Color is Enum< [#red, #green, #blue] >
    type RCB is Array<Integer<Range => 0..0xFF>, Indexed_By => Color>

    const Red : RCB := [#red => 0x33, #green => 0, #blue => 0]
    const Blue : RCB := [#red => 0, #green => 0, #blue => 0x33]
    const Yellow : RCB := [0, 0x33, 0x33]
    const White : RCB := [0xFF, 0xFF, 0xFF]
    
    const RCBs : Vector<RCB> := [Red, Blue, Yellow, White]

    for each C of RCBs forward loop
        Println("#red => " | C[#red] | ", #green => " | C[#green] |
          ", #blue => " | C[#blue])
    end loop
end func PSL::Test::Test_Array
interface PSL::Containers::Index_Pair
  <Index1_Type is Countable<>; Index2_Type is Countable<>> is
  // Two countable indices which can be combined to form an 2D array index
    const Index1 : Index1_Type
    const Index2 : Index2_Type

    func Nth_Pair
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       N : Univ_Integer) -> optional Index_Pair
      // Return Nth Pair given bounds for each of 2 index types
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2)
      // presuming second index varies fastest.
      // Return null if N out of range.

    func Pair_Position
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       Pair : Index_Pair) -> optional Univ_Integer
      // Return position of Pair within bounds
      // presuming Pair.Index1 in Bounds1 and Pair.Index2 in Bounds2
      // and second index varies fastest.
      // Return null if Pair out of range.

end interface PSL::Containers::Index_Pair

class PSL::Containers::Index_Pair is
  exports
    func Nth_Pair
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       N : Univ_Integer) -> optional Index_Pair is
      // Return Nth Pair given bounds for each of 2 index types
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2).
      // Return null if N out of range.
        const Len2 := Length (Bounds2)
        if N <= 0 or else N > Length(Bounds1) * Len2 then
            return null
        else
            const I1 := (N-1) / Len2
            const I2 := (N-1) rem Len2
            return (Index1 => Bounds1.First + I1,
                    Index2 => Bounds2.First + I2)
        end if
    end func Nth_Pair

    func Pair_Position
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       Pair : Index_Pair) -> optional Univ_Integer is
      // Return position of Pair within bounds (starting at 1)
      // presuming Pair.Index1 in Bounds1 and Pair.Index2 in Bounds2
      // and second index varies fastest.
      // Return null if Pair out of range.
        if Pair.Index1 not in Bounds1 then
            var IO := IO::Get_IO()
            IO.Stderr.Println
              (Pair.Index1 | " not in " | Bounds1.First | ".." | Bounds1.Last)
            return null
        elsif Pair.Index2 not in Bounds2 then
            var IO := IO::Get_IO()
            IO.Stderr.Println
              (Pair.Index2 | " not in " | Bounds2.First | ".." | Bounds2.Last)
            return null
        else
            return (Pair.Index1-Bounds1.First) * Length(Bounds2) + 
              (Pair.Index2-Bounds2.First) + 1
        end if
    end func Pair_Position

end class PSL::Containers::Index_Pair

interface PSL::Containers::Index_Pair_Set<Pair is Index_Pair<>> is
  // Set of index pairs
    func Create(Bounds1 : Countable_Range<Pair::Index1_Type>;
                Bounds2 : Countable_Range<Pair::Index2_Type>)
      -> Index_Pair_Set

    op "[]"() -> Index_Pair_Set

    func Count(Index_Pair_Set) -> Univ_Integer

    func Is_Empty(Index_Pair_Set) -> Boolean

    func First(Index_Pair_Set)
      -> optional Pair
    func Last(Index_Pair_Set)
      -> optional Pair
    
    func Remove_First(var Index_Pair_Set)
      -> optional Pair
    func Remove_Last(var Index_Pair_Set)
      -> optional Pair
    func Remove_Any(var Index_Pair_Set)
      -> optional Pair
end interface PSL::Containers::Index_Pair_Set

class PSL::Containers::Index_Pair_Set is
  // Set of index pairs
    const Bounds1 : Countable_Range<Pair::Index1_Type>
    const Bounds2 : Countable_Range<Pair::Index2_Type>
    var First : Univ_Integer
    var Last : Univ_Integer

    func Nth_Pair(Index_Pair_Set; N : Univ_Integer) -> Pair is
      // Return Nth Pair of original Index_Pair_Set
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2).
      // Return null if N out of range.
        return Nth_Pair(Index_Pair_Set.Bounds1, Index_Pair_Set.Bounds2, N)
    end func Nth_Pair

  exports
    func Create(Bounds1 : Countable_Range<Pair::Index1_Type>;
                Bounds2 : Countable_Range<Pair::Index2_Type>)
      -> Index_Pair_Set is
        return (Bounds1 => Bounds1, Bounds2 => Bounds2,
                First => 1, Last => Length(Bounds1) * Length(Bounds2))
    end func Create

    op "[]"() -> Index_Pair_Set is
        return
          (Bounds1 =>
             Pair::Index1_Type::First()+1 .. Pair::Index1_Type::First(),
           Bounds2 =>
             Pair::Index2_Type::First()+1 .. Pair::Index2_Type::First(),
           First => 1,
           Last => 0)
    end op "[]"

    func Count(Index_Pair_Set) -> Univ_Integer is
        return Index_Pair_Set.Last - Index_Pair_Set.First + 1
    end func Count

    func Is_Empty(Index_Pair_Set) -> Boolean is
        return Index_Pair_Set.First > Index_Pair_Set.Last
    end func Is_Empty

    func First(Index_Pair_Set)
      -> optional Pair is
        return Nth_Pair(Index_Pair_Set, Index_Pair_Set.First)
    end func First

    func Last(Index_Pair_Set)
      -> optional Pair is
        return Nth_Pair(Index_Pair_Set, Index_Pair_Set.Last)
    end func Last

    func Remove_First(var Index_Pair_Set)
      -> Result : optional Pair is
        if Is_Empty(Index_Pair_Set) then
            Result := null
        else
            Result := Nth_Pair(Index_Pair_Set, Index_Pair_Set.First)
            Index_Pair_Set.First += 1
        end if
    end func Remove_First

    func Remove_Last(var Index_Pair_Set)
      -> Result : optional Pair is
        if Is_Empty(Index_Pair_Set) then
            Result := null
        else
            Result := Nth_Pair(Index_Pair_Set, Index_Pair_Set.Last)
            Index_Pair_Set.Last -= 1
        end if
    end func Remove_Last

    func Remove_Any(var Index_Pair_Set)
      -> optional Pair is
        if Count(Index_Pair_Set) mod 2 == 1 then
            return Remove_First(Index_Pair_Set)
        else
            return Remove_Last(Index_Pair_Set)
        end if
    end func Remove_Any

end class PSL::Containers::Index_Pair_Set
interface PSL::Containers::Array2D
  <Elem_Type is Assignable<>; Index1 is Countable<>; Index2 is Countable<>> is
  // A 2-D array abstraction where the index types are not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    const Bounds1 : Countable_Range<Index1>
    const Bounds2 : Countable_Range<Index2>

    func Create(Bounds1 : Countable_Range<Index1>;
      Bounds2 : Countable_Range<Index2>;
      Initial_Value : optional Elem_Type)
      -> Array2D

    type Indices is Index_Pair<Index1, Index2>
    type Set_Of_Indices is Index_Pair_Set<Indices>

    func Length1(Arr : Array2D) -> Univ_Integer
    func Length2(Arr : Array2D) -> Univ_Integer

    func Bounds1(Arr : Array2D) -> Countable_Range<Index1>
    func Bounds2(Arr : Array2D) -> Countable_Range<Index2>

    // Indexing operations using an index pair
    op "indexing"(ref Arr : Array2D; Indices) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array2D; Indices)
      -> ref var Elem_Type

    // Indexing operations using two individual indices
    op "indexing"(ref Arr : Array2D; Index1; Index2) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array2D; Index1; Index2)
      -> ref var Elem_Type

    // Set of index pairs that cover the 2D array.
    op "index_set"(Arr : Array2D) -> Set_Of_Indices

    op "[]"() -> Array2D
end interface PSL::Containers::Array2D

class PSL::Containers::Array2D is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    type Elem_Array is
      Big_Array<optional Elem_Type, Indexed_By => Univ_Integer>
    var Data : Elem_Array

    func Extend_Array(var Arr : Array2D; Index1; Index2) is
        // Extend array if necessary to include Index1 and Index2
        if Index1 not in Arr.Bounds1 or else Index2 not in Arr.Bounds2 then
            var Old_Arr <== Arr
            Arr := Create
              (Bounds1 => Min(Old_Arr.Bounds1.First, Index1) ..
                 Max(Old_Arr.Bounds1.Last, Index1),
               Bounds2 => Min(Old_Arr.Bounds2.First, Index2) ..
                 Max(Old_Arr.Bounds2.Last, Index2),
               Initial_Value => null)

            // Move over old data
            for I in Old_Arr.Bounds1 loop
                for J in Old_Arr.Bounds2 loop
                    // Explicitly use "indexing" to avoid infinite recursion
                    "indexing"(Arr, I, J) <== Old_Arr[I, J]
                end loop
            end loop

            // Reclaim old data space
            Old_Arr := null
        end if
    end func Extend_Array

  exports

    func Create(Bounds1 : Countable_Range<Index1>;
      Bounds2 : Countable_Range<Index2>;
      Initial_Value : optional Elem_Type)
      -> Array2D is
        return
          (Data =>
             Create(1 .. Length(Bounds1) * Length(Bounds2), Initial_Value),
           Bounds1 => Bounds1, Bounds2 => Bounds2)
    end func Create

    func Length1(Arr : Array2D) -> Univ_Integer is
        return Length(Arr.Bounds1)
    end func Length1

    func Length2(Arr : Array2D) -> Univ_Integer is
        return Length(Arr.Bounds2)
    end func Length2

    func Bounds1(Arr : Array2D) -> Countable_Range<Index1> is (Arr.Bounds1)
    func Bounds2(Arr : Array2D) -> Countable_Range<Index2> is (Arr.Bounds2)

    // Indexing operations using an index pair
    op "indexing"(ref Arr : Array2D; Indices) -> ref Elem_Type is
        {> Indices.Index1 in Arr.Bounds1; Indices.Index2 in Arr.Bounds2 <}
        return Arr.Data[Pair_Position(Arr.Bounds1, Arr.Bounds2, Indices)]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array2D; Indices)
      -> ref var Elem_Type is
        Extend_Array(Arr, Indices.Index1, Indices.Index2)
        return "indexing"(Arr, Indices.Index1, Indices.Index2)
    end op "var_indexing"

    // Indexing operations using two individual indices
    op "indexing"(ref Arr : Array2D; Index1; Index2) -> ref Elem_Type is
        {> Index1 in Arr.Bounds1; Index2 in Arr.Bounds2 <}
        return Arr.Data
          [Indices::Pair_Position(Arr.Bounds1, Arr.Bounds2, (Index1, Index2))]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array2D; Index1; Index2)
      -> ref var Elem_Type is
        //  We don't allow extending the array when indices given separately
        //  Return ref to appropriate element
        return "indexing"(Arr, Index1, Index2)
    end op "var_indexing"

    // Set of index pairs that cover the 2D array.
    op "index_set"(Arr : Array2D) -> Set_Of_Indices is
        return Create(Arr.Bounds1, Arr.Bounds2)
    end op "index_set"

    op "[]"() -> Array2D is
        return (Data => [],
          Bounds1 => Index1::First()+1 .. Index1::First(),
          Bounds2 => Index2::First()+1 .. Index2::First())
            // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Array2D

func PSL::Test::Test_Array2D() is
    type Shade is Enum< [#white, #black] >
    type Chess_Board is Array2D<Shade,
      Index1 => Integer<1..8>, Index2 => Integer<1..8>>

    const Board_Indices : Chess_Board::Set_Of_Indices := Create(1..8, 1..8)
    var CB : Chess_Board := [for Ix in Board_Indices =>
      (if (Ix.Index1 - Ix.Index2) mod 2 == 0 then #white else #black)]

    for each [Ix => C] of CB forward loop
        Println("CB[" | Ix.Index1 | ", " | Ix.Index2 | "] = " | C)

        {> CB[Ix.Index1, Ix.Index2] == C <}
    end loop
end func PSL::Test::Test_Array2D
interface PSL::Core::Time<> is
  // Time in nanoseconds since Jan 1, 1970

    type Time_Interval is new
      Fixed<Delta => 1.0E-9>

    const Second : Time_Interval := 1.0
    const Millisecond : Time_Interval := 1.0/1000
    const Microsecond : Time_Interval := 1.0/10**6
    const Nanosecond : Time_Interval := 1.0/10**9

    const Minute : Time_Interval := 60.0
    const Hour : Time_Interval := 60 * Minute
    const Day : Time_Interval := 24 * Hour

    type Month_Enum is Enum< 
       [#Jan, #Feb, #Mar, #Apr, #May, #Jun,
        #Jul, #Aug, #Sep, #Oct, #Nov, #Dec] >

    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time

    func Zero() -> Time

    op "+"(Left : Time; Right : Time_Interval) -> Time
      is import("+")
    op "+"(Left : Time_Interval; Right : Time) -> Time
      is import("+")
    op "-"(Left : Time; Right : Time_Interval) -> Time
      is import("-")
    op "-"(Left, Right : Time) -> Time_Interval
      is import("-")

    op "=?"(Left, Right : Time) -> Ordering
      is import(#univ_compare)
    func Strict_Compare(Left, Right : Time) -> Ordered::Full_Ordering
      is import(#univ_compare)

    func Min(Left, Right : optional Time) -> optional Time
      is import(#min)
    func Max(Left, Right : optional Time) -> optional Time
      is import(#max)

    func Seconds_Since_1970(Time) -> Time_Interval
      is import(#identity)

end interface PSL::Core::Time

class PSL::Core::Time is
    const Since_1970 : Time_Interval

    type Year_Kind is Enum< [#normal, #leap] >

    const Month_Base : Array<Array<Univ_Integer, Indexed_By => Year_Kind>,
      Indexed_By => Month_Enum> := 
        [#Jan => [0, 0], #Feb => [31, 31], #Mar => [59, 60], #Apr => [90, 91],
         #May => [120, 121], #Jun => [151, 152], #Jul => [181, 182],
         #Aug => [212, 213], #Sep => [243, 244], #Oct => [273, 274],
         #Nov => [304, 305], #Dec => [334, 335]]

    func Kind_Of_Year(Year : Univ_Integer) -> Year_Kind is
        if Year mod 4 == 0 and then
          (Year mod 100 != 0 or else Year mod 400 == 0) then
            // Every 100 years leap year is omitted, 
            // except for multiples of 400 which *are* leap years.
            return #leap
        else
            return #normal
        end if
    end func Kind_Of_Year

    func Leaps_Before(Year : Univ_Integer) -> Univ_Integer is
        // Number of leap years before this year, starting from 1970
        if Year < 2101 then
            return (Year-1969)/4
        else
            // Every 100 years leap year is omitted, 
            // except for multiples of 400 which *are* leap years.
            return (Year-1969)/4 - (Year-2001)/100
        end if
    end func Leaps_Before

  exports
    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time is
        // Determine number of nanos since Jan 1, 1970
        const Kind := Kind_Of_Year(1970)
        const Base := Month_Base[Month][Kind]

        return (Since_1970 => 
          (Year-1970) * (365*Day) + 
          (Leaps_Before(Year) + Base + Day_Of_Month)*Day +
          Time_Of_Day - Time_Zone)
    end func Create

    func Zero() -> Time is
        return (Since_1970 => 0.0)
    end func Zero

end class PSL::Core::Time

func PSL::Test::Test_Time(X : Univ_Real) is
    var XTI : Time::Time_Interval := X
    const Local_Minute : Time::Time_Interval := 60.0
    Println("X = " | XTI)
    Println("X * 2 = " | XTI*2)
    Println("X + X = " | (XTI + XTI))
    Println("X - X = " | (XTI - XTI))
    Println("X / 2 = " | (XTI / 2))
    Println("X / 2.0 = " | (XTI / 2.0))
    Println("X * 3.0 = " | (XTI * 3.0))
    Println("5.0 * X = " | (5.0 * XTI))
    Println("-5.0 * X = " | (-5.0 * XTI))
    Println("-5.0 = " | -5.0)
    Println("Local_Minute = " | Local_Minute)
    Println("-5.0*Local_Minute = " | (-5.0*Local_Minute))
    Println("Time::Minute = " | Time::Minute)
    Println("-5.0*Time::Minute = " | (-5.0*Time::Minute))
    Println("Time::Hour = " | Time::Hour )
    Println("-5.0*Time::Hour = " | (-5.0*Time::Hour))

    Println("-5.0*Time::Hour = `(-5.0*Time::Hour)");
    Println("-5.0*Time::Hour =? -12.0*Time::Hour = " |
      (5.0*Time::Hour =? -12.0*Time::Hour));
    Println("-5.0*Time::Hour =? +12.0*Time::Hour = " |
      (5.0*Time::Hour =? +12.0*Time::Hour));
      {-5.0*Time::Hour in -12.0*Time::Hour .. +12.0*Time::Hour};
    Println("10*Time::Hour + 5*Time::Minute = " |
      10*Time::Hour + 5*Time::Minute);
    Println("10*Time::Hour + 5*Time::Minute =? 0.0 = " |
      (10*Time::Hour + 5*Time::Minute =? 0.0));
    Println("10*Time::Hour + 5*Time::Minute =? 86400.0 = " |
      (10*Time::Hour + 5*Time::Minute =? 86400.0));
      {10*Time::Hour + 5*Time::Minute in 0.0 .. 86400.0}

    var T : Time := Create(Year => 2011, Month => #Oct, Day_Of_Month => 18,
      Time_Of_Day => 10*Time::Hour + 5*Time::Minute,
      Time_Zone => -5.0*Time::Hour)

    Println("18-Oct-2011 = " | ( T - Zero() ))
    Println("X = " | XTI )
    Println("18-Oct-2011 - X = " | ( (T - XTI) - Zero() ) )

end func PSL::Test::Test_Time
concurrent interface PSL::Core::Clock<> is
    // A module that provides access to a wall clock and
    // to other timers, and an ability to delay the caller
    // for a given amount of time, or until a specified time
    // in the future.
    
    func Create() -> Clock
        // Create a clock, which corresponds to the current wall clock time

    func Create(Now : Time) -> Clock
        // Create a clock, where Now() returns the given time when created

    func Now(locked C : Clock) -> Time
        // Return current reading of clock

    func Now() -> Time
        // Return current reading of wall clock

    queued func Delay(C : Clock; Until : Time)
        // Wait until the given clock reads >= Until

    queued func Delay(Until : Time)
        // Wait until the wall clock reads >= Until

    queued func Delay(C : Clock; For : Time::Time_Interval)
        // Wait until the given clock reads "Now(C) + For"

    queued func Delay(For : Time::Time_Interval)
        // Wait until the wall clock reads "Now() + For"

    func Set(locked var C : Clock; To : Time)
        // Update clock so it reads the given time
end interface PSL::Core::Clock

concurrent class PSL::Core::Clock is

    var Timer_Delta : Time::Time_Interval
        // Amount to be subtracted from Current Time
        // to produce value of timer

    func Current_Time(locked C : Clock) -> Time 
      is import(#clock_current_time)
        // NOTE: Clock parameter is ignored; returns wall clock

    func Wait_For_Delay(queued C : Clock; Until : Time) is 
      import(#clock_delay)
        // Wait until the wall clock reads >= Until
        // NOTE: Clock parameter is ignored

  exports
    func Create() -> Clock is
        // Create a clock, which corresponds to the current wall clock time
        // Println("Create Clock with Delta 0.0")
        return (Timer_Delta => 0.0)
    end func Create

    func Create(Now : Time) -> Result : Clock is
        // Create a clock, where Now() returns the given time when created
        const Delta := Current_Time(Create()) - Now
        // Println("Create Clock with Delta = " | Delta)
        return (Timer_Delta => Current_Time(Create()) - Now)
    end func Create

    func Now(locked C : Clock) -> Result : Time is
        // Return current reading of clock
        Result := Current_Time(C) - C.Timer_Delta
        // Println("Now returning " | Result-Zero())
    end func Now

    func Now() -> Result : Time is
        // Return current reading of wall clock
        var C : Clock := Create()
        Result := Current_Time(C)
        // Println("Now returning " | Result-Zero())
    end func Now

    queued func Delay(C : Clock; Until : Time) is
        // Wait until the given clock reads >= Until
        Wait_For_Delay(C, Until + C.Timer_Delta)
    end func Delay

    queued func Delay(Until : Time) is
        // Wait until the wall clock reads >= Until
        var C : Clock := Create()
        Wait_For_Delay(C, Until)
    end func Delay

    queued func Delay(C : Clock; For : Time::Time_Interval) is
        // Wait until the given clock reads "Now(C) + For"
        // NOTE: Timer_Delta is irrelevant for this one
        // Println("Wait for delay of " | For)
        const Time_Now := Current_Time(C)
        const Until := Time_Now + For
        // Println("Time_Now + " | For | " - Time_Now = " | Until - Time_Now)
        Wait_For_Delay(C, Until)
    end func Delay

    queued func Delay(For : Time::Time_Interval) is
        // Wait until the wall clock reads "Now() + For"
        // NOTE: Timer_Delta is irrelevant for this one
        // Println("Wait for delay of " | For)
        var C : Clock := Create()
        const Time_Now := Current_Time(C)
        const Until := Time_Now + For
        // Println("Time_Now + " | For | " - Time_Now = " | Until - Time_Now)
        Wait_For_Delay(C, Until)
    end func Delay

    func Set(locked var C : Clock; To : Time) is
        // Update clock so it reads the given time
        C.Timer_Delta := Current_Time(C) - To
    end func Set

end class PSL::Core::Clock

func PSL::Test::Test_Clock() is
    var C := Clock::Create()
    const Start := C.Now()
    var Ran := Random::Start (Round_To_Int (Seconds_Since_1970 (Clock::Now())))
    Println("First random number = " | Next(Ran));
    Println("Second random number = " | Next(Ran));
    Println("Third random number = " | Next(Ran));

  then
    Println("About to delay 4.0 seconds")
    C.Delay(4.0)
    Println("Done with delay of 4.0")
  ||
    Println("About to delay 2.0 seconds")
    C.Delay(2.0)
    Println("Done with delay of 2.0")
||    // check that indent of 0 works
    for I in 1..7 loop
        Println("In loop delaying for 1.0")
        C.Delay(1.0)
        Println("Done with delay " | I | " of 1.0")
    end loop
then  // check that indent of 0 works
    Println("Elapsed time: " | (C.Now() - Start))
end func PSL::Test::Test_Clock

concurrent interface PSL::Core::Atomic<Content_Type is Countable<>> is
    func Create(Initial_Val : Content_Type) -> Atomic
      // Create an atomic object with given initial value

    func Set_Value(locked var A : Atomic; Val : Content_Type)
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually

    func Value(locked A : Atomic) -> Content_Type
      // Return the current value
      // TBD: Use atomic hardware instructions eventually

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Content_Type
      // Set Value(A) to New_Val; Return the prior value.

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) -> Content_Type
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.

    func Fetch_And_Add(locked var A : Atomic; Amount : Univ_Integer) ->
      Content_Type
      //  Set Value(A) to Value(A) + Amount; Return the prior value

    func Add_And_Fetch(locked var A : Atomic; Amount : Univ_Integer) ->
      Content_Type
      //  Set Value(A) to Value(A) + Amount; Return the new value
end interface PSL::Core::Atomic

concurrent class PSL::Core::Atomic is
    var Value : Content_Type
  exports
    func Create(Initial_Val : Content_Type) -> Atomic is
      // Create an atomic object with given initial value
        return (Value => Initial_Val)
    end func Create

    func Set_Value(locked var A : Atomic; Val : Content_Type) is
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually
        A.Value := Val
    end func Set_Value

    func Value(locked A : Atomic) -> Content_Type is
      // Return the current value
      // TBD: Use atomic hardware instructions eventually
        return A.Value
    end func Value

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Result : Content_Type is
      // Set Value(A) to New_Val; Return the prior value.
        Result := A.Value
        A.Value := New_Val
    end func Test_And_Set

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) -> Result : Content_Type is
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.
        Result := A.Value
        if Result == Expected_Val then
            A.Value := New_Val
        end if
    end func Compare_And_Swap

    func Fetch_And_Add(locked var A : Atomic; Amount : Univ_Integer) ->
      Result : Content_Type is
      //  Set Value(A) to Value(A) + Amount; Return the prior value
       Result := A.Value
       A.Value += Amount
    end func Fetch_And_Add

    func Add_And_Fetch(locked var A : Atomic; Amount : Univ_Integer) ->
      Content_Type is
      //  Set Value(A) to Value(A) + Amount; Return the new value
       A.Value += Amount
       return A.Value
    end func Add_And_Fetch
end class PSL::Core::Atomic

func PSL::Test::Test_Atomic(X, Y : Univ_Integer) is
    type Atomic_Univ is Atomic<Univ_Integer>
    var AX := Atomic_Univ::Create(X)

    Println("Value(X) = " | Value(AX))

    Set_Value(AX, X+1)
    Println("After Set_Value(" | X+1 | "), Value(X) = " | Value(AX))

    const Z := Test_And_Set(AX, Y)
    Println("Test_And_Set(X, " | Y | ") = " | Z)

    const CAS := Compare_And_Swap(AX, Expected_Val => X-1, New_Val => Y-1)
    Println("Compare_And_Swap(X, " | X-1 | ", " | Y-1 | 
      ") = " | CAS | ", Value(X) = " | Value(AX))

    const CAS2 := Compare_And_Swap(AX, Y, Y-2)
    Println("Compare_And_Swap(X, " | Y | ", " | Y-2 | 
      ") = " | CAS2 | ", Value(X) = " | Value(AX))

end func PSL::Test::Test_Atomic
interface PSL::Core::Unsigned_64<> is
    //  64-bit unsigned type (i.e. mod 2**64), with *no* "null" value.
    op "+"(Right : Unsigned_64) -> Unsigned_64
      is import(#identity)

    op "-"(Right : Unsigned_64) -> Unsigned_64
      is import(#uns_negate)

    op "abs"(Right : Unsigned_64) -> Unsigned_64
      is import(#identity)

    op "magnitude"(Unsigned_64) -> Unsigned_64 is "abs"

    op "+"(Left, Right : Unsigned_64) -> Result : Unsigned_64 
      is import(#uns_add)

    op "-"(Left, Right : Unsigned_64) -> Result : Unsigned_64
      is import(#uns_subtract)

    op "*"(Left, Right : Unsigned_64) -> Result : Unsigned_64 
      is import(#uns_multiply)

    op "/"(Left, Right : Unsigned_64) -> Result : Unsigned_64
      is import(#uns_divide)

    op "**"(Left : Unsigned_64; Right : Univ_Integer) -> Unsigned_64
      is import(#uns_exp)

    op "mod"(Left, Right : Unsigned_64) -> Unsigned_64
      is import(#uns_mod)

    op "rem"(Left, Right : Unsigned_64) -> Unsigned_64
      is import(#uns_mod)

    op "and" (Left, Right : Unsigned_64) -> Unsigned_64
      is import(#uns_and)
    op "or" (Left, Right : Unsigned_64) -> Unsigned_64
      is import(#uns_or)
    op "xor" (Left, Right : Unsigned_64) -> Unsigned_64
      is import(#uns_xor)

    op "+="(var Left : Unsigned_64; Right : Unsigned_64) 
      is import(#uns_assign_add)

    op "-="(var Left : Unsigned_64; Right : Unsigned_64) 
      is import(#uns_assign_subtract)

    op "*="(var Left : Unsigned_64; Right : Unsigned_64) 
      is import(#uns_assign_multiply)

    op "/="(var Left : Unsigned_64; Right : Unsigned_64) 
      is import(#uns_assign_divide)

    op "**="(var Left : Unsigned_64; Right : Univ_Integer) 
      is import(#uns_assign_exp)


    op "=?"(Left, Right : Unsigned_64) -> Ordering
      is import(#uns_compare)

    func Strict_Compare(Left, Right : Unsigned_64) -> Ordered::Full_Ordering
      is import(#uns_compare)

    op ">>"(Unsigned_64; Unsigned_64) -> Unsigned_64 is import(#uns_rshift)

    op "<<"(Unsigned_64; Unsigned_64) -> Unsigned_64 is import(#uns_lshift)

    func Min(Left, Right : Unsigned_64) -> Unsigned_64
      is import(#uns_min)
    func Max(Left, Right : Unsigned_64) -> Unsigned_64
      is import(#uns_max)

    func Hash(Val : Unsigned_64) -> Unsigned_64
      is (Val >> 1)

    op "from_univ"(Lit : Univ_Integer) -> Unsigned_64 
      is import(#uns_from_univ)

    op "to_univ"(Val : Unsigned_64) -> Univ_Integer 
      is import(#uns_to_univ)

    func To_String(Val : Unsigned_64) -> Univ_String
      is import(#to_string_uns)

    func From_String(Str : Univ_String) -> Unsigned_64
      is import(#from_string_uns)

    func Print(X : Unsigned_64) is (Print(To_String(X)))
    func Println(X : Unsigned_64) is (Println(To_String(X)))

    func First() -> Unsigned_64 is ("from_univ"(0))

    func Last() -> Unsigned_64 is ("from_univ"(-1))

    op "not" (Right : Unsigned_64) -> Unsigned_64 is (Last() - Right)

    op ".."(Left, Right : Unsigned_64) -> Countable_Set<Unsigned_64>
      is in Countable_Set<Unsigned_64>
    op "<.."(Left, Right : Unsigned_64) -> Countable_Set<Unsigned_64>
      is in Countable_Set<Unsigned_64>
    op "..<"(Left, Right : Unsigned_64) -> Countable_Set<Unsigned_64>
      is in Countable_Set<Unsigned_64>
    op "<..<"(Left, Right : Unsigned_64) -> Countable_Set<Unsigned_64>
      is in Countable_Set<Unsigned_64>
    op "|"(Left, Right : Unsigned_64) -> Countable_Set<Unsigned_64>
      is in Countable_Set<Unsigned_64>

  implements for Countable

    op "+"(Left : Unsigned_64; Right : Univ_Integer) -> Unsigned_64
      is import(#uns_add_univ)
    op "+"(Left : Univ_Integer; Right : Unsigned_64) -> Unsigned_64
      is (Right + Left)

    op "-"(Left : Unsigned_64; Right : Univ_Integer) -> Unsigned_64
      is (Left + (-Right));
    op "-"(Left, Right : Unsigned_64) -> Univ_Integer
      is import(#uns_subtract_returns_univ)

    op "+="(var Left : Unsigned_64; Right : Univ_Integer)
      is import(#uns_assign_add_univ)
    op "-="(var Left : Unsigned_64; Right : Univ_Integer)
      is import(#uns_assign_subtract_univ)

  implements for Summable

    func From_Int (Int : Univ_Integer) -> optional Unsigned_64 is
      (Int in 0 .. 2**64-1? Int : null)
    func Trunc_To_Int(Val : Unsigned_64) -> Univ_Integer is
      ("to_univ"(Val))
    func Round_To_Int(Val : Unsigned_64) -> Univ_Integer is
      ("to_univ"(Val))
    func Floor_To_Int(Val : Unsigned_64) -> Univ_Integer is
      ("to_univ"(Val))

end interface PSL::Core::Unsigned_64

func PSL::Test::Test_Unsigned_64() is
    type Uns is Unsigned_64<>

    Println("Testing unsigned 64")
    Println("0xA - 0xB = 0x" | Hex_Image (Uns::0xA - Uns::0xB))
    Println("0xA + 0xA = " | Uns::0xA + Uns::0xA)
    Println("0xA or 0x1 = 0x" | Hex_Image(Uns::0xA or Uns::0x1))
    Println("0xA xor 0x2 = 0x" | Hex_Image(Uns::0xA xor Uns::0x2))
    Println("not 0xA = 0x" | Hex_Image(not Uns::0xA))
    Println("");
    Println("for I in 0 .. 15 forward loop ");
    for I in Uns::0 .. Uns::15 forward loop
       Println(" " | I | " * 2**62 - 1 = " | I * 2**62 - 1 | ", 0x" |
         Hex_Image (I * 2**62 - 1));
    end loop
    Println("");
    Println("-2**62 * 2 = " | Hex_Image (-Uns::2**62 * 2));
end func PSL::Test::Test_Unsigned_64

interface PSL::Core::Modular<Modulus : Unsigned_64> is
  // This is an unsigned type whose arithmetic is "modulo" the modulus

    interface Modular_Range<> is
       //  Similar to Countable_Range, except avoids wrap-around issues
       const First : Modular
       const Last : Modular
       op ".."(Left, Right : Modular) -> Modular_Range
       op "<.."(Left, Right : Modular) -> Modular_Range
       op "..<"(Left, Right : Modular) -> Modular_Range
       op "<..<"(Left, Right : Modular) -> Modular_Range
       op "in"(Val : Modular; Interval : Modular_Range) -> Boolean
       func Length(R : Modular_Range) -> Univ_Integer
       op "magnitude"(Modular_Range) -> Univ_Integer is Length
       op "[..]"() -> Modular_Range
       op "[]"() -> Modular_Range

       func Remove_First(var S : Modular_Range) -> optional Modular
       func Remove_Last(var S : Modular_Range) -> optional Modular
       func Remove_Any(var S : Modular_Range) -> optional Modular
    end interface Modular_Range;

    op "from_univ"(Lit : Univ_Integer) -> Modular 
      is import(#integer_from_univ)

    op "to_univ"(Val : Modular) -> Univ_Integer 
      is import(#integer_to_univ)

    op "+"(Right : Modular) -> Modular
      is import(#identity)

    op "-"(Right : Modular) -> Modular

    op "abs"(Right : Modular) -> Modular
      is import(#identity)

    op "magnitude"(Modular) -> Modular is "abs"

    op "+"(Left, Right : Modular) -> Result : Modular

    op "-"(Left, Right : Modular) -> Result : Modular

    op "*"(Left, Right : Modular) -> Result : Modular

    op "/"(Left, Right : Modular) -> Result : Modular
      is import(#uns_divide)

    op "mod"(Left, Right : Modular) -> Modular
      is import(#uns_mod)

    op "rem"(Left, Right : Modular) -> Modular
      is import(#uns_mod)

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "+="(var Left : Modular; Right : Modular)

    op "-="(var Left : Modular; Right : Modular)

    op "*="(var Left : Modular; Right : Modular)

    op "/="(var Left : Modular; Right : Modular) 
      is import(#uns_assign_divide)

    op "**="(var Left : Modular; Right : Univ_Integer)

    op "=?"(Left, Right : Modular) -> Ordering
      is import(#uns_compare)
    func Strict_Compare(Left, Right : Modular) -> Ordered::Full_Ordering
      is import(#uns_compare)

    op ">>"(Modular; Modular) -> Modular is import(">>")

    op "<<"(Modular; Modular) -> Modular is import("<<")

    op "and"(Left, Right : Modular) -> Modular is import(#bit_and)
    op "or"(Left, Right : Modular) -> Modular
    op "xor"(Left, Right : Modular) -> Modular
    op "not"(M : Modular) -> Modular

    func Min(Left, Right : optional Modular) -> optional Modular
      is import(#uns_min)
    func Max(Left, Right : optional Modular) -> optional Modular
      is import(#uns_max)

    func Hash(Val : Modular) -> Unsigned_64
      is import(#identity)

    func To_String(Val : optional Modular) -> Univ_String
      is import(#to_string_uns)

    func From_String(Str : Univ_String) -> optional Modular

    func Print(X : Modular) is (Print(To_String(X)))
    func Println(X : Modular) is (Println(To_String(X)))

    func First() -> Modular

    func Last() -> Modular

    op "[..]"()->Modular_Range is in Modular_Range<>

    op ".."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "<.."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "<..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "|"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
  implements for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding a Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "-"(Left, Right : Modular) -> Result : Univ_Integer

    op "+="(var Left : Modular; Right : Univ_Integer);

    op "-="(var Left : Modular; Right : Univ_Integer);

  implements for Summable

    func From_Int (Int : Univ_Integer) -> optional Modular is
      (Int in 0 .. Modulus-1? Int : null)
    func Trunc_To_Int(Val : Modular) -> Univ_Integer is
      ("to_univ"(Val))
    func Round_To_Int(Val : Modular) -> Univ_Integer is
      ("to_univ"(Val))
    func Floor_To_Int(Val : Modular) -> Univ_Integer is
      ("to_univ"(Val))

end interface PSL::Core::Modular

class PSL::Core::Modular is
    const Content : Unsigned_64;  // So this ends up as a wrapper

    func Bit_Or(Left, Right : Unsigned_64) -> Unsigned_64 
      is import(#bit_or)

    func Bit_Xor(Left, Right : Unsigned_64) -> Unsigned_64 
      is import(#bit_xor)
  exports
    op "-"(Right : Modular) -> Modular is
        return (Content => Modulus - Right.Content)
    end op "-"

    op "+"(Left, Right : Modular) -> Result : Modular is
        return (Content => (Left.Content + Right.Content) mod Modulus)
    end op "+"

    op "-"(Left, Right : Modular) -> Result : Modular is
        return (Content => (Left.Content - Right.Content) mod Modulus)
    end op "-"

    op "*"(Left, Right : Modular) -> Result : Modular is
        return (Content => (Left.Content * Right.Content) mod Modulus)
    end op "*"

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
        return (Content => (Left.Content ** Right) mod Modulus)
    end op "**"

    op "+="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content + Right.Content) mod Modulus)
    end op "+="

    op "-="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content - Right.Content) mod Modulus)
    end op "-="

    op "*="(var Left : Modular; Right : Modular) is
        Left := (Content => (Left.Content * Right.Content) mod Modulus)
    end op "*="

    op "**="(var Left : Modular; Right : Univ_Integer) is
        Left := (Content => (Left.Content ** Right) mod Modulus)
    end op "**="

    func From_String(Str : Univ_String) -> optional Modular is
        const Val : Univ_Integer := From_String(Str)
        if Val is null or else Val in 0..<Modulus then
            return (Content => Val)
        else
            return null
        end if
    end func From_String

    op "or"(Left, Right : Modular) -> Modular is
        return (Content => Bit_Or(Left.Content, Right.Content) mod Modulus)
    end op "or"

    op "xor"(Left, Right : Modular) -> Modular is
        return (Content => Bit_Xor(Left.Content, Right.Content) mod Modulus)
    end op "xor"

    op "not"(M : Modular) -> Modular is
        return (Content => Modulus - 1 - M.Content)
    end op "not"

    func First() -> Modular is
        return (Content => 0)
    end func First

    func Last() -> Modular is
        return (Content => Modulus-1)
    end func Last

    class Modular_Range is
     exports
       op ".."(Left, Right : Modular) -> Modular_Range is
           return (First => Left, Last => Right)
       end op ".."

       op "<.."(Left, Right : Modular) -> Modular_Range is
           return Left.Content == Modulus-1? [] :
                    (First => Left+1, Last => Right)
       end op "<.."

       op "..<"(Left, Right : Modular) -> Modular_Range is
           return Right == 0? [] : (First => Left, Last => Right-1)
       end op "..<"

       op "<..<"(Left, Right : Modular) -> Modular_Range is
           return Left.Content == Modulus-1 or else Right == 0? [] :
                              (First => Left+1, Last => Right-1)
       end op "<..<"

       op "in"(Val : Modular; Interval : Modular_Range) -> Boolean is
           return Val >= Interval.First and then Val <= Interval.Last
       end op "in"

       func Length(R : Modular_Range) -> Univ_Integer is
           return R.Last - R.First + 1
       end func Length

       op "[]"() -> Modular_Range is
           return 1 .. 0
       end op "[]"

       op "[..]"() -> Modular_Range is
           return Modular::First() .. Modular::Last()
       end op "[..]"

       func Remove_First(var S : Modular_Range) 
         -> Result : optional Modular is
           if S.First <= S.Last then
               Result := S.First
               S := Result <.. S.Last
           else
               Result := null
           end if
       end func Remove_First
           
       func Remove_Last(var S : Modular_Range) 
         -> Result : optional Modular is
           if S.First <= S.Last then
               Result := S.Last
               S := S.First ..< Result
           else
               Result := null
           end if
       end func Remove_Last

       func Remove_Any(var S : Modular_Range) 
         -> Result : optional Modular is
           if S.First <= S.Last then
               if (S.Last - S.First) mod 2 == 0 then
                   Result := S.First
                   S := Result <.. S.Last
               else
                   Result := S.Last
                   S := (First => S.First, Last => Result-1)
               end if
           else
               return null
           end if
       end func Remove_Any
    end class Modular_Range

  // implements
  // for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding a Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
        return (Content => (Left.Content + Right) mod Modulus)
    end op "+"

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular is
        return (Content => (Left + Right.Content) mod Modulus)
    end op "+"

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
        return (Content => (Left.Content - Right) mod Modulus)
    end op "-"

    op "-"(Left, Right : Modular) -> Result : Univ_Integer is
        return Left.Content - Right.Content  //  No "mod" here intentionally
    end op "-"

    op "+="(var Left : Modular; Right : Univ_Integer) is
        Left := (Content => (Left.Content + Right) mod Modulus);
    end op "+=";

    op "-="(var Left : Modular; Right : Univ_Integer) is
        Left := (Content => (Left.Content - Right) mod Modulus);
    end op "-=";
end class PSL::Core::Modular
    
func PSL::Test::Test_Modular() is
    type Mod16 is Modular<16>

    Println("Testing mod 16")
    Println("0xA + 0xA = " | Mod16::0xA + Mod16::0xA)
    Println("0xA or 0x1 = " | (Mod16::0xA or Mod16::0x1))
    Println("0xA xor 0x2 = " | (Mod16::0xA xor Mod16::0x2))
    Println("not 0xA = " | (not Mod16::0xA))
    Print("for I in Mod16 is ");
    for I in Mod16 loop
       Print(" " | I);
    end loop
    Println("");
end func PSL::Test::Test_Modular

interface PSL::Containers::Ordered_Set<Element_Type is Ordered<>> is
  // A set over individual but ordered elements
    op "[]"() -> Ordered_Set

    func Singleton(Elem : Element_Type) -> Ordered_Set

    op "|"(Left, Right : Element_Type) -> Ordered_Set
    op "|"(Left : Ordered_Set; Right : Element_Type) 
      -> Ordered_Set
    op "|"(Left : Element_Type; Right : Ordered_Set) 
      -> Ordered_Set
    op "|"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set

    op "|="(var Left : Ordered_Set; Right : Element_Type)
    op "|="(var Left : Ordered_Set; Right : Ordered_Set)

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Ordered_Set) -> Ordered_Set
      // Set difference
    op "-"(Left : Ordered_Set; Right : Element_Type) 
      -> Ordered_Set
      // Remove one element
    op "-="(var S : Ordered_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Ordered_Set; Right : Ordered_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|"   // union
    op "or="(var Left : Ordered_Set; Right : Ordered_Set)
      is "|="

    op "+"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|"   // Union
    op "+="(var Left : Ordered_Set; Right : Ordered_Set)
      is "|="
    op "+="(var Left : Ordered_Set; Right : Element_Type) is "|="
   
    op "and"(Left, Right : Ordered_Set) -> Ordered_Set
        // Intersection
    op "and="(var Left : Ordered_Set; Right : Ordered_Set)

    op "xor"(Left, Right : Ordered_Set) -> Ordered_Set
        // Symmetric difference
    op "xor="(var Left : Ordered_Set; Right : Ordered_Set)

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean

    op "=?"(Left, Right : Ordered_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    func Strict_Compare(Left, Right : Ordered_Set) -> Ordered::Full_Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less or #greater based on a lexicographical ordering
        // Never return #unordered

    func Count(S : Ordered_Set) -> Univ_Integer

    op "magnitude"(Ordered_Set) -> Univ_Integer is Count

    func Is_Empty(S : Ordered_Set) -> Boolean

    func First(S : Ordered_Set) -> optional Element_Type
    func Last(S : Ordered_Set) -> optional Element_Type
    func Any_Element(S : Ordered_Set) -> optional Element_Type

    func Next(S : Ordered_Set; E : Element_Type) -> optional Element_Type
      // Return minimum element in Set greater than E, or null if none
    func Prev(S : Ordered_Set; E : Element_Type) -> optional Element_Type
      // Return maximum element in Set less than E, or null if none

    func Min_No_Less(S : Ordered_Set; E : Element_Type)
      -> optional Element_Type
      // Return minimum element in Set no less than E, or null if none
    func Max_No_Greater(S : Ordered_Set; E : Element_Type)
      -> optional Element_Type
      // Return maximum element in Set no greater than E, or null if none

    func Remove_First(var S : Ordered_Set) -> optional Element_Type
        // Remove first element of set (lowest value)

    func Remove_Last(var S : Ordered_Set) -> optional Element_Type
        // Remove last element of set (highest value)

    func Remove_Any(var S : Ordered_Set) -> optional Element_Type
        // Remove an arbitrary element of set

end interface PSL::Containers::Ordered_Set

class PSL::Containers::Ordered_Set is

    var Items : optional AA_Tree<Element_Type>
    var Count := 0

  exports
    op "[]"() -> Ordered_Set is
        return (Items => [], Count => 0)
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Ordered_Set is
        Result := []
        Result.Items |= Elem
        Result.Count := 1
    end func Singleton

    op "|"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := [];
        Result.Items |= Left;
        Result.Items |= Right;
        Result.Count := Count(Result.Items)
    end op "|"

    op "|"(Left : Ordered_Set; Right : Element_Type) 
      -> Result : Ordered_Set is
        Result := Left
        Result.Items |= Right
        Result.Count := Count(Result.Items)
    end op "|"

    op "|"(Left : Element_Type; Right : Ordered_Set) 
      -> Ordered_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Result : Ordered_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Ordered_Set; Right : Element_Type) is
        Left.Items |= Right;
        Left.Count := Count(Left.Items)
    end op "|="

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type)
      is
        // Move element into set, leaving Right null afterward.
        Left.Items <|= Right
        Left.Count := Count(Left.Items)
    end op "<|="

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set)
      is
        // Move all elements of Right into Left, leaving Right empty.
        if Left.Count == 0 then
            Left.Items <== Right.Items
            Left.Count := Right.Count
            Right.Count := 0
        else
            // Iterate through the tree
            loop
                // Extract element from right
                var Elem for Left := Remove_Any(Right)

                if Elem is null then
                    Left.Count := Count(Left.Items)
                    return   // All done
                end if

                Left.Items <|= Elem

            end loop
        end if
    end op "<|="

    op "|="(var Left : Ordered_Set; Right : Ordered_Set) is
        // Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end op "|="

    op "-"(Left, Right : Ordered_Set) 
      -> Result : Ordered_Set is
      // Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-"(Left : Ordered_Set; Right : Element_Type)
      -> Result : Ordered_Set is
      // Remove one element
        Result := Left
        Result -= Right
    end op "-"
        
    op "-="(var S : Ordered_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
        Delete(S.Items, Elem);
        S.Count := Count(S.Items)
    end op "-="

    op "-="(var Left : Ordered_Set; Right : Ordered_Set) is
      // Remove all elements of Right from Left, if present
        for Elem in Right loop
            Left -= Elem
        end loop
    end op "-="

    op "and"(Left, Right : Ordered_Set)
      -> Result : Ordered_Set is
        // Intersection
        Result := []
        for Elem in Right loop
            if Elem in Left then
                Result += Elem
            end if
        end loop
    end op "and"

    op "and="(var Left : Ordered_Set; Right : Ordered_Set) is
        // Intersection
        for Elem in Left loop
            if Elem not in Right then
                Left -= Elem
            end if
        end loop
    end op "and="

    op "xor"(Left, Right : Ordered_Set) 
      -> Result : Ordered_Set is
        // Symmetric difference
        Result := Left
        Result xor= Right
    end op "xor"

    op "xor="(var Left : Ordered_Set; Right : Ordered_Set) is
        // Symmetric difference
        // Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end op "xor="

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean is
        return Overlapping(Right.Items, Left) not null
    end op "in"

    op "=?"(Left, Right : Ordered_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    func Strict_Compare(Left, Right : Ordered_Set) -> Ordered::Full_Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less or #greater based on a lexicographical ordering
        // Never return #unordered
    is
        for (Left_Elem in Left; Right_Elem in Right) forward loop
           const Result := Strict_Compare(Left_Elem, Right_Elem);
           if Result != #equal then
              return Result
           end if
        end loop
        return |Left| =? |Right|
    end func Strict_Compare

    func Count(S : Ordered_Set) -> Result : Univ_Integer is
        // Return count of items in set
        return S.Count;
    end func Count

    func Is_Empty(S : Ordered_Set) -> Boolean is
        return S.Count == 0;
    end func Is_Empty

    func First(S : Ordered_Set) -> optional Element_Type is
        return First(S.Items);
    end func First

    func Last(S : Ordered_Set) -> optional Element_Type is
        return Last(S.Items);
    end func Last

    func Any_Element(S : Ordered_Set) -> optional Element_Type is
        return Any_Element(S.Items);
    end func Any_Element

    func Next(S : Ordered_Set; E : Element_Type) -> optional Element_Type is
      // Return minimum element in Set greater than E, or null if none
        return Next(S.Items, E);
    end func Next

    func Prev(S : Ordered_Set; E : Element_Type) -> optional Element_Type is
      // Return maximum element in Set less than E, or null if none
        return Prev(S.Items, E);
    end func Prev

    func Min_No_Less(S : Ordered_Set; E : Element_Type)
      -> optional Element_Type is
      // Return minimum element in Set no less than E, or null if none
        return Min_No_Less(S.Items, E);
    end func Min_No_Less

    func Max_No_Greater(S : Ordered_Set; E : Element_Type)
      -> optional Element_Type is
      // Return maximum element in Set no greater than E, or null if none
        return Max_No_Greater(S.Items, E)
    end func Max_No_Greater

    func Remove_First(var S : Ordered_Set) 
      -> Result : optional Element_Type is
        // Return first element of set
        Result := Remove_First(S.Items)
        if Result not null then
           S.Count -= 1
        end if
    end func Remove_First

    func Remove_Last(var S : Ordered_Set) 
      -> Result : optional Element_Type is
        // Remove last element of set
        Result := Remove_Last(S.Items);
        if Result not null then
           S.Count -= 1
        end if
    end func Remove_Last

    func Remove_Any(var S : Ordered_Set) -> Result : optional Element_Type is
        // Remove any element of set
        Result := Remove_Any(S.Items);
        if Result not null then
           S.Count -= 1
        end if
    end func Remove_Any

end class PSL::Containers::Ordered_Set

interface PSL::Core::Enum_With_Rep
  <Rep_Type is Imageable<>;
   Rep_Map : Two_Way_Map<Univ_Enumeration, Rep_Type>> is
  // An enumeration type specified using a map from literal to value
  // of an underlying representation type.
    op "from_univ"(Univ : Univ_Enumeration) 
      {*"Literal not defined for Enum type"*
       (for some [Lit => Val] of Rep_Map => Lit == Univ)}
      -> Enum_With_Rep
    op "to_univ"(Val : optional Enum_With_Rep)
      -> Result : optional Univ_Enumeration
      {Result is null or else
        (for some [Lit => V] of Rep_Map => Lit == Result)}

    // Functions to convert from/to rep
    func From_Rep (Rep : optional Rep_Type) -> optional Enum_With_Rep
    func To_Rep (Val : optional Enum_With_Rep) -> optional Rep_Type

    op "[..]"() -> Ordered_Set<Enum_With_Rep>

    func Strict_Compare(Left, Right : Enum_With_Rep) -> Ordered::Full_Ordering
    op "=?"(Left, Right : Enum_With_Rep) -> Ordering is Strict_Compare

    // Functions for Imageable
    func To_String(Val : optional Enum_With_Rep) -> Univ_String
    func From_String(Str : Univ_String) -> optional Enum_With_Rep

    func Hash(Val : Enum_With_Rep) -> Unsigned_64

    func Min(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    func Max(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep

    func Dump_Rev_Map()
end interface PSL::Core::Enum_With_Rep

class PSL::Core::Enum_With_Rep is
    const Rep : Rep_Type
  exports
    op "from_univ"(Univ : Univ_Enumeration) 
      -> Enum_With_Rep is
        return (Rep => Rep_Map[Univ]);
    end op "from_univ"

    op "to_univ"(Val : optional Enum_With_Rep) 
      -> Result : optional Univ_Enumeration is
        if Val is null then
            return null
        else
            return Key_Of (Rep_Map, Val.Rep)
        end if
    end op "to_univ"

    func From_Rep (Rep : optional Rep_Type) -> optional Enum_With_Rep is
        if Rep is null then
            return null
        else
            return (Rep => Rep)
        end if
    end func From_Rep

    func To_Rep (Val : optional Enum_With_Rep) -> optional Rep_Type is
        if Val is null then
            return null
        else
            return Val.Rep
        end if
    end func To_Rep

    // Functions for Imageable
    func To_String(Val : optional Enum_With_Rep) -> Univ_String is
        const Enum : optional Univ_Enumeration := [[Val]];
        if Enum not null then
            // use enum image
            return Univ_Enumeration::To_String(Enum);
        else
            // use rep-type To_String
            return Rep_Type::To_String(Val.Rep)
        end if
    end func To_String

    func From_String(Str : Univ_String) -> optional Enum_With_Rep is
        if Str[1] == '#' then
            // Presume is an enum
            return Univ_Enumeration::From_String(Str)
        else
            // Use rep-type From_String
            return (Rep => Rep_Type::From_String(Str))
        end if
    end func From_String

    op "[..]"() -> Ordered_Set<Enum_With_Rep> is
        return [for each Rep of Rep_Map => From_Rep(Rep)]
    end op "[..]";

    func Strict_Compare(Left, Right : Enum_With_Rep) -> Ordered::Full_Ordering
    is
        return Left.Rep =? Right.Rep
    end func Strict_Compare

    func Hash(Val : Enum_With_Rep) -> Unsigned_64 is
        return Hash (Val.Rep)
    end func Hash

    func Min(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep > Left.Rep then
            return Left
        else
            return Right
        end if
    end func Min

    func Max(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep < Left.Rep then
            return Left
        else
            return Right
        end if
    end func Max

    func Dump_Rev_Map() is
        const Rev := Rev_Map (Rep_Map)

        for KV in Rev loop
            Println ("[" | KV.Key | " => " | KV.Value | "]")
        end loop
    end func Dump_Rev_Map

end class PSL::Core::Enum_With_Rep

func PSL::Test::Test_Enum_With_Rep() is
    type Color is Enum_With_Rep<Univ_Integer,
               [#red => 1, #green => 3, #blue => 5]>;

    type Day_Of_Week is 
       Enum_With_Rep<Modular<2**7>,
          [#Monday => 1<<0, #Tuesday => 1<<1, #Wednesday => 1<<2,
           #Thursday => 1<<3, #Friday => 1<<4,
            #Saturday => 1<<5, #Sunday => 1<<6]>

    Println ("Dump_Rev_Map():")
    Day_Of_Week::Dump_Rev_Map()

    for C in Color forward loop
        Println("Next color = " | C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " | C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " | D3)
    end loop

    {#Monday in Day_Of_Week}

    for D4 in Day_Of_Week reverse loop
        Println("Prev day of week = " | D4)
    end loop

    for D5 in Day_Of_Week forward loop
        Println("To_Rep(" | D5 | ") = " | To_Rep(D5))
    end loop

    for I in 1..10 forward loop
        Println("Day_Of_Week::From_Rep(" | I | ") = " |
          Day_Of_Week::From_Rep(I))
    end loop

end func PSL::Test::Test_Enum_With_Rep
interface PSL::Core::Enum_Mask
  <Base_Type is Modular<>;
   Rep_Map : Two_Way_Map<Univ_Enumeration, Base_Type>>
  extends PSL::Core::Enum_With_Rep<Base_Type, Rep_Map> is
  // An enumeration type built on a modular type
  // that supports "|" as a way to combine bits into a single value.
    op "|"(Left, Right : Enum_Mask) -> Enum_Mask
       is (From_Rep(To_Rep(Left) or To_Rep(Right)))
end interface PSL::Core::Enum_Mask
concurrent interface PSL::Core::IO<>:
  // Locked versions of the Print, Println and Readln operations
    var Stdout : Standard_Output_Stream
    var Stderr : Standard_Output_Stream

    func Get_IO() -> IO  // Get handle on IO subsystem

    func Print(locked var IO; Univ_String)
    func Println(locked var IO; Univ_String)

    func Print(locked var IO; Val : Val_Type is Imageable<>)
    func Println(locked var IO; Val : Val_Type is Imageable<>)

    func Readln(locked var IO) -> optional Univ_String
        //  Read input up to a newline, from standard input.
        //  Return null value when reaching end of file of standard input
        //  (which can happen when standard input is coming from a file,
        //   or when user types control/D on a Unix-like platform).

    type Exit_Status_Value is new Integer<-9999 .. +9999>
    const Exit_Success : Exit_Status_Value := 0
    const Exit_Failure : Exit_Status_Value := 1 
    func Set_Exit_Status(locked var IO; Exit_Status_Value)
      is import(#set_exit_status)

end interface PSL::Core::IO

concurrent class PSL::Core::IO:
  exports
    func Get_IO() -> IO:
        return (Stdout => (Channel => #stdout),
                Stderr => (Channel => #stderr));

    func Print(locked var IO; Univ_String):
        Print (Univ_String)

    func Println(locked var IO; Univ_String):
        Println (Univ_String)

    func Print(locked var IO; Val : Val_Type is Imageable<>):
        Print (Val_Type::To_String(Val))

    func Println(locked var IO; Val : Val_Type is Imageable<>):
        Println (Val_Type::To_String(Val))

    func Readln(locked var IO) -> optional Univ_String:
        return Readln()

end class PSL::Core::IO
interface PSL::Containers::Imageable_Vector<Element_Type is Imageable<>>
  extends Vector<Element_Type>
  implements Imageable<> is
  //  A vector which can be easily printed.
  //  Requires element type to itself be Imageable.
    func To_String(Val : Imageable_Vector) -> Univ_String<>

    func From_String(Str : Univ_String<>) -> optional Imageable_Vector
      is (null)  // TBD

    func Strict_Compare(Left, Right : Imageable_Vector)
      -> Ordered::Full_Ordering
    op "=?"(Left, Right : Imageable_Vector) -> Ordering is Strict_Compare
    func Hash(Val : Imageable_Vector) -> Unsigned_64

    func Print(Val : Imageable_Vector) is (Print(To_String(Val)))
    func Println(Val : Imageable_Vector) is (Println(To_String(Val)))
end interface PSL::Containers::Imageable_Vector

class PSL::Containers::Imageable_Vector is
  exports
    func To_String(Val : Imageable_Vector) -> Result : Univ_String<> is
        Result := "";
        for (each V of Val; Sep := "[" then ", ") forward loop
            Result |= Sep | V;
        end loop
        return Result | "]"
    end func To_String

    func Strict_Compare(Left, Right : Imageable_Vector) -> Ordering is
        for I in 1 .. Min(|Left|, |Right|) forward loop
            const Result := Left[I] =? Right[I]
            if Result != #equal then
                //  First mismatch determines result
                return Result
            end if
        end loop
        //  Prefixes match, result determined by length comparison
        return |Left| =? |Right|
    end func Strict_Compare

    func Hash(Val : Imageable_Vector) -> Unsigned_64 is
        if |Val| == 0 then
            return 0
        else
            //  Hash first and last
            return Hash(Val[1])*7 + Hash(Val[|Val|])
        end if
    end func Hash
end class PSL::Containers::Imageable_Vector
//  Tuple types

interface PSL::Containers::Pair<T1 is Assignable<>; T2 is Assignable<>> is
   const First  : T1;
   const Second : T2;
end interface PSL::Containers::Pair;

interface PSL::Containers::Triple<T1 is Assignable<>; T2 is Assignable<>;
                                  T3 is Assignable<>> is
   const First  : T1;
   const Second : T2;
   const Third  : T3;
end interface PSL::Containers::Triple;

interface PSL::Containers::Quad<T1 is Assignable<>; T2 is Assignable<>;
                                T3 is Assignable<>; T4 is Assignable<>> is
   const First  : T1;
   const Second : T2;
   const Third  : T3;
   const Fourth : T4;
end interface PSL::Containers::Quad;
func PSL::Test::Test_IO (X, Y : Univ_String; Z : Univ_Integer):
    var IO := IO::Get_IO()
    const Pi := 3.141592653589793
    const True := Boolean::#true

    IO.Print ("Pi = ")
    IO.Print (Pi)
    IO.Print (", True prints as ")
    IO.Print (True)
    IO.Print ('\n')
    IO.Print ("X = \"" | X | '"')
    IO.Print (", Y = \"" | Y | '"')
    IO.Println (", Z = " | Z )
    IO.Print ("Give me somethin: ")
    var Input := IO.Readln()
    IO.Println ("You gave me: \"" | Input | '"')

    IO.Stderr.Println ("This is going to standard error output");
    IO.Stdout.Println ("This is going to standard output");
    IO.Stdout.Println ("About to flush stderr and stdout");
    IO.Stderr.Flush ()
    IO.Stdout.Flush ()

    const Vec : Imageable_Vector<Univ_Integer> := [1, 3, 5, 7, 9]
    IO.Println ("About to print out imageable vector")
    IO.Print (Vec); IO.Print('\n')
end func PSL::Test::Test_IO
    
import PSL::Test::Test_IO

func Test_IO (X, Y : Univ_String; Z : Univ_Integer):
    PSL::Test::Test_IO (X, Y, Z)
end func Test_IO

interface PSL::Core::Output_Stream<> is
  // Output stream interface; all operations
  // expressed in terms of Univ_String print and close
    abstract func Print(var Output_Stream; Univ_String)
    abstract func Flush(var Output_Stream)
    abstract func Close(var optional Output_Stream)

    func Println(var Output_Stream+; Univ_String)

    func Print(var Output_Stream+; Val : Val_Type is Imageable<>)

    func Println(var Output_Stream+; Val : Val_Type is Imageable<>)

end interface PSL::Core::Output_Stream

class PSL::Core::Output_Stream is
  // Output stream interface; all operations
  // expressed in terms of Univ_String print
  exports
    func Println(var Output_Stream+; Univ_String):
        Output_Stream.Print(Univ_String)
        Output_Stream.Print("\n")

    func Print(var Output_Stream+; Val : Val_Type is Imageable<>):
        Output_Stream.Print (Val_Type::To_String(Val))

    func Println(var Output_Stream+; Val : Val_Type is Imageable<>):
        Output_Stream.Print (Val_Type::To_String(Val))
        Output_Stream.Print("\n")

end class PSL::Core::Output_Stream

abstract interface PSL::Core::Input_Stream<> is
    func Readln(var Input_Stream) -> optional Univ_String
        //  Read input up to a newline, from input stream.
        //  Return null value when reaching end of file of input stream.
    func Close(var optional Input_Stream)
end interface PSL::Core::Input_Stream

interface PSL::Core::File_Output_Stream<> extends Output_Stream<> is
    func Create(var IO; Name : Univ_String) -> optional File_Output_Stream
      is import(#create_output_file)
    func Append(var IO; Name : Univ_String) -> optional File_Output_Stream
      is import(#append_output_file)
    func Flush(var File_Output_Stream)
      is import(#flush_output_file)
    func Close(var optional File_Output_Stream)
      is import(#close_output_file)
    func Delete(var optional File_Output_Stream)
      is import(#delete_output_file)

    func Print(var File_Output_Stream; Univ_String)
      is import(#print_to_file)
end interface PSL::Core::File_Output_Stream

class PSL::Core::File_Output_Stream is
    const Name : Univ_String
    const Index : Univ_Integer
  exports
end class PSL::Core::File_Output_Stream

interface PSL::Core::File_Input_Stream<> extends Input_Stream is
    func Open(var IO; Name : Univ_String) -> optional File_Input_Stream
      is import(#open_input_file)
    func Close(var optional File_Input_Stream)
      is import(#close_input_file)
    func Readln(var File_Input_Stream) -> optional Univ_String
      is import(#read_from_file)
        //  Read input up to a newline, from given file.
        //  Return null value when reaching end of file.
end interface PSL::Core::File_Input_Stream

class PSL::Core::File_Input_Stream is
    const Name : Univ_String;
    const Index : Univ_Integer
  exports
end class PSL::Core::File_Input_Stream

interface PSL::Core::Standard_Output_Stream<> extends Output_Stream is
  //  Output stream for one of the "standard" output channels
    type Output_Channel_Enum is Enum<[#stdout, #stderr]>
    const Channel : Output_Channel_Enum

    func Print(var Standard_Output_Stream; Univ_String)
      is import(#print_to_standard_file)

    func Flush(var Standard_Output_Stream)
      is import(#flush_standard_file)

    func Close(var optional Standard_Output_Stream)
      is Flush
end interface PSL::Core::Standard_Output_Stream

func PSL::Test::Test_File (Name, X, Y : Univ_String; Z : Univ_Integer):
    var IO := IO::Get_IO()
    var File := File_Output_Stream::Create(IO, Name);
    const Pi := 3.14159265389793
    const True := Boolean::#true

    IO.Println ("Writing to file: " | Name)

    File.Print ("Pi = ")
    Output_Stream::Print (File, Pi)
    File.Print (", True prints as ")
    Print (File, True)
    Print (File, '\n')
    File.Print ("X = \"" | X | '"')
    Println (File, ", Y = \"" | Y | '"')
    IO.Print ("Give me somethin: ")
    var Inp := IO.Readln()
    IO.Println ("You gave me: \"" | Inp | '"')
    File.Println ("User input = \"" | Inp | '"')
    File.Close();

    var Inp_File := File_Input_Stream::Open(IO, Name)
    IO.Println ("Contents of file " | Name)
    loop
        const Line := Inp_File.Readln()
        if Line is null then
            exit loop
        end if
        IO.Println(Line)
    end loop

    IO.Println("All done")

end func PSL::Test::Test_File
interface PSL::Short_Names<> is
   type Int is Univ_Integer<>
   type Char is Univ_Character<>
   type String is Univ_String<>
   type Real is Univ_Real<>
   type Bool is Boolean<>
   //interface Arr<Element_Type is Assignable<>> extends Basic_Array<Element_Type> is
   //end interface Arr
end interface PSL::Short_Names
interface PSL::Core::Operation_Descriptor<> is
   //  For internal use only
   const Routine_Addr : Univ_Integer;
   const Routine_Index : Univ_Integer;
   const Static_Link : Univ_Integer;
   const Conv_Desc : Univ_Integer;
end interface PSL::Core::Operation_Descriptor;

func PSL::Test::Test_Operation_Descriptor() is
   //  For this Type to appear in the type table,
   //  it must be used. Don't delete this function
   const OD : PSL::Core::Operation_Descriptor := (0, 0, 0, 0);
   Println(OD.Static_Link);
end func PSL::Test::Test_Operation_Descriptor;

interface PSL::Containers::Indexed_Set<Element_Type is Hashable<>;
                                       Id_Type is Integer<>> is
  //  A set where each element is assigned a unique ID when it is first
  //  added to the set, and the Id can be used to retrieve the element later.

   op "[]"() -> Indexed_Set
     // Create an empty indexed set

   func Get_Unique_Id(var Indexed_Set; Element_Type) -> Id_Type
     // Add element to set if not there; in any case return the unique Id
     // for the element.

   op "indexing"(ref const Indexed_Set; Id : Id_Type)
    -> ref const Element_Type
     //  Return ref to element in Indexed_Set with given Id

   op "index_set"(Indexed_Set) -> Countable_Range<Id_Type>
     //  Return set of Ids of all elements in the Indexed_Set

   op "in"(Id : Id_Type; Indexed_Set) -> Boolean
     //  Return #true if Id is in the range of the Indexed_Set

   func All_Ids(Indexed_Set) -> Countable_Range<Id_Type> is "index_set"
     //  Set of all ids in index set

   func Count(Indexed_Set) -> Univ_Integer
     //  Count of elements in the indexed set

   op "magnitude"(Indexed_Set) -> Univ_Integer is Count

end interface PSL::Containers::Indexed_Set

class PSL::Containers::Indexed_Set is
   interface Bucket<> is
      //  Linked list of indices of all elements with the same hash value
      var Id : Id_Type
      var Next : optional Bucket
   end interface Bucket

   const Empty_Bucket : optional Bucket := null

   interface With_Hash<> is
      //  Save a copy of the Hash value to avoid repeatedly re-invoking Hash
      var Elem : Element_Type
      var Saved_Hash : Unsigned_64
   end interface With_Hash

   const Initial_Size := 4  //  Length of initial hash-table backbone

   var IS_Vector   : Vector<With_Hash> := []
   var IS_Hash_Tab : Vector<optional Bucket> :=
     Create(Initial_Size, Empty_Bucket)
  exports
   op "[]"() -> Indexed_Set is
     // Create an empty indexed set
      return ()  //  Everything defaults properly
   end op "[]"

   op "indexing"(ref const Indexed_Set; Id : Id_Type)
     -> ref const Element_Type is
     //  Return ref to element in Indexed_Set with given Id
      return Indexed_Set.IS_Vector[Id].Elem
   end op "indexing"

   op "index_set"(Indexed_Set) -> Countable_Range<Id_Type> is
      return 1 .. |Indexed_Set.IS_Vector|
   end op "index_set"

   op "in"(Id : Id_Type; Indexed_Set) -> Boolean is
     //  Return #true if Id is in the range of the Indexed_Set
      return Id in Indexed_Set.All_Ids()
   end op "in"

   func Get_Unique_Id(var Indexed_Set; Elem : Element_Type) -> Id_Type is
     // Add element to set if not there; in any case return the unique Id
     // for the element.

      const Hash_Val := Hash(Elem)

      //  Search to see if it is already in table
      var Index := Hash_Val mod |Indexed_Set.IS_Hash_Tab| + 1
      ref Bucket_List => Indexed_Set.IS_Hash_Tab[Index]
      for B => Bucket_List then B.Next while B not null loop
         ref Elem_In_Table => Indexed_Set.IS_Vector[B.Id]
         if Elem_In_Table.Saved_Hash == Hash_Val
           and then Elem_In_Table.Elem == Elem
         then
            //  Already in table
            return B.Id
         end if
      end loop

      //  Not in table; add to end of vector
      var Elem_With_Hash : With_Hash for Indexed_Set :=
        (Elem => Elem, Saved_Hash => Hash_Val)
      Indexed_Set.IS_Vector <|= Elem_With_Hash

      //  Assign it a unique id based on position in Indexed_Set
      const New_Id : Id_Type := |Indexed_Set.IS_Vector|

      //  Add to appropriate bucket
      Bucket_List := (Id => New_Id, Next <== Bucket_List)

      //  Now check to see if hash table should be expanded
      if |Indexed_Set.IS_Vector| > 2 * |Indexed_Set.IS_Hash_Tab| then
         //  Table was already at double density.  Expand IS_Hash_Tab
         var Old_HTab <== Indexed_Set.IS_Hash_Tab
         const New_Len := |Old_HTab| * 2
         //  Create hash table with double the number of buckets
         Indexed_Set.IS_Hash_Tab := Create(New_Len, Empty_Bucket)
         for each Old_Bucket of Old_HTab loop
            for B => Old_Bucket then B.Next while B not null loop
               ref Old_Elem => Indexed_Set.IS_Vector[B.Id]
               ref New_Bucket =>
                 Indexed_Set.IS_Hash_Tab[Old_Elem.Saved_Hash mod New_Len + 1]
               //  Insert at front
               New_Bucket := (Id => B.Id, Next <== New_Bucket)
            end loop
         end loop
         Old_HTab := null  --  Recover storage (TBD: should not be necessary)
      end if // Expanding table

      return New_Id
   end func Get_Unique_Id

   func Count(Indexed_Set) -> Univ_Integer is (|Indexed_Set.IS_Vector|)
     //  Count of elements in the indexed set

end class PSL::Containers::Indexed_Set

func PSL::Test::Test_Indexed_Set() is
   type String_Id is new Integer<0 .. 1_000>
   type String_Set is Indexed_Set<Univ_String, String_Id>

   var SST : String_Set := []

   const Hello_Id := SST.Get_Unique_Id("Hello")
   const There_Id := SST.Get_Unique_Id("There")
   const My_Id := SST.Get_Unique_Id("My")
   const Friend_Id := SST.Get_Unique_Id("Friend")

   const Ids : Vector<String_Id> := [Hello_Id, There_Id, My_Id, Friend_Id]

   Print("Secret message:")
   for each Id of Ids forward loop
      Print(" " | SST[Id])
   end loop
   Print('\n')
end func PSL::Test::Test_Indexed_Set

interface PSL::Containers::Ordered_Map
  <Key_Type is Ordered<>; Value_Type is Assignable<>> is
  // An ordered map module, allowing iterating over the keys in
  // forward or reverse order.

    interface Pair<> extends Basic_Key_Value<Key_Type, Value_Type> is
       func Strict_Compare (Left, Right : Pair) -> Ordered::Full_Ordering
         is (Strict_Compare (Left.Key, Right.Key))
       op "=?"(Left, Right : Pair) -> Ordering is Strict_Compare
    end interface Pair

    op "[]"() -> Ordered_Map

    op "|="(var Left : Ordered_Map; Right : Pair)
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.

    op "|"(Left : Ordered_Map; Right : Pair) -> Ordered_Map
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.

    op "<|="(var Left : Ordered_Map; var Right : optional Pair)
        // Move Key/Value pair into map, leaving Right null

    op "<|="(var Left : Ordered_Map; var Right : Ordered_Map)
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.

    op "+="(var Left : Ordered_Map; Right : Pair) is "|="
        // A synonym for adding a key=>value pair

    op "in"(Left : Key_Type; Right : Ordered_Map) -> Boolean
        // Return True if given key has a mapping in the Map

    op "-="(var M : Ordered_Map; Key : Key_Type)   // aka Exclude
        // Remove mapping for Right, if present

    op "index_set"(M : Ordered_Map) -> Ordered_Set<Key_Type>
        // Return set of keys with mappings

    func Keys(M : Ordered_Map) -> Ordered_Set<Key_Type> is "index_set"

    op "indexing"(ref M : Ordered_Map; Key : Key_Type) {Key in M}
      -> ref Value_Type
        // Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Ordered_Map; Key : Key_Type) 
      -> ref var optional Value_Type
        // Used for assignments to M[Key]; Key is added to M if not present

    func Remove_First(var M : Ordered_Map) -> optional Pair
        // Remove mapping from the Map with lowest key value.
        // Return null if Map is empty

    func Remove_Last(var M : Ordered_Map) -> optional Pair
        // Remove mapping from the Map with highest key value.
        // Return null if Map is empty

    func Remove_Any(var M : Ordered_Map) -> optional Pair
        // Remove one mapping from the Map.  Return null if Map is empty

    func Count(M : Ordered_Map) -> Univ_Integer
        // Number of mappings in the table

    op "magnitude"(Ordered_Map) -> Univ_Integer is Count

    func Is_Empty(M : Ordered_Map) -> Boolean
        // Return True if no mappings in the table

    func Dump_Statistics(M : Ordered_Map)
      // A debugging routine to show bucket sizes of Map

end interface PSL::Containers::Ordered_Map

class PSL::Containers::Ordered_Map is
    var Items : optional AA_Tree<Pair> := []
    var Count := 0
  exports
    op "[]"() -> Ordered_Map is (Items => [])

    op "|="(var Left : Ordered_Map; Right : Pair) is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any.
        "var_indexing"(Left, Right.Key) := Right.Value
    end op "|="

    op "|"(Left : Ordered_Map; Right : Pair) -> Result : Ordered_Map is
        // Add Key=>Value to Map, replacing pre-existing mapping
        // for Key, if any in result.
        Result := Left
        Result |= Right
    end op "|"

    op "<|="(var Left : Ordered_Map; var Right : optional Pair) is
        // Move Key/Value pair into map, leaving Right null
        "var_indexing"(Left, Right.Key) <== Right.Value
        Right := null
    end op "<|="

    op "<|="(var Left : Ordered_Map; var Right : Ordered_Map) is
        // Move key/value pairs from Right into Left, leaving Right empty,
        // replacing any pre-existing entries with the same key.
        if Left.Count == 0 then
            Left.Items <== Right.Items
            Left.Count := Right.Count
        else
            // Iterate through the tree
            loop
                // Extract element from right
                var Elem for Left := Remove_Any(Right.Items)

                if Elem is null then
                    Left.Count := Count(Left.Items)
                    return   // All done
                end if

                Left.Items <|= Elem

            end loop
        end if
    end op "<|="

    op "in"(Left : Key_Type; Right : Ordered_Map) -> Boolean is
        // Return True if given key has a mapping in the Map
        const P : Pair := (Key => Left, Value => null)
        return P in Right.Items
    end op "in"

    op "-="(var M : Ordered_Map; Key : Key_Type) is  // aka Exclude
        // Remove mapping for Right, if present
        Delete(M.Items, (Key => Key, Value => null))
        M.Count := Count(M.Items)
    end op "-="

    op "index_set"(M : Ordered_Map) -> Ordered_Set<Key_Type>
      is ([for Item in M.Items => Item.Key])
        // Return set of keys with mappings

    op "indexing"(ref M : Ordered_Map; Key : Key_Type) {Key in M}
      -> ref Value_Type is
        // Used for references to M[Key]; requires the Key to be in M.
        return Unsafe_Indexing(M.Items, (Key => Key, Value => null)).Value
    end op "indexing"

    op "var_indexing"(ref var M : Ordered_Map; Key : Key_Type) 
      -> ref var optional Value_Type is
        // Used for assignments to M[Key]; Key is added to M if not present

        if Key not in M then
            //  Insert new item with Value null
            Insert(M.Items, (Key => Key, Value => null))
            M.Count += 1
        end if

        //  Return reference to item
        return "indexing"(M, Key)
    end op "var_indexing"

    func Remove_First(var M : Ordered_Map) -> Result : optional Pair is
        // Remove mapping from the Map with lowest key value.
        // Return null if Map is empty
        Result := Remove_First(M.Items)
        if Result not null then
           M.Count -= 1
        end if
    end func Remove_First

    func Remove_Last(var M : Ordered_Map) -> Result : optional Pair is
        // Remove mapping from the Map with highest key value.
        // Return null if Map is empty
        Result := Remove_Last(M.Items)
        if Result not null then
           M.Count -= 1
        end if
    end func Remove_Last

    func Remove_Any(var M : Ordered_Map) -> Result : optional Pair is
        // Remove one mapping from the Map.  Return null if Map is empty
        Result := Remove_Any(M.Items)
        if Result not null then
           M.Count -= 1
        end if
    end func Remove_Any

    func Count(M : Ordered_Map) -> Univ_Integer is (M.Count)
        // Number of mappings in the table

    func Is_Empty(M : Ordered_Map) -> Boolean is (M.Count == 0)
        // Return True if no mappings in the table

    func Dump_Statistics(M : Ordered_Map) is (null)
      // A debugging routine to show bucket sizes of Map

end class PSL::Containers::Ordered_Map

func PSL::Test::Test_Ordered_Map() is
    var M : Ordered_Map<Univ_Integer, Univ_String> := []
    
    M |= [3 => "three"]
    M |= [1 => "one"]
    M |= [5 => "five"]

    Println("M = [" |
     (for (each [K => V] of M forward; Sep := "" then ", ") =>
        <""> | Sep | K | " => " | V) | "]")

    M |= [2 => "deux"]
    M |= [1 => "un"]
    M |= [3 => "trois"]
    M |= [5 => "cinq"]

    Println("French M = [" |
     (for (each [K => V] of M forward; Sep := "" then ", ") =>
        <""> | Sep | K | " => " | V) | "]")

    const Keys := M.Keys()

    Println("Keys of M = [" |
     (for (K in Keys forward; Sep := "" then ", ") =>
        <""> | Sep | K) | "]")

    const P4 := Prev(Keys, 4)
    const N4 := Next(Keys, 4)
    const MNL4 := Min_No_Less(Keys, 4)
    const MNG4 := Max_No_Greater(Keys, 4)

    const P3 := Prev(Keys, 3)
    const N3 := Next(Keys, 3)
    const MNL3 := Min_No_Less(Keys, 3)
    const MNG3 := Max_No_Greater(Keys, 3)

    Println("Prev(4) = " | P4 | ", Next(4) = " | N4)
    Println("Min_No_Less(4) = " | MNL4 | ", Max_No_Greater(4) = " | MNG4)
    Println("Prev(3) = " | P3 | ", Next(3) = " | N3)
    Println("Min_No_Less(3) = " | MNL3 | ", Max_No_Greater(3) = " | MNG3)
    
end func PSL::Test::Test_Ordered_Map
interface PSL::Containers::Bit_Set<Element_Type is Countable<>>
  implements
   Ordered_Set<Element_Type> is

    op "[]"() -> Bit_Set

    func Singleton(Elem : Element_Type) -> Bit_Set

    op ".."(Left, Right : Element_Type) -> Bit_Set
    op "<.."(Left, Right : Element_Type) -> Bit_Set
    op "..<"(Left, Right : Element_Type) -> Bit_Set
    op "<..<"(Left, Right : Element_Type) -> Bit_Set

    func Create(Range : Countable_Range<Element_Type>; Val : Boolean)
      -> Bit_Set

    op "|"(Left, Right : Element_Type) -> Bit_Set
    op "|"(Left : Bit_Set; Right : Element_Type) -> Bit_Set
    op "|"(Left : Element_Type; Right : Bit_Set) -> Bit_Set
    op "|"(Left : Bit_Set; Right : Bit_Set) -> Bit_Set

    op "|="(var Left : Bit_Set; Right : Bit_Set)

    op "|="(var Left : Bit_Set; Right : Element_Type)
        // Add element to Bit_Set.

    op "<|="(var Left : Bit_Set; var Right : optional Element_Type)
        // Move element into Bit_Set.

    op "<|="(var Left : Bit_Set; var Right : Bit_Set)
        // Move all elements of Right into Left, leaving Right empty.

    op "in"(Left : Element_Type; Right : Bit_Set) -> Boolean<>

    op "=?"(Left, Right : Bit_Set) -> Ordering
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise

    op "or"(Left, Right : Bit_Set) -> Bit_Set is "|"  // Union
    op "or="(var Left : Bit_Set; Right : Bit_Set) is "|="

    op "+"(Left, Right : Bit_Set) -> Bit_Set is "|"   // Union
    op "+="(var Left : Bit_Set; Right : Bit_Set) is "|="
    op "+="(var Left : Bit_Set; Right : Element_Type) is "|="   // aka Include

    op "and"(Left, Right : Bit_Set) -> Bit_Set
        // Intersection
    op "and="(var Left : Bit_Set; Right : Bit_Set)

    op "xor"(Left, Right : Bit_Set) -> Bit_Set
        // Symmetric difference
    op "xor="(var Left : Bit_Set; Right : Bit_Set)

    op "-"(Left, Right : Bit_Set) -> Bit_Set
        // Bit_Set difference

    op "-="(var Left : Bit_Set; Right : Bit_Set)
        // Compute Bit_Set difference

    op "-="(var S : Bit_Set; Elem : Element_Type)   // aka Exclude
        // Remove one element, if present

    op "indexing"(S : Bit_Set; Elem : Element_Type) -> Boolean is (Elem in S)

    func Count(S : Bit_Set) -> Univ_Integer

    op "magnitude"(Bit_Set) -> Univ_Integer is Count

    func Is_Empty(S : Bit_Set) -> Boolean<>

    func Remove_First(var S : Bit_Set) -> optional Element_Type
      // Remove and return the first element of the Bit_Set S
    func Remove_Last(var S : Bit_Set) -> optional Element_Type
      // Remove and return the last element of the Bit_Set S
    func Remove_Any(var S : Bit_Set) -> optional Element_Type
      // Remove and return an arbitrary element of the Bit_Set S

    func First(S : Bit_Set) -> optional Element_Type
      // Return the first element of the Bit_Set S;
      // return null if S is empty.
    func Last(S : Bit_Set) -> optional Element_Type
      // Return the last element of the Bit_Set S;
      // return null if S is empty.
    func Any_Element(S : Bit_Set) -> optional Element_Type
      // Return an arbitrary element of the Bit_Set S;
      // return null if S is empty.

end interface PSL::Containers::Bit_Set


class PSL::Containers::Bit_Set is
    var Bit_Arr : Packed_Array<Boolean, Indexed_By => Element_Type>
       //  TBD: should add "|", "and", "or" to Packed_Array
    //  When created: Bit_Arr[Bit_Arr.First()] == #true
    //            and  Bit_Arr[Bit_Arr.Last()] == #true
    //  This can change due to "and" and "-"
    var Count : Univ_Integer
  exports
    op "[]"() -> Bit_Set is ((Bit_Arr => [], Count => 0))

    func Singleton(Elem : Element_Type) -> Bit_Set
      is ((Bit_Arr => [Elem => #true], Count => 1))

    op ".."(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left .. Right, #true),
        Count => Max (Right - Left + 1, 0)))
    
    op "<.."(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left <.. Right, #true),
        Count => Max (Right - Left, 0)))
    
    op "<..<"(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left <..< Right, #true),
        Count => Max (Right - Left - 1, 0)))
    
    op "..<"(Left, Right : Element_Type) -> Bit_Set
      is ((Bit_Arr => Create(Left ..< Right, #true),
        Count => Max (Right - Left, 0)))
    
    func Create(Range : Countable_Range<Element_Type>; Val : Boolean)
      -> Bit_Set is ((Bit_Arr => Create(Range, Val),
            Count => Val? |Range| : 0))

    op "|"(Left, Right : Element_Type) -> Result : Bit_Set is
       const Low := Min(Left, Right)
       const High := Max(Left, Right)
       Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
       Result.Bit_Arr[Low] := #true
       Result.Bit_Arr[High] := #true
       Result.Count := Low==High? 1 : 2
    end op "|"
       
    op "|"(Left : Bit_Set; Right : Element_Type) -> Result : Bit_Set is
       if Left.Count == 0 then
          Result := Singleton(Right)
       elsif Right in Left.Bit_Arr.Bounds() then
          //  Left already encompasses Right
          Result := Left
          if not Result.Bit_Arr[Right] then
             Result.Bit_Arr[Right] := #true
             Result.Count += 1
          end if
       else
          //  Right is outside limits of Left
          const Low := Min(Left.Bit_Arr.First(),
                       Max(Right - Left.Count, Element_Type::First()))
          const High := Max(Left.Bit_Arr.Last(), 
                       Min(Right + Left.Count, Element_Type::Last()))
          // Println("Growing bounds of Left from " | Left.Bit_Arr.First() |
          //   " .. " | Left.Bit_Arr.Last() | " to " | Low | " .. " | High)
          Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
          //  Copy over all the #true values from Left
          for each [I => V] of Left.Bit_Arr {V} loop
             Result.Bit_Arr[I] := #true
          end loop
          //  And the Right value
          Result.Bit_Arr[Right] := #true
          Result.Count := Left.Count + 1
       end if;
    end op "|"

    op "|"(Left : Element_Type; Right : Bit_Set) -> Bit_Set
     is (Right | Left)
        
    op "|"(Left : Bit_Set; Right : Bit_Set) -> Result : Bit_Set is
       if Left.Count == 0 then
          return Right
       elsif Right.Count == 0 then
          return Left
       end if

       const Low := Min(Left.Bit_Arr.First(), Right.Bit_Arr.First())
       const High := Max(Left.Bit_Arr.Last(), Right.Bit_Arr.Last())
       if Low == Left.First() and then High == Left.Last() then
          //  Left subsumes Right, start from Left
          Result := Left;
       elsif Low == Right.First() and then High == Right.Last() then
          //  Rights subsumes Left
          return Right | Left
       else
          //  Neither is subsumed, create a new value
          Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
          for each [I => V] of Left.Bit_Arr {V} loop
             Result.Bit_Arr[I] := #true
          end loop
          Result.Count := Left.Count
       end if
       for each [I => V] of Right.Bit_Arr {V and not Result.Bit_Arr[I]} loop
          //  Set bit-arr true for the elements of Right that are not in Left
          Result.Bit_Arr[I] := #true
          Result.Count += 1
       end loop
    end op "|"

    op "|="(var Left : Bit_Set; Right : Bit_Set) is
       if Left.Bit_Arr.First() <= Right.Bit_Arr.First()
         and then Left.Bit_Arr.Last() >= Right.Bit_Arr.Last()
       then
          for each [I => V] of Right.Bit_Arr {V and not Left.Bit_Arr[I]} loop
             Left.Bit_Arr[I] := #true
             Left.Count += 1
          end loop
       else
          Left := Left | Right
       end if
    end op "|="

    op "|="(var Left : Bit_Set; Right : Element_Type) is
       // Add element to Bit_Set.
       if Right in Left.Bit_Arr.Bounds() then
          //  Right is within bounds of Left's bit array
          if not Left.Bit_Arr[Right] then
             Left.Bit_Arr[Right] := #true
             Left.Count += 1
          end if
       else
          //  Need to create a new object
          Left := Left | Right
       end if
    end op "|="

    op "<|="(var Left : Bit_Set; var Right : optional Element_Type) is
        // Move element into Bit_Set.
        // Not worth doing anything special for a bit set
        Left |= Right
        Right := null
    end op "<|="

    op "<|="(var Left : Bit_Set; var Right : Bit_Set) is
        // Move all elements of Right into Left, leaving Right empty.
        Left |= Right
        Right := []
    end op "<|="

    op "in"(Left : Element_Type; Right : Bit_Set) -> Boolean<> is
       return Left in Right.Bit_Arr.Bounds()
         and then
           Right.Bit_Arr[Left]
    end op "in"

    op "=?"(Left, Right : Bit_Set) -> Ordering is
        // Return #equal if Left and Right have the same elements
        // Return #less if Left is a proper subset of Right
        // Return #greater if Left is a proper superset of Right
        // Return #unordered otherwise
        var Right_Count_In_Overlap := 0
        for each [I => Left_V] of Left.Bit_Arr loop
           const Right_V := (I in Right)
           if Left_V != Right_V then
              case Left.Count =? Right.Count of
                 [#equal] =>
                    //  Left can't be subset or superset
                    return #unordered
                 [#less] =>
                    if Left_V > Right_V then
                       //  Left can't be subset or superset
                       return #unordered
                    end if
                 [#greater] =>
                    if Left_V < Right_V then
                       //  Left can't be subset or superset
                       return #unordered
                    end if
              end case
           end if
           if Right_V then
              //  Keep track of number of elements in Right when only
              //  looking at elements in Left's Bit_Arr
              Right_Count_In_Overlap += 1
           end if
        end loop
        case Left.Count =? Right.Count of
           [#equal] =>
              //  Must be equal since same count and equal
              //  in all overlapping items
              return #equal
           [#less] =>
              //  Left is a proper subset of right
              return #less
           [#greater] =>
              if Right.Count > Right_Count_In_Overlap then
                 //  Right has some elements that are not in Left's Bit_Arr
                 return #unordered
              else
                 //  All #true elements of Right have been accounted for,
                 //  so Left is a proper superset of Right
                 return #greater
              end if
        end case
    end op "=?"

    op "and"(Left, Right : Bit_Set) -> Result : Bit_Set is
        // Intersection
        Result := Left
        Result and= Right
    end op "and"

    op "and="(var Left : Bit_Set; Right : Bit_Set) is
        for each [I => V] of Right.Bit_Arr {not V and I in Left} loop
           Left.Bit_Arr[I] := #false
           Left.Count -= 1
        end loop
    end op "and="

    op "xor"(Left, Right : Bit_Set) -> Result : Bit_Set is
       // Symmetric difference
       if Left.Count == 0 then
          return Right
       elsif Right.Count == 0 then
          return Left
       end if

       const Low := Min(Left.Bit_Arr.First(), Right.Bit_Arr.First())
       const High := Max(Left.Bit_Arr.Last(), Right.Bit_Arr.Last())
       if Low == Left.First() and then High == Left.Last() then
          //  Left subsumes Right, start from Left
          Result := Left;
       elsif Low == Right.First() and then High == Right.Last() then
          //  Rights subsumes Left
          return Right xor Left
       else
          //  Neither is subsumed, create a new value
          Result := (Bit_Arr => Create(Low .. High, #false), Count => 0)
          for each [I => V] of Left.Bit_Arr {V} loop
             Result.Bit_Arr[I] := #true
          end loop
          Result.Count := Left.Count
       end if
       for each [I => V] of Right.Bit_Arr {V} loop
          //  Invert element of Result when Right is #true
          if Result.Bit_Arr[I] then
             Result.Bit_Arr[I] := #false
             Result.Count -= 1
          else
             Result.Bit_Arr[I] := #true
             Result.Count += 1
          end if
       end loop
    end op "xor"

    op "xor="(var Left : Bit_Set; Right : Bit_Set) is
       if Left.Bit_Arr.First() <= Right.Bit_Arr.First()
         and then Left.Bit_Arr.Last() >= Right.Bit_Arr.Last()
       then
          //  Right is subsumed by Left
          for each [I => V] of Right.Bit_Arr {V} loop
             //  Invert I'th element of Left
             if Left.Bit_Arr[I] then
                Left.Bit_Arr[I] := #false
                Left.Count -= 1
             else
                Left.Bit_Arr[I] := #true
                Left.Count += 1
             end if
          end loop
       else
          //  Need to create a new object
          Left := Left xor Right
       end if
    end op "xor="

    op "-"(Left, Right : Bit_Set) -> Result : Bit_Set is
        // Bit_Set difference
        Result := Left
        Result -= Right
    end op "-"

    op "-="(var Left : Bit_Set; Right : Bit_Set) is
        // Compute Bit_Set difference
        if Left.Count == 0 then
           //  Nothing to do
           return
        end if

        for I in Max(Left.Bit_Arr.First(), Right.Bit_Arr.First()) ..
          Min(Left.Bit_Arr.Last(), Right.Bit_Arr.Last()) loop
           //  Only need to visit overlapping part of ranges
           if Right.Bit_Arr[I] and then Left.Bit_Arr[I] then
              Left.Bit_Arr[I] := #false
              Left.Count -= 1
           end if
        end loop
    end op "-="

    op "-="(var S : Bit_Set; Elem : Element_Type) is   // aka Exclude
        // Remove one element, if present
        if S.Count == 0 then
           //  Nothing to do
           return
        end if

        if Elem in S.Bit_Arr.Bounds() and then S.Bit_Arr[Elem] then
            S.Bit_Arr[Elem] := #false
            S.Count -= 1
        end if
    end op "-="

    func Count(S : Bit_Set) -> Univ_Integer is (S.Count)

    func Is_Empty(S : Bit_Set) -> Boolean<> is (S.Count == 0)

    func Remove_First(var S : Bit_Set) -> optional Element_Type is
      // Remove and return the first element of the Bit_Set S
      for each [I => V] of S.Bit_Arr {V} forward loop
         S.Bit_Arr[I] := #false
         S.Count -= 1
         return I
      end loop
    end func Remove_First

    func Remove_Last(var S : Bit_Set) -> optional Element_Type is
      // Remove and return the last element of the Bit_Set S
      for each [I => V] of S.Bit_Arr {V} reverse loop
         S.Bit_Arr[I] := #false
         S.Count -= 1
         return I
      end loop
    end func Remove_Last

    func Remove_Any(var S : Bit_Set) -> optional Element_Type is
      // Remove and return an arbitrary element of the Bit_Set S
       if S.Count mod 2 == 0 then
          return Remove_Last(S)
       else
          return Remove_First(S)
       end if
    end func Remove_Any

    func First(S : Bit_Set) -> optional Element_Type is
      // Return the first element of the Bit_Set S;
      // return null if S is empty.
      for each [I => V] of S.Bit_Arr {V} forward loop
         return I
      end loop
    end func First

    func Last(S : Bit_Set) -> optional Element_Type is
      // Return the last element of the Bit_Set S;
      // return null if S is empty.
      for each [I => V] of S.Bit_Arr {V} reverse loop
         return I
      end loop
    end func Last

    func Any_Element(S : Bit_Set) -> optional Element_Type is
      // Return an arbitrary element of the Bit_Set S;
       if S.Count mod 2 == 0 then
          return Last(S)
       else
          return First(S)
       end if
    end func Any_Element

end class PSL::Containers::Bit_Set

func PSL::Test::Test_Bit_Set(Args : Basic_Array<Univ_String>) is
   type BSI is Bit_Set<Integer<0 .. 199>>

   func Print_Set(S : BSI) is
      for (V in S; Sep := "[" then ", ") forward loop
         Print(Sep | V)
      end loop
      Println("]")
   end func Print_Set

   Println("Bit_Set of 3..33 = ")
   Print_Set(3 .. 33)

   var Test_Set : BSI

   if |Args| == 0 then
      Test_Set := [1, 3, 5, 7, 9]
   else
      Test_Set := []
      for each Arg of Args forward loop
         const Val : optional Univ_Integer := From_String(Arg)
         if Val is null then
            Println(Arg | ": not an integer")
         else
            Test_Set |= Val
         end if
      end loop
   end if

   Println ("Initial set:")
   Print_Set(Test_Set)

   Println ("Initial set xor 3..33 = ")
   Print_Set(Test_Set xor (3..33))

   Println ("(Initial set xor 3.33) and Create(15..20, #false) =")
   Print_Set((Test_Set xor (3..33)) and Create(15..20, #false))

   var Ran : Random := Start()
   for I in 1 .. 1000 forward loop
      const R := Ran.Next() mod 200
      if I mod 2 == 1 then
         Println("Adding " | R)
         Test_Set += R
      else
         Println("Subtracting " | R)
         Test_Set -= R
      end if
   end loop

   Println ("After 500 random adds and 500 random subtracts there are " |
     Test_Set.Count() | " left in set:")
   Print_Set(Test_Set)

end func PSL::Test::Test_Bit_Set
interface PSL::Containers::Big_Array
  <Elem_Type is Assignable<>; Indexed_By is Countable<>> 
  implements Indexable<Elem_Type, Indexed_By> is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
  // and where the length can be greater than 65K

    const Bounds : Countable_Range<Indexed_By>

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Big_Array

    func Length(Arr : Big_Array) -> Univ_Integer
    op "magnitude"(Big_Array) -> Univ_Integer is Length

    func Bounds(Arr : Big_Array) -> Countable_Range<Indexed_By>

    op "indexing"(ref Arr : Big_Array; Index : Indexed_By) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Big_Array; Index : Indexed_By) 
      -> ref var Elem_Type
    op "index_set"(Arr : Big_Array) -> Countable_Range<Indexed_By> is Bounds
    op "<|="(var Left : Big_Array; var Right : optional Elem_Type)
    op "|"(Left : Big_Array; Right : Key_Value<Indexed_By, Elem_Type>) -> Big_Array
    op "|"(Left, Right : Big_Array) -> Big_Array;
    op "[]"() -> Big_Array
end interface PSL::Containers::Big_Array

class PSL::Containers::Big_Array is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
  // and where the length can be greater than 65K
    const Chunk_Len_Bits := 15
    const Chunk_Len := 2 ** Chunk_Len_Bits
    type Elem_Array is Basic_Array<Elem_Type>
    type Arr_Of_Arr is Basic_Array<optional Elem_Array>
    var Data : Arr_Of_Arr
  exports

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Result : Big_Array is
        const Len := Length (Bounds)
        const Num_Chunks := (Len + Chunk_Len - 1) / Chunk_Len
        Result := (Data => Create(Num_Chunks, null), Bounds => Bounds)
        if Num_Chunks > 0 then
            for I in 1 ..< Num_Chunks loop
                Result.Data[I] := Create(Chunk_Len, Initial_Value)
            end loop
            Result.Data[Num_Chunks] :=
              Create(Len - (Num_Chunks-1)*Chunk_Len, Initial_Value)
        end if
    end func Create

    func Length(Arr : Big_Array) -> Univ_Integer is
        return Length(Arr.Bounds)
    end func Length

    func Bounds(Arr : Big_Array) -> Countable_Range<Indexed_By> is
        return Arr.Bounds
    end func Bounds

    op "indexing"(ref Arr : Big_Array; Index : Indexed_By) -> ref Elem_Type is
        const Zero_Based_Index := Index - Arr.Bounds.First
        return Arr.Data[Zero_Based_Index / Chunk_Len + 1]
                          [Zero_Based_Index rem Chunk_Len + 1]
    end op "indexing"

    op "var_indexing"(ref var Arr : Big_Array; Index : Indexed_By) 
      -> ref var Elem_Type is
        if Length(Arr) == 0 then
            // Create a one-element Big_Array
            Arr := Create(Index .. Index, null)
        elsif Index < Arr.Bounds.First then
            // Extend below
            const Old_Arr <== Arr
            Arr := Create(Index .. Arr.Bounds.Last, null)
            for I in Old_Arr.Bounds loop
               "indexing"(Arr, I) := Old_Arr[I]
            end loop
        elsif Index > Arr.Bounds.Last then
            // Extend above; try to move unchanged old data into new array
            var Old_Arr <== Arr
            const New_Bounds : Countable_Range<Indexed_By> :=
              Old_Arr.Bounds.First .. Index;
            const Old_Len := Length (Old_Arr.Bounds)
            const New_Len := Length (New_Bounds)
            const Old_Num_Chunks := Length(Old_Arr.Data)
            const New_Num_Chunks := (New_Len + Chunk_Len - 1) / Chunk_Len
            //  Create new array
            Arr := (Data => Create(New_Num_Chunks, null), Bounds => New_Bounds)

            //  Move over unchanged chunks
            const Unchanged_Chunks := Old_Len mod Chunk_Len == 0?
                                          Old_Num_Chunks : Old_Num_Chunks-1
            for I in 1 .. Unchanged_Chunks loop
                Arr.Data[I] <== Old_Arr.Data[I]
            end loop

            //  Fill in intervening uninitialized chunks
            for I in Unchanged_Chunks <..< New_Num_Chunks loop
                Arr.Data[I] := Create(Chunk_Len, null)
            end loop
           
            //  Create final new chunk
            Arr.Data[New_Num_Chunks] :=
              Create(New_Len - (New_Num_Chunks-1)*Chunk_Len, null)

            //  Copy over old data
            if Old_Num_Chunks > Unchanged_Chunks then
                for I in 1 .. Old_Len - Unchanged_Chunks * Chunk_Len loop
                    Arr.Data[Old_Num_Chunks][I] <==
                      Old_Arr.Data[Old_Num_Chunks][I]
                end loop
            end if
        end if
        return "indexing"(Arr, Index)
    end op "var_indexing"

    op "<|="(var Left : Big_Array; var Right : optional Elem_Type) is
        // Add Right onto Big_Array
        if Length(Left) == 0 then
            Left :=
              Create(Indexed_By::First() .. Indexed_By::First(), null)
            Left[Indexed_By::First()] <== Right
        else
            Left[Left.Bounds.Last + 1] <== Right
        end if
    end op "<|="
    
    op "|"(Left : Big_Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      -> Result : Big_Array is
        Result := Left
        Result[Right.Key] := Right.Value
    end op "|"

    op "|"(Left, Right : Big_Array) -> Result : Big_Array is
        const Left_Len := Length(Left)

        if Left_Len == 0 then
            return Right
        end if

        Result :=
          Create(Left.Bounds.First .. Left.Bounds.Last + Length(Right), null)

        // Copy the Left elements
        for I in Left.Bounds loop
            Result[I] := Left[I]
        end loop

        // Copy the Right elements
        
        for J in Right.Bounds loop
            Result[Left_Len + J] := Right[J]
        end loop
    end op "|"

    op "[]"() -> Result : Big_Array is
        const First := Indexed_By::First()
        return Create(First + 1 .. First, null)
            // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Big_Array

func PSL::Test::Test_Big_Array(Len : Univ_Integer) is
   {Len > 0}
   Println("Len = " | Len)
   type Elem is Integer<0 .. 2**24-1>
   var BA : Big_Array<Elem, Indexed_By => Univ_Integer> := Create(1..Len, 0)
   BA[(Len+1)/2] := 42
   BA[Len] := 33
   BA[1] := 77
   var X : Elem := 88
   BA <|= X
   Println("After <|= 88, len = " | |BA| | ", arr[" | |BA| | "] = " |
     BA[|BA|])
   {BA[(Len+1)/2] == 42}
   {BA[Len] == 33}
   {BA[1] == 77}
   var Null_BA : Big_Array<Boolean, Indexed_By => Elem> := []
   {|Null_BA| == 0}
   {Null_BA.Bounds.First == 1}
   {Null_BA.Bounds.Last == 0}
end func PSL::Test::Test_Big_Array

interface PSL::Containers::Stack<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Stack implemented on top of an Extendable Stack,
  // indexed by Univ_Integer, 0..Depth-1, [0] = top of stack
    op "[]"() -> Stack
    op "indexing"(ref S : Stack; Index : Univ_Integer) -> 
      ref Element_Type
    op "index_set"(S : Stack) -> Countable_Range<Univ_Integer>
    func Bounds(S : Stack) -> Countable_Range<Univ_Integer> is "index_set"
    func Push(var S : Stack; Elem : Element_Type)
    op "|="(var S : Stack; Elem : Element_Type) is Push
    op "<|="(var S : Stack; var Elem : optional Element_Type)
    func Pop(var S : Stack) -> Element_Type
    func Discard(var S : Stack)  //  Ignore result of pop
    func Top(ref S : Stack) -> ref Element_Type is (S[0])
    func Depth(S : Stack) -> Univ_Integer
    func Is_Empty(S : Stack) -> Boolean
    op "magnitude"(Stack) -> Univ_Integer is Depth
end interface PSL::Containers::Stack

class PSL::Containers::Stack is
  // Stack implemented on top of an Extendable Stack,
  // indexed by Univ_Integer, 0..Depth-1, [0] = top of stack
    var Data : Vector<Element_Type> := []
    var Depth : Univ_Integer := 0;
 exports
    op "[]"() -> Stack
      is (Data => [], Depth => 0)

    op "indexing"(ref S : Stack; Index : Univ_Integer) -> ref Element_Type
      is (S.Data[S.Depth - Index])

    op "index_set"(S : Stack) -> Countable_Range<Univ_Integer>
      is (0 .. S.Depth-1)

    func Push(var S : Stack; Elem : Element_Type) is
       S.Depth += 1
       if |S.Data| < S.Depth then
          S.Data |= Elem
       else
          S.Data[S.Depth] := Elem
       end if
    end func Push

    op "<|="(var S : Stack; var Elem : optional Element_Type) is
       S.Depth += 1
       if |S.Data| < S.Depth then
          S.Data <|= Elem
       else
          S.Data[S.Depth] <== Elem
       end if
    end op "<|="

    func Pop(var S : Stack) -> Result : Element_Type is
       {S.Depth > 0}

       Result <== S.Data[S.Depth]
       S.Depth -= 1
    end func Pop

    func Discard(var S : Stack) is //  Ignore result of pop
      //  Just pop the stack, but don't return the element there.
       {S.Depth > 0}
       S.Data[S.Depth] := null
       S.Depth -= 1
    end func Discard

    func Is_Empty(S : Stack) -> Boolean is (S.Depth == 0)

    func Depth(S : Stack) -> Univ_Integer is (S.Depth)
end class PSL::Containers::Stack

func PSL::Test::Test_Stack(Args : Basic_Array<Univ_String>) is
    var S : Stack<Univ_String> := []
    for each A of Args forward loop
       S |= A
       Println("Pushing " | A)
       Println("Stack depth now " | S.Depth())
    end loop

    if |S| > 0 then
       Println("Top of stack = " | S.Top())
       Println("Bottom of stack = " | S[|S|-1])
    else
       Println("Stack is empty")
    end if

    for I in 1 .. S.Depth() loop
       Println("Popping " | S.Pop())
       Println("Stack depth now " | S.Depth())
    end loop

    Println("Pushing and then popping \"hi there\"");
    S.Push("hi there");
    S.Discard();
    Println("Stack depth now " | S.Depth())
end func PSL::Test::Test_Stack
interface PSL::Containers::Node_Tree<Key_Type is Hashable<>> is
  //  Define a rooted tree of nodes, where each node may have zero or more
  //  child nodes.  Each node in a tree is assigned a unique Node_Id.
  //  Each child node has a key.  All children of a given node must
  //  have unique keys, but the same key may be re-used for children
  //  of different parent nodes.
  //  Ancestors of a node may be retrieved, given the distance to the
  //  ancestor.
   type Node_Id is Integer<1 .. 100_000>;

   func Create() -> Node_Tree;
     //  Create a tree with a single (root) node.

   op "[]"() -> Node_Tree is Create;
     //  Create a (nearly) empty tree.

   func Root(Node_Tree) -> Node_Id;
     //  Return node id of root of tree.

   func Num_Nodes(Node_Tree) -> Univ_Integer;
   op "magnitude"(Node_Tree) -> Univ_Integer is Num_Nodes;
     //  Return number of nodes in tree.
     //  Root counts

   func Add_Child(var Node_Tree; Parent : Node_Id; Key : Key_Type)
     { Find_Child(Node_Tree, Parent, Key) is null }
     -> Node_Id;
     //  Add new child node to given Parent node, with given Key
     //  Pre: child with given key must not exist

   func Find_Child(Node_Tree; Parent : Node_Id; Key : Key_Type)
     -> optional Node_Id;
     //  Find child node of given Parent node, with given Key, if any.
     //  Return null if no such child.

   func Get_Child(var Node_Tree; Parent : Node_Id; Key : Key_Type)
     -> Node_Id;
     //  Add new child node to given Parent node, with given Key, if
     //  it doesn't already exist.
     //  If child already exists, return Node_Id of existing child.

   func Children(Node_Tree; Parent : Node_Id) -> Ordered_Set<Node_Id>;
     //  Return set of children of given node.

   func Child_Keys(Node_Tree; Parent : Node_Id) -> Set<Key_Type>;
     //  Return set of keys of children of given parent node.
   
   func Depth(Node_Tree; Node_Id) -> Univ_Integer {Depth >= 0};
     //  Return depth of given node.  Depth(Root_Id) == 0

   func Ancestor(Node_Tree; Node_Id;
                      Distance : Univ_Integer {Distance >= 0})
     -> optional Node_Id
     //  Return ancestor node in tree, at given "distance."
     //  Parent node at distance 1, Root node at distance Depth(Node_Id).
     //  Return null if Distance > Depth(Node_Id)

end interface PSL::Containers::Node_Tree;
class PSL::Containers::Node_Tree is
  //  Define a rooted tree of nodes, where each node may have zero or more
  //  child nodes.  Each node in a tree is assigned a unique Node_Id.
  //  Each child node has a key.  All children of a given node must
  //  have unique keys, but the same key may be re-used for children
  //  of different parent nodes.
  //  Ancestors of a node may be retrieved, given the distance to the
  //  ancestor.
   var Children : Map<Node_Id, Map<Key_Type, Node_Id>> := [];
   var Num_Nodes : Univ_Integer := 1;
   const Root_Id : Node_Id := 1;
   var Parent : Map<Node_Id, Node_Id> := []

  exports

   func Create() -> Node_Tree is
     //  Create a tree with a single (root) node.
      return ()
   end func Create

   func Root(Node_Tree) -> Node_Id is
     //  Return node id of root of tree.
      return Node_Tree::Root_Id
   end func Root

   func Num_Nodes(Node_Tree) -> Univ_Integer is
     //  Return number of nodes in tree.
     //  Root counts
      return Node_Tree.Num_Nodes
   end func Num_Nodes

   func Add_Child(var Node_Tree; Parent : Node_Id; Key : Key_Type)
     { Find_Child(Node_Tree, Parent, Key) is null }
     -> Result : Node_Id is
     //  Add new child node to given Parent node, with given Key
     //  Pre: child with given key must not exist
      if Parent not in Node_Tree.Children then
         Node_Tree.Children[Parent] := []
      else
         { Key not in Node_Tree.Children[Parent] }
      end if
      Node_Tree.Num_Nodes += 1
      Result := 0 + Node_Tree.Num_Nodes
      Node_Tree.Children[Parent][Key] := Result
      Node_Tree.Parent[Result] := Parent  //  Remember parent
   end func Add_Child

   func Find_Child(Node_Tree; Parent : Node_Id; Key : Key_Type)
     -> optional Node_Id is
     //  Find child node of given Parent node, with given Key, if any.
     //  Return null if no such child.
      if Parent in Node_Tree.Children then
         ref Sibs => Node_Tree.Children[Parent]
         if Key in Sibs then
            return Sibs[Key]
         end if
      end if
      return null
   end func Find_Child;

   func Get_Child(var Node_Tree; Parent : Node_Id; Key : Key_Type)
     -> Node_Id is
     //  Add new child node to given Parent node, with given Key, if
     //  it doesn't already exist.
     //  If child already exists, return Node_Id of existing child.
      const Existing_Child := Find_Child(Node_Tree, Parent, Key)
      if Existing_Child not null then
         return Existing_Child
      else
         return Add_Child(Node_Tree, Parent, Key)
      end if
   end func Get_Child

   func Children(Node_Tree; Parent : Node_Id) -> Ordered_Set<Node_Id> is
     //  Return set of children of given node.
      if Parent not in Node_Tree.Children then
         return []
      else
         return [for each Id of Node_Tree.Children[Parent] => Id]
      end if
   end func Children
   
   func Child_Keys(Node_Tree; Parent : Node_Id) -> Set<Key_Type> is
     //  Return set of keys of children of given parent node.
      if Parent not in Node_Tree.Children then
         return []
      else
         return [for each [Key => Id] of Node_Tree.Children[Parent] => Key]
      end if
   end func Child_Keys
   
   func Depth(Node_Tree; Node_Id) -> Univ_Integer {Depth >= 0} is
     //  Return depth of given node.  Depth(Root_Id) == 0
      return (for N := Node_Id then Node_Tree.Parent[N]
                 while N in Node_Tree.Parent => <0> + 1)
   end func Depth

   func Ancestor(Node_Tree; Node_Id;
                      Distance : Univ_Integer {Distance >= 0})
     -> optional Node_Id is
     //  Return ancestor node in tree, at given "distance."
     //  Parent node at distance 1, Root node at distance Depth(Node_Id).
     //  Return null if Distance > Depth(Node_Id)
      for (Anc := Node_Id then Node_Tree.Parent[Anc];
           D := Distance then D - 1) forward loop
         if D == 0 then
            return Anc
         elsif Anc not in Node_Tree.Parent then
            exit loop;
         end if
      end loop
      return null
   end func Ancestor

end class PSL::Containers::Node_Tree;

import PSL::Containers::Node_Tree
func PSL::Test::Test_Node_Tree() is
   type Int_Tree is Node_Tree<Univ_Integer>
   var T : Int_Tree := Create()
   const Sub1 := Add_Child(T, T.Root(), 41)
   const Sub2 := Add_Child(T, Sub1, 42)
   const Sub3 := Add_Child(T, T.Root(), 43)
   Println("Depth(Sub2) = " | Depth(T, Sub2))
   Println("Node_Id of Sub1 = " | Sub1)
   Println("Node_Id of Sub3 = " | Sub3)
   Println("Ancestor(Sub2, 2) = " | Ancestor(T, Sub2, 2));
   const Root_Children := Children(T, T.Root())
   const Root_Child_Keys := Child_Keys(T, T.Root())
   Println("Child keys of Root:")
   for each K of Root_Child_Keys loop
      Println("  " | K | " => " | Find_Child(T, T.Root(), K))
   end loop
   Println("Child nodes of Root:")
   for each C of Root_Children forward loop
      Println("  " | C)
   end loop
end func PSL::Test::Test_Node_Tree

//  Byte stream used for (de)serializing values/objects
//
//  Streaming in ParaSail is a three layer cake:
//    Byte Stream is the lowest layer
//    Value Stream is the middle layer
//    Object Stream is the top layer
//
//  A byte stream abstracts away the actual file, network, or internal buffer
//  that holds the bytes of the stream.
//  The minimal operations for a byte stream are:
//    For input:
//      func Read
//        (var Input_Byte_Stream;
//         var Data : Stream_Element_Array)
//        -> Bytes_Read : Stream_Count;
//    For output: 
//      func Write
//        (var Output_Byte_Stream;
//         Data : Stream_Element_Array)
//        -> Bytes_Written : Stream_Count;
//  Other operations depend on the kind of the byte stream.
//  For example, for a file byte stream, there are operations to
//  create and/or open the file.
//
//  A value stream abstracts away the byte representation of any given
//  value, where a value could be a number or a string, possibly optional,
//  and possibly surrounded by syntax to indicate that the value is part of
//  a larger composite object, such as a sequence or a dictionary, or
//  an object of some user-defined type.
//
//  An object stream abstracts away the set of values and other syntax
//  that are used to represent a high-level object.

interface PSL::Core::Byte_Stream<> is
   const Stream_Elem_Size := 8;

   type Stream_Element is Modular<2**Stream_Elem_Size>;
   type Stream_Index is Integer<0 .. Integer_64::Last()>;
   type Stream_Count is Stream_Index;

   type Stream_Element_Array is Packed_Array<Stream_Element, Stream_Index>;

   func Num_Bytes_For_Int
     (Low, High : Univ_Integer {Low <= High}; Is_Optional : Boolean)
      -> Num_Bytes : Univ_Integer;
     //  Determine representation to use for integers
     //  based on low and high bound.

   func Null_To_Use
     (Low, High : Univ_Integer {Low <= High})
      -> optional Univ_Integer;
     //  Determine value to use to represent "null" given non-null value range.

   const Null_8_Byte_Arr : Stream_Element_Array := [0, 0, 0, 0, 0, 0, 0, 0x80];
   //  Representation of "null" in stream when Null_To_Use returns null

end interface PSL::Core::Byte_Stream;

class PSL::Core::Byte_Stream is

 exports

   func Num_Bytes_For_Int
     (Low, High : Univ_Integer {Low <= High}; Is_Optional : Boolean)
      -> Num_Bytes : Univ_Integer is
     //  Determine representation to use for integers
     //  based on low and high bound.
     //  If Low >= 0 will presume an unsigned representation.
      const Room_For_Null := (if Is_Optional then 1 else 0);

      if Low >= 0 then
         --  Can use unsigned

         if High <= 2**8 - 1 - Room_For_Null then
            Num_Bytes := 1;
         elsif High <= 2**16 - 1 - Room_For_Null then
            Num_Bytes := 2;
         elsif High <= 2**24 - 1 - Room_For_Null then
            Num_Bytes := 3;
         elsif High <= 2**32 - 1 - Room_For_Null then
            Num_Bytes := 4;
         elsif High <= 2**64 - 1 - Room_For_Null then
            Num_Bytes := 8;
         else
            --  Use variable length
            Num_Bytes := -1;
         end if;
      else
         --  Use signed

         if High <= 2**7-1 and then Low >= -2**7 + Room_For_Null then
            --  Use 8-bit elements
            Num_Bytes := 1;
         elsif High <= 2**15-1 and then Low >= -2**15 + Room_For_Null then
            --  Use 16-bit elements
            Num_Bytes := 2;
         elsif High <= 2**31-1 and then Low >= -2**31 + Room_For_Null then
            --  Use 32-bit elements
            Num_Bytes := 4;
         elsif High <= 2**63-1 and then Low >= -2**63 + Room_For_Null then
            --  Use 64-bit elements
            Num_Bytes := 8;
         else
            --  Use variable length
            Num_Bytes := -1;
         end if;
      end if;
   end func Num_Bytes_For_Int;

   func Null_To_Use
     (Low, High : Univ_Integer {Low <= High})
      -> optional Univ_Integer is
     //  Determine value to use to represent "null" given non-null value range.
      const Num_Bytes :=
        Num_Bytes_For_Int (Low, High, Is_Optional => #true);

      if Low < 0 then
         //  Use most-negative value that fits in num bytes
         if Num_Bytes < 0 then
            //  Just below "Low" -- TBD: round down to power of 2
            return Low-1;
         elsif Num_Bytes == 8 then
            --  Use "regular" null
            return null;
         else
            //  Use most-negative value that fits
            return -2**(Num_Bytes * 8 - 1);
         end if;
      else
         //  Unsigned value.
         //  Use most-positive value that fits in num bytes
         if Num_Bytes < 0 then
            //  Just above "High"  --  TBD: round up to power of 2
            return High+1;
         elsif Num_Bytes == 8
           and then High <= 2**63-1
         then
            //  Use regular null
            return null;
         else
            //  Use most-positive value that fits
            return 2**(Num_Bytes * 8) - 1;
         end if;
      end if;
   end func Null_To_Use;
end class PSL::Core::Byte_Stream;

abstract interface PSL::Core::Input_Byte_Stream<>
  extends Byte_Stream<> is
   func Read  (var Input_Byte_Stream;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count;
end interface PSL::Core::Input_Byte_Stream;

abstract interface PSL::Core::Output_Byte_Stream<>
  extends Byte_Stream<> is
   func Write (var Output_Byte_Stream;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count;
end interface PSL::Core::Output_Byte_Stream;

interface PSL::Core::Byte_Stream_Buffer<>
  extends Byte_Stream<> implements Input_Byte_Stream, Output_Byte_Stream is

   func Create (Initial_Size : Stream_Count := 100;
                Allow_Growth : Boolean := #true)
     -> Byte_Stream_Buffer;
   //  Will automatically grow if Allow_Growth #true and reaches Initial_Size

   func Create (Initial_Content : Stream_Element_Array;
                Allow_Growth : Boolean := #true) -> Byte_Stream_Buffer;
   //  Create a new buffer from a stream-element array.
   //  Will allow growth if Allow_Growth #true.

   func Write (var BSB : Byte_Stream_Buffer;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count;

   func Read  (var BSB : Byte_Stream_Buffer;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count;

   func Bytes_To_Read (BSB : Byte_Stream_Buffer) -> Univ_Integer;

   func Bytes_To_Write (BSB : Byte_Stream_Buffer) -> Univ_Integer;
   //  Returns current grown increment if Allow_Growth is #true,
   //  otherwise returns amount left.

   func Read_Remainder (var BSB : Byte_Stream_Buffer) -> Stream_Element_Array;
   //  Return everything left in stream as a single array.

end interface PSL::Core::Byte_Stream_Buffer;

interface PSL::Core::Byte_Stream_Output_File<>
  extends Output_Byte_Stream<> is

   func Create (var IO; Name : Univ_String)
     -> optional Byte_Stream_Output_File
      is import(#create_output_file)

   func Append (var IO; Name : Univ_String)
     -> optional Byte_Stream_Output_File
      is import(#append_output_file)

   func Flush(var Byte_Stream_Output_File)
      is import(#flush_output_file)

   func Close(var optional Byte_Stream_Output_File)
      is import(#close_output_file)

   func Delete(var optional Byte_Stream_Output_File)
      is import(#delete_output_file)

   func Write (var Byte_Stream_Output_File;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count
       is import(#write_bytes_to_file)

end interface PSL::Core::Byte_Stream_Output_File;

interface PSL::Core::Byte_Stream_Input_File<>
  extends Input_Byte_Stream<> is
   func Open (var IO; Name : Univ_String) -> optional Byte_Stream_Input_File
      is import(#open_input_file)

   func Close(var optional Byte_Stream_Input_File)
      is import(#close_input_file)

   func Read  (var Byte_Stream_Input_File;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count
       is import(#read_bytes_from_file)

end interface PSL::Core::Byte_Stream_Input_File;

class PSL::Core::Byte_Stream_Buffer is

   const Allow_Growth : Boolean;
   var Buf : Stream_Element_Array;
   var Write_Index : Byte_Stream::Stream_Index := 0;
   var Read_Index : Byte_Stream::Stream_Index := 0;
   const Debug : Boolean := #false;
 exports
   func Create (Initial_Size : Stream_Count := 100;
                Allow_Growth : Boolean := #true)
     -> Byte_Stream_Buffer is
   //  Will automatically grow if Allow_Growth #true and reaches Initial_Size
      return (Allow_Growth => Allow_Growth,
              Buf => Create (0 ..< Initial_Size, 0));
   end func Create;

   func Create (Initial_Content : Stream_Element_Array;
                Allow_Growth : Boolean := #true) -> Byte_Stream_Buffer is
   //  Create a new buffer from a stream-element array.
   //  Will allow growth if Allow_Growth #true.
      return (Allow_Growth => Allow_Growth,
              Buf => Initial_Content,
              Write_Index => |Initial_Content|);
   end func Create;

   func Write (var BSB : Byte_Stream_Buffer;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count is

      const Amt_Left := |BSB.Buf| - BSB.Write_Index;

      if BSB.Allow_Growth then
         if |Data| > Amt_Left then
            //  At least double the size of the buffer
            const Extra_Space := Max (|BSB.Buf|, |Data| - Amt_Left);
            BSB.Buf := BSB.Buf | Create (0 ..< Extra_Space, 0);
         end if;
         Bytes_Written := |Data|;
      else
         Bytes_Written := Min (|Data|, Amt_Left);
      end if;

      for (Left in BSB.Write_Index .. BSB.Buf.Last();
           Right in Data.Bounds()) forward loop
         BSB.Buf [Left] := Data [Right];
         // Println("write BSB.Buf[`(Left)] = `(BSB.Buf[Left])");
      end loop;

      if Debug and then Bytes_Written != |Data| then
         Println("|Data| = `(|Data|) but Bytes_Written = `(Bytes_Written)");
      end if;

      BSB.Write_Index += Bytes_Written;
   end func Write;

   func Read  (var BSB : Byte_Stream_Buffer;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count is
      Bytes_Read := Min (|Data|, BSB.Write_Index - BSB.Read_Index);

      for (Left in Data.Bounds();
           Right in BSB.Read_Index ..< BSB.Write_Index) forward loop
         // Println("read BSB.Buf[`(Right)] = `(BSB.Buf[Right])");
         Data [Left] := BSB.Buf [Right];
      end loop;
      BSB.Read_Index += Bytes_Read;

      if BSB.Read_Index == BSB.Write_Index then
         --  Buffer is empty, so reset indices
         BSB.Read_Index := 0;
         BSB.Write_Index := 0;
      end if;
   end func Read;

   func Bytes_To_Read (BSB : Byte_Stream_Buffer) -> Univ_Integer is
     (BSB.Write_Index - BSB.Read_Index);

   //  If Allow_Growth, return current buffer size
   func Bytes_To_Write (BSB : Byte_Stream_Buffer) -> Univ_Integer is
     ((if BSB.Allow_Growth then |BSB.Buf|
       else BSB.Buf.Last() - BSB.Write_Index + 1));

   func Read_Remainder
     (var BSB : Byte_Stream_Buffer) -> Result : Stream_Element_Array is
   //  Return everything left in stream as a single array.
      
      Result := Create(0 .. Bytes_To_Read (BSB), 0);
      for (I in 0 .. Result.Bounds.Last;
           J in BSB.Read_Index .. BSB.Write_Index - 1) forward loop
         Result[I] := BSB.Buf[J];
      end loop;
      BSB.Read_Index := 0;
      BSB.Write_Index := 0;
   end func Read_Remainder;

end class PSL::Core::Byte_Stream_Buffer;

class PSL::Core::Byte_Stream_Output_File is
    const Name : Univ_String
    const Index : Univ_Integer
  exports
end class PSL::Core::Byte_Stream_Output_File;

class PSL::Core::Byte_Stream_Input_File is
    const Name : Univ_String
    const Index : Univ_Integer
  exports
end class PSL::Core::Byte_Stream_Input_File;

func PSL::Test::Test_Byte_Stream() is
   var Buf : Byte_Stream_Buffer := Create (Initial_Size => 100);

   for I in 1 .. 7 forward loop
      const Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 15, I);
      const Written := Buf.Write(Arr)
      if Written != 15 then
         Println ("Tried to write 15 bytes, but only `(Written) were written");
      else
         Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
      end if;
   end loop;

   var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 15, 0);

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Bytes_Read := Buf.Read(Arr)
      Println ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
      if Bytes_Read != 15 then
         Println ("Tried to read 15 bytes, but only `(Bytes_Read) were read");
      else
         for Z in 1 .. 10 loop
            if Arr[Z] != I then
               Println ("Expected `(I) in Arr[`(Z)] but found `(Arr[Z])");
            end if;
         end loop;
      end if;
   end loop;
   
   Println (" Now using zero-based array");

   for I in 1 .. 7 forward loop
      const ZB_Arr : Byte_Stream::Stream_Element_Array := Create(0 ..< 15, I);
      const Written := Buf.Write(ZB_Arr)
      if Written != 15 then
         Println ("Tried to write 15 bytes, but only `(Written) were written");
      else
         Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
      end if;
   end loop;

   var ZB_Arr : Byte_Stream::Stream_Element_Array := Create(0 ..< 15, 0);

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Bytes_Read := Buf.Read(ZB_Arr)
      Println ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
      if Bytes_Read != 15 then
         Println ("Tried to read 15 bytes, but only `(Bytes_Read) were read");
      else
         for Z in ZB_Arr.Bounds() loop
            if ZB_Arr[Z] != I then
               Println
                 ("Expected `(I) in ZB_Arr[`(Z)] but found `(ZB_Arr[Z])");
            end if;
         end loop;
      end if;
   end loop;
   
   Println ("All done");
end func PSL::Test::Test_Byte_Stream;

func PSL::Test::Test_File_Stream() is
   var IO := IO::Get_IO()

   var Out_File : Byte_Stream_Output_File := IO.Create ("test_file");

   for I in 1 .. 7 forward loop
      const Arr : Byte_Stream::Stream_Element_Array :=
         Create(1 .. (I == 7? 10: 15), I);
      const Written := Out_File.Write(Arr)
      if Written != 15 then
         Println ("Tried to write 15 bytes, but only `(Written) were written");
      end if;
   end loop;

   Out_File.Close();

   var In_File : Byte_Stream_Input_File := IO.Open ("test_file");

   var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 15, 0);

   for I in 1 .. 7 forward loop
      const Bytes_Read := In_File.Read(Arr)
      if Bytes_Read != 15 then
         Println ("Tried to read 15 bytes, but only `(Bytes_Read) were read");
      else
         for Z in 1 .. 10 loop
            if Arr[Z] != I then
               Println ("Expected `(I) in Arr[`(Z)] but found `(Arr[Z])");
            end if;
         end loop;
      end if;
   end loop;

   In_File.Close();
   
   Println ("All done");
end func PSL::Test::Test_File_Stream;

interface PSL::Core::Binary_Output_Value_Stream<>
  extends PSL::Core::Output_Value_Stream<> is

   func Create(ref var Output_Byte_Stream+) -> Binary_Output_Value_Stream;

   func Is_Self_Describing (Binary_Output_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.
     //  If true, it also requires that the Key of each Key/Value
     //  pair of a Map is required to be a string, and written/read using
     //  {Write,Read}_String.  The actual key could be of any type with
     //  appropriate {To,From}_String routines, but those conversions
     //  must be performed in the higher level code.

   func Reached_End(Binary_Output_Value_Stream) -> Boolean;

   func Write_Int (var Binary_Output_Value_Stream; Val : Univ_Integer;
      Low, High : Univ_Integer) {Val in Low .. High};
   func Write_Optional_Int
     (var Binary_Output_Value_Stream; Val : optional Univ_Integer;
      Low, High : Univ_Integer);

   func Write_Float (var Binary_Output_Value_Stream; Val : Univ_Float;
      Digits : Univ_Integer);
   func Write_Optional_Float
     (var Binary_Output_Value_Stream; Val : optional Univ_Float;
      Digits : Univ_Integer);

   func Write_String (var Binary_Output_Value_Stream; Val : Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
      {Min_Len >= 0 and then |Val| in Min_Len .. Max_Len};
   func Write_Optional_String
     (var Binary_Output_Value_Stream; Val : optional Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer);

   func Write_Begin_Seq (var Binary_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer);
   func Write_Begin_Optional_Seq (var Binary_Output_Value_Stream;
      Min_Len, Max_Len : Univ_Integer; Actual_Len : optional Univ_Integer);

   func Write_End_Seq (var Binary_Output_Value_Stream);

   func Write_Begin_Map (var Binary_Output_Value_Stream);
   func Write_Begin_Optional_Map (var Binary_Output_Value_Stream;
      Is_Null : Boolean);

   func Write_End_Map (var Binary_Output_Value_Stream);

   func Write_Begin_Poly (var Binary_Output_Value_Stream; Type_Name : Univ_String);
   func Write_Begin_Optional_Poly (var Binary_Output_Value_Stream;
      Type_Name : optional Univ_String);
   func Write_End_Poly (var Binary_Output_Value_Stream);

   func Write_Begin_Obj (var Binary_Output_Value_Stream);
   func Write_Begin_Optional_Obj (var Binary_Output_Value_Stream;
      Is_Null : Boolean);
   func Write_End_Obj (var Binary_Output_Value_Stream);
end interface PSL::Core::Binary_Output_Value_Stream;

class PSL::Core::Binary_Output_Value_Stream is
   ref var Byte_Str : Output_Byte_Stream+;
   var End_Reached : Boolean := #false;
   var Arr_Len_Left : Univ_Integer := -1;
   const Debug : Boolean := #false;

   func Float_To_Unsigned_64 (Val : optional Univ_Float) -> Unsigned_64
     is import(#identity);

   func Write_Int_Shared
     (var OVS: Binary_Output_Value_Stream;
      Val : optional Univ_Integer;
      Low, High : Univ_Integer;
      Is_Optional : Boolean) is

      const Num_Bytes :=
        Byte_Stream::Num_Bytes_For_Int (Low, High, Is_Optional);

      if Debug then
         Println
           ("Write_Int_Shared, Num_Bytes(`(Low),`(High)) = `(Num_Bytes)");
      end if;

      //  Replace null with value to use in stream
      const Val_To_Use := Val is null?
                            Byte_Stream::Null_To_Use (Low, High): Val;

      if Debug and then Val is null then
         Println("Val is null, Val_To_Use = `(Val_To_Use)");
      end if;

      if Num_Bytes < 0 then
         //  Use variable-length representation
         var Num_To_Write := 0;

         for V := abs Val_To_Use then V/2**32 while V != 0 loop
            Num_To_Write += 1;
         end loop;
         {Num_To_Write <= 2**15-1}

         //  Write out count of 32-bit digits as a signed 16-bit number
         //  where the sign of the count is the sign of the value.
         Write_Int (OVS,
                    (if Val_To_Use < 0 then -Num_To_Write else Num_To_Write),
                    Low => -2**15, High => 2**15-1);
         //  Now write out little-endian
         for V := abs Val_To_Use then V/2**32 while V != 0 loop
            Write_Int (OVS, V mod 2**32, Low => 0, High => 2**32-1);
         end loop;
      elsif Val_To_Use is null then
         {Num_Bytes == 8}
         const Written := Write (OVS.Byte_Str, Byte_Stream::Null_8_Byte_Arr);
         if Written != Num_Bytes then
            if Debug then
               Println("End Reached: Num_Bytes = `(Num_Bytes), " |
                       "Written = `(Written)");
            end if;
            OVS.End_Reached := #true;
         end if;
      else
         --  Use fixed-length representation (either signed or unsigned)
         var Buf : Byte_Stream::Stream_Element_Array :=
           Create(0 ..< Num_Bytes, 0);

         for (I in Buf.Bounds(); V := Val_To_Use then V/2**8) forward loop
            const Byte := V mod 2**8;
              //  Do as a separate step so done using univ int arith

            Buf [I] := Byte;
         end loop

         const Written := Write (OVS.Byte_Str, Buf);

         if Written != Num_Bytes then
            if Debug then
               Println("End Reached: Num_Bytes = `(Num_Bytes), " |
                       "Written = `(Written)");
            end if;
            OVS.End_Reached := #true;
         end if;
      end if;
   end func Write_Int_Shared;

 exports

   func Create(ref var Output_Byte_Stream+) -> Binary_Output_Value_Stream is
     ((Byte_Str => Output_Byte_Stream));

   func Is_Self_Describing (Binary_Output_Value_Stream) -> Boolean is
     (#false);
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.
     //  If true, it also requires that the Key of each Key/Value
     //  pair of a Map is required to be a string, and written/read using
     //  {Write,Read}_String.  The actual key could be of any type with
     //  appropriate {To,From}_String routines, but those conversions
     //  must be performed in the higher level code.

   func Reached_End(Binary_Output_Value_Stream) -> Boolean is
     (Binary_Output_Value_Stream.End_Reached);

   func Write_Int (var OVS: Binary_Output_Value_Stream; Val : Univ_Integer;
      Low, High : Univ_Integer) is

      Write_Int_Shared (OVS, Val, Low, High, Is_Optional => #false);
   end func Write_Int;

   func Write_Optional_Int
     (var OVS : Binary_Output_Value_Stream; Val : optional Univ_Integer;
      Low, High : Univ_Integer) is

      Write_Int_Shared (OVS, Val, Low, High, Is_Optional => #true);
   end func Write_Optional_Int;

   func Write_Float (var Binary_Output_Value_Stream; Val : Univ_Float;
      Digits : Univ_Integer) is
      //  Just pass the buck to the optional one
      Write_Optional_Float (Binary_Output_Value_Stream, Val, Digits);
   end func Write_Float;

   func Write_Optional_Float
     (var Binary_Output_Value_Stream; Val : optional Univ_Float;
      Digits : Univ_Integer) is
      const Equiv_Uns_Val : Unsigned_64 := Float_To_Unsigned_64(Val);
      var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 8, 0);

      for (I in Arr.Bounds(); V := Equiv_Uns_Val then V >> 8) forward loop
         Arr[I] := [[V and 0xFF]];
         //  Println("Arr[`(I)] = `(Arr[I]), V = `(V)");
      end loop;

      const Bytes_Written := Write (Binary_Output_Value_Stream.Byte_Str, Arr);
      if Bytes_Written != 8 then
         //  Information was lost
         if Debug then
            Println("End Reached: Bytes_Written = `(Bytes_Written) != 8");
         end if;
         Binary_Output_Value_Stream.End_Reached := #true;
      end if;
   end func Write_Optional_Float;

   func Write_String (var OVS : Binary_Output_Value_Stream; Val : Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer) is
     //  Use UTF-8 unless Max_Char's code is in range 0x80 to 0xFF
     //  in which case we will use a simple sequence of 8-bit characters.
     //  Emit a length first if Min_Len != Max_Len or Max_Len = 0.
     //  An empty string is represented by a length of zero followed by a zero.
      const Nul_Ch : Univ_Character := Univ_Character::First();
      const Use_UTF_8 : Boolean := Max_Char - Nul_Ch not in 0x80 .. 0xFF;
      const Use_Len : Boolean := Min_Len != Max_Len or else Max_Len == 0;

      if Use_Len then
         const Len := |Val|;
         Write_Int (OVS, Len, Low => 0, High => Max_Len);
         if Len == 0 then
            //  An empty string is [0, 0]
            Write_Int (OVS, 0, Low => 0, High => 0xFF);
            return;
         end if;
      elsif Val[1] == Nul_Ch then
         //  When not using a length, we always "double" an initial zero
         //  to distinguish it from a null value, which is a 0,0x7F
         Write_Int (OVS, 0, Low => 0, High => 0xFF);
      end if;
      
      for each C of Val forward loop
         {C <= Max_Char}
         const Code : Univ_Integer := C - Nul_Ch;
         var Arr : Byte_Stream::Stream_Element_Array;

         if Use_UTF_8 then
            case Code of
               [0 .. 0x7F] => 
                  Arr := [Code];
               [0x80 .. 0x7FF] =>
                  Arr := [0xC0 + (Code >> 6), 0x80 + (Code and 0x3F)];
               [0x800 .. 0xFFFF] =>
                  Arr := [0xE0 + (Code >> 12), 0x80 + (Code >> 6 and 0x3F),
                          0x80 + (Code and 0x3F)];
               [0x1_0000 .. 0x1F_FFFF] =>
                  Arr :=
                   [0xF0 + (Code >> 18), 0x80 + (Code >> 12 and 0x3F),
                    0x80 + (Code >> 6 and 0x3F), 0x80 + (Code and 0x3F)];
               [..] => //  Nonstandard
                  Arr :=
                   [0xF8 + (Code >> 24), 0x80 + (Code >> 18 and 0x3F),
                    0x80 + (Code >> 12 and 0x3F), 0x80 + (Code >> 6 and 0x3F),
                    0x80 + (Code and 0x3F)];
            end case;
         else
            //  Just give one octet to each character
            Arr := [Code and 0xFF];
         end if;

         if Debug then
            Print("C = \"`(C)\", Code = 0x`(Hex_Image(Code)), ");
            for (each A of Arr; Sep := "Arr = [" then ", ") forward loop
               Print(Sep | "0x" | Hex_Image(A));
            end loop;
            Println("]");
         end if;

         const Bytes_Written := Write (OVS.Byte_Str, Arr);

         if Bytes_Written != |Arr| then
            if Debug then
               Println("End Reached: |Arr| = `(|Arr|), " |
                       "Bytes_Written = `(Bytes_Written)");
            end if;
            OVS.End_Reached := #true;
         end if;
      end loop
   end func Write_String;

   func Write_Optional_String
     (var OVS : Binary_Output_Value_Stream; Val : optional Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer) is
     //  A null-valued string (as opposed to the empty string)
     //  is represented by a length of zero followed a 0x7F.
     //  An empty string is represented by a length of zero followed by a zero.
     //  A fixed-length string that starts with a 0x7F has an extra
     //  0x7F tagged on the front.

      if Val is null then
         //  Null
         const Bytes_Written := Write(OVS.Byte_Str, [0, 0x7F]);
         if Bytes_Written != 2 then
            OVS.End_Reached := #true;
         end if;
      else
         //  Pass the buck
         Write_String (OVS, Val, Max_Char, Min_Len, Max_Len);
      end if;
   end func Write_Optional_String;

   func Write_Begin_Seq (var OVS : Binary_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer) is
      Write_Int (OVS, Actual_Len, Low => Min_Len, High => Max_Len);
   end func Write_Begin_Seq;
    
   func Write_Begin_Optional_Seq (var OVS : Binary_Output_Value_Stream;
      Min_Len, Max_Len : Univ_Integer; Actual_Len : optional Univ_Integer) is
      Write_Optional_Int
        (OVS, Actual_Len, Low => Min_Len, High => Max_Len);
   end func Write_Begin_Optional_Seq;

   func Write_End_Seq (var Binary_Output_Value_Stream) is (null);

   func Write_Begin_Map (var OVS : Binary_Output_Value_Stream)
     is (Write_Begin_Optional_Map (OVS, Is_Null => #false));

   func Write_Begin_Optional_Map (var OVS : Binary_Output_Value_Stream;
      Is_Null : Boolean) is
      Write_Int (OVS, (if Is_Null then 1 else 0), Low => 0, High => 1);
   end func Write_Begin_Optional_Map;

   func Write_End_Map (var OVS : Binary_Output_Value_Stream) is
      (Write_Optional_String (OVS, null,
                              Max_Char => Univ_Character::Last(),
                              Min_Len => 1, Max_Len => 100_000));

   func Write_Begin_Poly
     (var OVS : Binary_Output_Value_Stream; Type_Name : Univ_String)
      is (Write_String (OVS, Type_Name,
                        Max_Char => Univ_Character::Last(),
                        Min_Len => 1, Max_Len => 100_000));
   func Write_Begin_Optional_Poly (var OVS : Binary_Output_Value_Stream;
      Type_Name : optional Univ_String)
      is (Write_Optional_String (OVS, Type_Name,
                                 Max_Char => Univ_Character::Last(),
                                 Min_Len => 1, Max_Len => 100_000));
   func Write_End_Poly (var Binary_Output_Value_Stream) is (null);

   func Write_Begin_Obj (var OVS : Binary_Output_Value_Stream)
     is (Write_Begin_Optional_Obj (OVS, Is_Null => #false));
   func Write_Begin_Optional_Obj (var OVS : Binary_Output_Value_Stream;
      Is_Null : Boolean) is
      Write_Int (OVS, (if Is_Null then 1 else 0), Low => 0, High => 1);
   end func Write_Begin_Optional_Obj;

   func Write_End_Obj (var Binary_Output_Value_Stream) is (null);
end class PSL::Core::Binary_Output_Value_Stream;

interface PSL::Core::Binary_Input_Value_Stream<>
  extends PSL::Core::Input_Value_Stream<> is

   func Create(ref var Input_Byte_Stream+) -> Binary_Input_Value_Stream;

   func Is_Self_Describing (Binary_Input_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.
     //  If true, it also requires that the Key of each Key/Value
     //  pair of a Map is required to be a string, and written/read using
     //  {Write,Read}_String.  The actual key could be of any type with
     //  appropriate {To,From}_String routines, but those conversions
     //  must be performed in the higher level code.

   func Reached_End(Binary_Input_Value_Stream) -> Boolean;

   func Read_Int (var IVS : Binary_Input_Value_Stream;
      Low, High : Univ_Integer) -> Val : Univ_Integer
      {Val in Low .. High};

   func Read_Optional_Int
     (var Binary_Input_Value_Stream;
      Low, High : Univ_Integer) -> optional Univ_Integer;

   func Read_Float (var Binary_Input_Value_Stream;
      Digits : Univ_Integer) -> Univ_Float;
   func Read_Optional_Float
     (var Binary_Input_Value_Stream;
      Digits : Univ_Integer) -> optional Univ_Float;

   func Read_String (var Binary_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> Univ_String;
   func Read_Optional_String
     (var Binary_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> optional Univ_String;

   func Read_Begin_Seq (var Binary_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : Univ_Integer;
   func Read_Begin_Optional_Seq (var Binary_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer;

   func More_Seq_Elements (var Binary_Input_Value_Stream) -> Boolean;
   func Read_End_Seq (var Binary_Input_Value_Stream);
   //  Absorb end-of-seq indicator.

   func Read_Begin_Map (var Binary_Input_Value_Stream);
   func Read_Begin_Optional_Map (var Binary_Input_Value_Stream)
     -> Is_Null : Boolean;

   func More_Map_Elements (var Binary_Input_Value_Stream) -> Boolean;
   func Read_Key_Value_Separator (var Binary_Input_Value_Stream);
   func Read_End_Map (var Binary_Input_Value_Stream) -> Syntax_OK : Boolean;
   //  Absorb end-of-map indicator.
   //  Return #false if end-of-map indicator is missing.

   func Read_Begin_Poly (var Binary_Input_Value_Stream)
     -> Type_Name : Univ_String;
   func Read_Begin_Optional_Poly (var Binary_Input_Value_Stream)
     -> Type_Name : optional Univ_String;
   func Read_End_Poly (var Binary_Input_Value_Stream);

   func Read_Begin_Obj (var Binary_Input_Value_Stream);
   func Read_Begin_Optional_Obj (var Binary_Input_Value_Stream)
     -> Is_Null : Boolean;

   func Read_End_Obj (var Binary_Input_Value_Stream);
end interface PSL::Core::Binary_Input_Value_Stream;

class PSL::Core::Binary_Input_Value_Stream is
   ref var Byte_Str : Input_Byte_Stream+;
   var End_Reached : Boolean := #false;
   interface Seq_State<> is
      const Actual_Len : Univ_Integer;
      var Num_Read : Univ_Integer := 0;
   end interface Seq_State;

   var Seq_State_Stack : Stack <Seq_State> := [];

   const Debug : Boolean := #false;

   func Unsigned_64_To_Float (Val : Unsigned_64) -> optional Univ_Float
     is import(#identity);

   func Read_Int_Shared (var IVS : Binary_Input_Value_Stream;
      Low, High : Univ_Integer;
      Is_Optional : Boolean) -> Val : optional Univ_Integer is

      const Num_Bytes :=
        Byte_Stream::Num_Bytes_For_Int (Low, High, Is_Optional);

      const Null_Val := Is_Optional?
                          Byte_Stream::Null_To_Use (Low, High): null;

      if Num_Bytes < 0 then
         //  Use variable-length representation

         //  Read in count of 32-bit digits as a signed 16-bit number
         //  where the sign of the count is the sign of the value.
         const Num_To_Read := Read_Int (IVS, -2**15, 2**15-1);

         //  Now read in little-endian
         Val := 0;

         for (I in 1 .. abs Num_To_Read;
              Mult := 1 then Mult * 2**32) forward loop
            Val += Val + Read_Int (IVS, 0, 2**32-1) * Mult;
         end loop;

         if Num_To_Read < 0 then
            Val := -Val;
         end if;
      else
         //  Use fixed-length representation (either signed or unsigned)
         var Buf : Byte_Stream::Stream_Element_Array :=
           Create(0 ..< Num_Bytes, 0);
         const Bytes_Read := Read (IVS.Byte_Str, Buf);
         if Bytes_Read != Num_Bytes then
            IVS.End_Reached := #true;
         end if;

         if Is_Optional
           and then Null_Val is null
           and then (for all I in Buf.Bounds() =>
                      Buf[I] == Byte_Stream::Null_8_Byte_Arr[I])
         then
            //  Special case of 8-byte null
            return null;
         end if;

         Val := 0;
         for each B of Buf reverse loop
            Val := Val * 2**8 + [[B]];
         end loop;

         if Low < 0 then
            //  Signed value may need to be adjusted
            const Max := 2 ** (8 * Num_Bytes - 1);

            if Val > Max then
               //  Value over Max for signed, so represents a negative value
               Val -= 2*Max;
            end if;
         end if;
      end if;

      if Is_Optional
        and then Null_Val not null
        and then Val == Null_Val
      then
         return null;
      end if;
   end func Read_Int_Shared;

 exports

   func Create(ref var Input_Byte_Stream+) -> Binary_Input_Value_Stream is
     ((Byte_Str => Input_Byte_Stream));

   func Is_Self_Describing (Binary_Input_Value_Stream) -> Boolean is (#false);
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.
     //  If true, it also requires that the Key of each Key/Value
     //  pair of a Map is required to be a string, and written/read using
     //  {Write,Read}_String.  The actual key could be of any type with
     //  appropriate {To,From}_String routines, but those conversions
     //  must be performed in the higher level code.

   func Reached_End(Binary_Input_Value_Stream) -> Boolean
     is (Binary_Input_Value_Stream.End_Reached);

   func Read_Int (var IVS : Binary_Input_Value_Stream;
      Low, High : Univ_Integer) -> Val : Univ_Integer is

      return Read_Int_Shared (IVS, Low, High, Is_Optional => #false);
   end func Read_Int;

   func Read_Optional_Int
     (var IVS : Binary_Input_Value_Stream;
      Low, High : Univ_Integer) -> optional Univ_Integer is

      return Read_Int_Shared (IVS, Low, High, Is_Optional => #true);
   end func Read_Optional_Int;

   func Read_Float (var Binary_Input_Value_Stream;
      Digits : Univ_Integer) -> Univ_Float is
      (Read_Optional_Float (Binary_Input_Value_Stream, Digits));

   func Read_Optional_Float
     (var Binary_Input_Value_Stream;
      Digits : Univ_Integer) -> Result : optional Univ_Float is

      var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 8, 0);

      const Bytes_Read := Read (Binary_Input_Value_Stream.Byte_Str, Arr);
      if Bytes_Read != 8 then
         //  Information was lost
         Binary_Input_Value_Stream.End_Reached := #true;
      end if;

      var Uns_Val : Unsigned_64 := 0;
      for each A of Arr reverse loop
         Uns_Val := (Uns_Val << 8) + [[A]];
         //  Println("A = `(A), Uns_Val = `(Uns_Val)");
      end loop;

      return Unsigned_64_To_Float (Uns_Val);
   end func Read_Optional_Float;

   func Read_String (var IVS : Binary_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> Univ_String is
      return Read_Optional_String (IVS, Max_Char, Min_Len, Max_Len);
   end func Read_String;
      
   func Read_Optional_String
     (var IVS : Binary_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> optional Univ_String is
      const Nul_Ch : Univ_Character := Univ_Character::First();
      const Use_UTF_8 : Boolean := Max_Char - Nul_Ch not in 0x80 .. 0xFF;
      const Use_Len : Boolean := Min_Len != Max_Len or else Max_Len == 0;
      var Len : Univ_Integer := Min_Len;
      var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 1, 0);
      var Arr2 : Byte_Stream::Stream_Element_Array := Create(1 .. 2, 0);
      var Arr3 : Byte_Stream::Stream_Element_Array := Create(1 .. 3, 0);
      var Arr4 : Byte_Stream::Stream_Element_Array := Create(1 .. 4, 0);

      if Use_Len then
         Len := Read_Int(IVS, 0, Max_Len);

         if Len == 0 then
            //  Either an empty string or a null value
            const Indicator := Read_Int (IVS, 0, 0x7F);
            //  An empty string is [0, 0]
            if Indicator == 0 then
               return "";
            else
               {Indicator == 0x7F}
               return null;
            end if;
         end if;
      end if;
      
      var Vec : Vector<Univ_Character> := [];

      for I in 1 .. Len forward loop
         const Bytes_Read := Read(IVS.Byte_Str, Arr);
         var Code : Byte_Stream::Stream_Element := 0;
         var C : Univ_Integer := 0;

         if Bytes_Read != 1 then
            IVS.End_Reached := #true;
         else
            Code := Arr[1];
         end if;

         if Code == 0 and then not Use_Len and then I == 1 then
            //  Read another byte since initial zeroes are doubled when
            //  we aren't using a length.
            Code := Read_Int(IVS, 0, 0xFF);
         end if;

         if Use_UTF_8 then
            case Code of
               [0 .. 0x7F] => 
                  C := Code;

               [0xC0 .. 0xDF] =>
                  const Code2 : Byte_Stream::Stream_Element :=
                    Read_Int(IVS, 0, 0xFF);
                  C := ([[Code and 0x1F]] << 6) + [[Code2 and 0x3F]];

               [0xE0 .. 0xEF] =>
                  const More_Read := Read(IVS.Byte_Str, Arr2);
                  if More_Read != 2 then
                     IVS.End_Reached := #true;
                  end if;
                  C :=
                     ([[Code and 0xF]] << 12) +
                     ([[Arr2[1] and 0x3F]] << 6) +
                      [[Arr2[2] and 0x3F]];

               [0xF0 .. 0xF7] =>
                  const More_Read := Read(IVS.Byte_Str, Arr3);
                  if More_Read != 3 then
                     IVS.End_Reached := #true;
                  end if;
                  C :=
                     ([[Code and 0x7]] << 18) +
                     ([[Arr3[1] and 0x3F]] << 12) +
                     ([[Arr3[2] and 0x3F]] << 6) +
                      [[Arr3[3] and 0x3F]]

                  if Debug then
                     Print
                       ("C = \"`(Nul_Ch + C)\", " |
                        "Code = 0x`(Hex_Image(C)), " |
                        "Arr = [0x`(Hex_Image(Code)), ");
                     for (each A of Arr3; Sep := "" then ", ")
                      forward loop
                        Print(Sep | "0x" | Hex_Image(A));
                     end loop;
                     Println("]");
                  end if;

               [0xF8 .. 0xFB] => // Non standard
                  const More_Read := Read(IVS.Byte_Str, Arr4);
                  if More_Read != 4 then
                     IVS.End_Reached := #true;
                  end if;
                  C :=
                     ([[Code and 0x3]] << 24) +
                     ([[Arr4[1] and 0x3F]] << 18) +
                     ([[Arr4[2] and 0x3F]] << 12) +
                     ([[Arr4[3] and 0x3F]] << 6) +
                      [[Arr4[4] and 0x3F]]

               [..] => //  Not UTF-8
                  IVS.End_Reached := #true;
            end case;
         else
            //  Just give one octet to each character
            C := Code;
         end if;

         const Chr : Univ_Character := Nul_Ch + C;

         {Chr < Max_Char}

         Vec |= Chr;
      end loop

      return From_Vector(Vec);
   end func Read_Optional_String;

   func Read_Begin_Seq (var IVS : Binary_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : Univ_Integer is
      Actual_Len := Read_Int (IVS, Min_Len, Max_Len);
      Push (IVS.Seq_State_Stack, (Actual_Len => Actual_Len));
   end func Read_Begin_Seq;

   func Read_Begin_Optional_Seq (var IVS : Binary_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer is
      Actual_Len := Read_Optional_Int (IVS, Min_Len, Max_Len);
      Push (IVS.Seq_State_Stack,
            (Actual_Len => (if Actual_Len is null then -1 else Actual_Len)));
   end func Read_Begin_Optional_Seq;

   func More_Seq_Elements (var IVS : Binary_Input_Value_Stream) -> Boolean is
      ref State => Top (IVS.Seq_State_Stack);
      return State.Num_Read <= State.Actual_Len;
   end func More_Seq_Elements;

   func Read_End_Seq (var IVS : Binary_Input_Value_Stream) is
      Discard (IVS.Seq_State_Stack);
   end func Read_End_Seq;

   func Read_Begin_Map (var Binary_Input_Value_Stream)
      is (null);  --  TBD
   func Read_Begin_Optional_Map (var Binary_Input_Value_Stream)
     -> Is_Null : Boolean
      is (#false);  --  TBD

   func More_Map_Elements (var Binary_Input_Value_Stream) -> Boolean
      is (#false);  --  TBD
   func Read_Key_Value_Separator (var Binary_Input_Value_Stream) is (null);
   func Read_End_Map (var Binary_Input_Value_Stream) -> Syntax_OK : Boolean
   //  Absorb end-of-map indicator.
   //  Return #false if end-of-map indicator is missing.
      is (#true);  --  TBD

   func Read_Begin_Poly (var IVS : Binary_Input_Value_Stream)
     -> Type_Name : Univ_String
      is (Read_Begin_Optional_Poly (IVS));
   func Read_Begin_Optional_Poly (var IVS : Binary_Input_Value_Stream)
     -> Type_Name : optional Univ_String
      is (Read_Optional_String (IVS,
            Max_Char => Univ_Character::Last(),
            Min_Len => 1, Max_Len => 100_000));

   func Read_End_Poly (var Binary_Input_Value_Stream)
      is (null);

   func Read_Begin_Obj (var IVS : Binary_Input_Value_Stream) is
      const Is_Null := Read_Begin_Optional_Obj (IVS);
      {not Is_Null};
   end func Read_Begin_Obj;

   func Read_Begin_Optional_Obj (var IVS : Binary_Input_Value_Stream)
     -> Is_Null : Boolean is
      return Read_Int (IVS, Low => 0, High => 1) != 0;
   end func Read_Begin_Optional_Obj;

   func Read_End_Obj (var Binary_Input_Value_Stream)
      is (null);
end class PSL::Core::Binary_Input_Value_Stream;

func PSL::Test::Test_Float_Stream() is
   var Buf : Byte_Stream_Buffer := Create (Initial_Size => 50);
   ref var OVS : Binary_Output_Value_Stream => Create(Buf);
   ref var IVS : Binary_Input_Value_Stream => Create(Buf);

   Println ("Testing Read/Write_Optional_Float");

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Float (OVS, null, Digits => 10);
      else
         Write_Optional_Float (OVS, I*1.5, Digits => 10);
      end if;
        
      Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Z := Read_Optional_Float (IVS, Digits => 10);
      if I == 3 then
         if Z not null then
            Println ("Expected null but found `(Z)");
         end if;
      else
         if Z != I*1.5 then
            Println ("Expected `(I*1.5) but found `(Z)");
         end if;
      end if;
      Println
        ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;
   
   Println ("All done");
end func PSL::Test::Test_Float_Stream;

func PSL::Test::Test_String_Stream() is
   var Buf : Byte_Stream_Buffer := Create (Initial_Size => 80);
   ref var OVS : Binary_Output_Value_Stream => Create(Buf);
   ref var IVS : Binary_Input_Value_Stream => Create(Buf);

   const Test_Chr : Univ_Character := '\#1_F7E9#';
     //  A green square

   Println ("Testing Read/Write_Optional_String");

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_String
           (OVS, null, Max_Char => Test_Chr + 2, Min_Len => 0,
            Max_Len => 10);
      elsif I == 5 then
         Println("I = 5 so writing " | From_Vector([Test_Chr]));
         Write_Optional_String
           (OVS, From_Vector([Test_Chr]),
            Max_Char => Test_Chr + 2, Min_Len => 0,
            Max_Len => 10);
      else
         Write_Optional_String
           (OVS, To_String(I**3),
            Max_Char => Test_Chr + 2, Min_Len => 0,
            Max_Len => 10);
      end if;
        
      Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Z := Read_Optional_String (IVS,
            Max_Char => Test_Chr + 2, Min_Len => 0,
            Max_Len => 10);

      if I == 3 then
         if Z not null then
            Println ("Expected null but found `(Z)");
         end if;
      elsif I == 5 then
         if |Z| != 1 or else
           Z[1] != Test_Chr
         then
            Println ("Expected \"`(Test_Chr)\" but found `(Z)");
         end if;
      else
         if Z != To_String(I**3) then
            Println ("Expected `(I**3) but found `(Z)");
         end if;
      end if;
      Println
        ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;
   
   Println ("All done");
end func PSL::Test::Test_String_Stream;

import PSL::Test::Test_Float_Stream, PSL::Test::Test_String_Stream;
func PSL::Test::Test_Value_Stream() is
   var Buf : Byte_Stream_Buffer := Create (Initial_Size => 13);
   ref var Buf_For_Output : Output_Byte_Stream+ => Buf;
   ref var Buf_For_Input : Input_Byte_Stream+ => Buf;
   ref var OVS : Binary_Output_Value_Stream => Create(Buf);
   ref var IVS : Binary_Input_Value_Stream => Create(Buf);

   Println ("Testing Read/Write_Int");

   for I in 1 .. 7 forward loop
      Write_Int (OVS, I**3, Low => 0, High => 1000);
      Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Z := Read_Int (IVS, 0, 1000);
      if Z != I**3 then
         Println ("Expected `(I**3) but found `(Z)");
      end if;
      Println
        ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;
   
   Println ("Testing Read/Write_Optional_Int");

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Int (OVS, null, Low => 0, High => 1000);
      else
         Write_Optional_Int (OVS, I**3, Low => 0, High => 1000);
      end if;
        
      Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Z := Read_Optional_Int (IVS, 0, 1000);
      if I == 3 then
         if Z not null then
            Println ("Expected null but found `(Z)");
         end if;
      else
         if Z != I**3 then
            Println ("Expected `(I**3) but found `(Z)");
         end if;
      end if;
      Println
        ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;
   
   Test_Float_Stream();

   Test_String_Stream();
   
end func PSL::Test::Test_Value_Stream;
func PSL::Test::Test_Object_Stream() is

   var Buf : Byte_Stream_Buffer := Create (Initial_Size => 10000);

   ref var OVS : Binary_Output_Value_Stream => Create(Buf);
   ref var IVS : Binary_Input_Value_Stream => Create(Buf);

   ref var OOS : Output_Object_Stream => Create(OVS);
   ref var IOS : Input_Object_Stream => Create(IVS);

   Println ("Testing Read/Write_Optional_Object");

   
   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Obj (OOS, Univ_Integer::(null));
      else
         Write_Optional_Obj (OOS, I**3);
      end if;
        
      Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      var Z : Univ_Integer;
      Read_Optional_Obj (IOS, Z);
      if I == 3 then
         if Z not null then
            Println ("Expected null but found `(Z)");
         end if;
      else
         if Z != I**3 then
            Println ("Expected `(I**3) but found `(Z)");
         end if;
      end if;
      Println
        ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;
   
   Println ("Testing write sets rather than integers");

   type Int_Set is Set<Integer>;

   func Img(II : Int_Set) -> Univ_String is
      return "[" | (for (I : Integer in II; Sep := "" then ",") =>
                 <""> | Sep | To_String (I)) | "]";
   end func Img;

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Obj (OOS, Int_Set::(null));
      else
         var Test_Set : Int_Set := [for J in 1 .. I => J];

         Write_Optional_Obj (OOS, Test_Set);
      end if;
        
      Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      var Z : Int_Set;
      Read_Optional_Obj (IOS, Z);
      if I == 3 then
         if Z not null then
            Println ("Expected null but found `(Img(Z))");
         end if;
      else
         const Expected : Int_Set := [for J in 1 .. I => J];

         if Z != Expected then
            Println ("Expected `(Img(Expected)) but found `(Img(Z))");
         end if;
      end if;
      Println
        ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;
   Println ("All done");
end func PSL::Test::Test_Object_Stream;

interface PSL::Core::UTF<> is
   const Nul_Ch : Univ_Character := Univ_Character::First();
   const Last_Ch : Univ_Character := Univ_Character::Last();
end interface PSL::Core::UTF;

interface PSL::Core::UTF::Output<> is

   func To_UTF8_Stream (Str : Univ_String)
     -> Byte_Stream::Stream_Element_Array;
   //  Build up UTF8 representation as a vector of stream elements
   //  and then convert to a packed representation.

   func Encode_Str (var OBS : Output_Byte_Stream+; Str : Univ_String)
     -> End_Reached : Boolean;
   //  Write UTF-8 encoding of Str to byte stream.
   //  Return #true if we reach end of stream.

end interface PSL::Core::UTF::Output;

interface PSL::Core::UTF::Input<> is

   func From_UTF8_Stream (Stream : Byte_Stream::Stream_Element_Array)
     -> Univ_String;
   //  Convert UTF-8-encoded Stream into a Univ_String

   func Decode_Char (var IBS : Input_Byte_Stream+)
     -> optional Univ_Character;
   //  Read UTF-8-encoded character from IBS.
   //  Return null if not a valid UTF-8 character or reach end of stream.
end interface PSL::Core::UTF::Input;

class PSL::Core::UTF::Output is
   const Debug := #false;
  exports

   func To_UTF8_Stream (Str : Univ_String)
     -> Result : Byte_Stream::Stream_Element_Array is

      //  Build up UTF8 representation as a vector of stream elements
      //  and then convert to a packed representation.
      var UTF8_Bytes : Vector<Byte_Stream::Stream_Element> := [];

      for each C of Str forward loop
         const Code : Univ_Integer := C - Nul_Ch;

         case Code of
            [0 .. 0x7F] => 
               UTF8_Bytes |= Code;
            [0x80 .. 0x7FF] =>
               UTF8_Bytes |= 0xC0 + (Code >> 6);
               UTF8_Bytes |= 0x80 + (Code and 0x3F);
            [0x800 .. 0xFFFF] =>
               UTF8_Bytes |= 0xE0 + (Code >> 12);
               UTF8_Bytes |= 0x80 + (Code >> 6 and 0x3F);
               UTF8_Bytes |= 0x80 + (Code and 0x3F);
            [0x1_0000 .. 0x1F_FFFF] =>
               UTF8_Bytes |= 0xF0 + (Code >> 18);
               UTF8_Bytes |= 0x80 + (Code >> 12 and 0x3F);
               UTF8_Bytes |= 0x80 + (Code >> 6 and 0x3F);
               UTF8_Bytes |= 0x80 + (Code and 0x3F);
            [..] => //  Nonstandard
               UTF8_Bytes |= 0xF8 + (Code >> 24)
               UTF8_Bytes |= 0x80 + (Code >> 18 and 0x3F)
               UTF8_Bytes |= 0x80 + (Code >> 12 and 0x3F)
               UTF8_Bytes |= 0x80 + (Code >> 6 and 0x3F)
               UTF8_Bytes |= 0x80 + (Code and 0x3F);
         end case;

      end loop

      if Debug then
         Print("Str = \"`(Str)\", ");
         for (each B of UTF8_Bytes;
              Sep := "UTF8 = [" then ", ") forward loop
            Print(Sep | "0x" | Hex_Image(B));
         end loop;
         Println("]");
      end if;

      --  Pack vector into Result
      Result :=
        Create (UTF8_Bytes.Bounds().First .. UTF8_Bytes.Bounds().Last, 0);
      for I in UTF8_Bytes.Bounds() loop
         Set (Result, I, UTF8_Bytes[I]);
      end loop;

   end func To_UTF8_Stream;

   func Encode_Str (var OBS : Output_Byte_Stream+; Str : Univ_String)
     -> End_Reached : Boolean is

      const Arr := To_UTF8_Stream (Str);

      const Bytes_Written := Write (OBS, Arr);

      if Bytes_Written != |Arr| then
         if Debug then
            Println("End Reached: |Arr| = `(|Arr|), " |
                    "Bytes_Written = `(Bytes_Written)");
         end if;
         return #true;
      else
         return #false;
      end if;
   end func Encode_Str;
end class PSL::Core::UTF::Output;

class PSL::Core::UTF::Input is
   const Debug := #false;
  exports
   func From_UTF8_Stream (Stream : Byte_Stream::Stream_Element_Array)
     -> Univ_String is
      //  Convert UTF-8-encoded Stream into a Univ_String
      var Buf : Byte_Stream_Buffer := Create (Stream);
      var Decoded_Vec : Vector<Univ_Character> := [];

      while Buf.Bytes_To_Read() > 0 loop
         const Ch := Decode_Char (Buf);

         if Ch is null then
            //  Not a valid UTF8 character
            {#false}
            exit loop;
         end if;

         Decoded_Vec |= Ch;
      end loop;

      //  Convert vector into Univ_String and return it
      return From_Vector (Decoded_Vec);
   end func From_UTF8_Stream;

   func Decode_Char (var IBS : Input_Byte_Stream+)
     -> optional Univ_Character is
      var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 1, 0);

      const Bytes_Read := Read(IBS, Arr);
      if Bytes_Read != 1 then
         return null;
      end if;

      var C : Univ_Integer;

      const Code := Arr[1];

      case Code of
         [0 .. 0x7F] => 
            C := Code;

         [0xC0 .. 0xDF] =>
            const More_Read := Read(IBS, Arr);
            if More_Read != 1 then
               return null;
            end if;

            const Code2 := Arr[1];
            C := ([[Code and 0x1F]] << 6) + [[Code2 and 0x3F]];

         [0xE0 .. 0xEF] =>
            var Arr2 : Byte_Stream::Stream_Element_Array := Create(1 .. 2, 0);
            const More_Read := Read(IBS, Arr2);
            if More_Read != 2 then
               return null;
            end if;
            C :=
               ([[Code and 0xF]] << 12) +
               ([[Arr2[1] and 0x3F]] << 6) +
                [[Arr2[2] and 0x3F]];

         [0xF0 .. 0xF7] =>
            var Arr3 : Byte_Stream::Stream_Element_Array := Create(1 .. 3, 0);
            const More_Read := Read(IBS, Arr3);
            if More_Read != 3 then
               return null;
            end if;
            C :=
               ([[Code and 0x7]] << 18) +
               ([[Arr3[1] and 0x3F]] << 12) +
               ([[Arr3[2] and 0x3F]] << 6) +
                [[Arr3[3] and 0x3F]]

            if Debug then
               Print
                 ("C = \"`(Nul_Ch + C)\", " |
                  "Code = 0x`(Hex_Image(C)), " |
                  "Arr = [0x`(Hex_Image(Code)), ");
               for (each A of Arr3; Sep := "" then ", ")
                forward loop
                  Print(Sep | "0x" | Hex_Image(A));
               end loop;
               Println("]");
            end if;

         [0xF8 .. 0xFB] => // Non standard
            var Arr4 : Byte_Stream::Stream_Element_Array := Create(1 .. 4, 0);
            const More_Read := Read(IBS, Arr4);
            if More_Read != 4 then
               return null;
            end if;
            C :=
               ([[Code and 0x3]] << 24) +
               ([[Arr4[1] and 0x3F]] << 18) +
               ([[Arr4[2] and 0x3F]] << 12) +
               ([[Arr4[3] and 0x3F]] << 6) +
                [[Arr4[4] and 0x3F]]

         [..] => //  Not UTF-8
            return null;
      end case;
      return Nul_Ch + C;
   end func Decode_Char;
end class PSL::Core::UTF::Input;

func PSL::Test::Test_UTF_Stream() is
   var IO := IO::Get_IO()

   var Out_File : Byte_Stream_Output_File := IO.Create ("test_file");

   Println ("Writing to test_file");

   if UTF::Output::Encode_Str
     (Out_File, "This is a green box: \#1_F7_E9#\n")
   then
      Println ("End reached putting green box");
   elsif UTF::Output::Encode_Str
      (Out_File, "This is a grey box: \#2B_1C#\n")
   then
      Println ("End reached putting grey box");
   elsif UTF::Output::Encode_Str
      (Out_File, "This is a yellow box: \#1_F7_E8#\n")
   then
      Println ("End reached putting yellow box");
   end if;

   Out_File.Close();

   var In_File : Byte_Stream_Input_File := IO.Open ("test_file");

   Println ("Reading from test_file");
   loop
      const C := UTF::Input::Decode_Char(In_File);
      if C is null then
         exit loop;
      end if;
      Print(C);
   end loop;
   In_File.Close();
   
   Println ("All done");
end func PSL::Test::Test_UTF_Stream;

//  Streaming in ParaSail is a three layer cake:
//    Byte Stream is the lowest layer
//    Value Stream is the middle layer
//    Object Stream is the top layer
//
//  This is a JSON-specific Value stream layer.  See *_Value_Stream above
//  for an overview of the purpose of the value stream layer.
//
//  See Input_Value_Stream and Output_Value_Stream for the general interface
//  for a Value stream.  See Binary_{Input,Output}_Value_Stream for an
//  implementation of a binary value stream.

interface PSL::Core::JSON_Value<> is
   //  A ParaSail object that can be used to represent a single
   //  JSON value, or the content of a complete JSON file
   //  (which is defined to be a single JSON value).
   type JSON_Value_Kind is Enum
     <[#Object_Value,
       #Array_Value,
       #String_Value,
       #Number_Value,
       #Boolean_Value,
       #Null_Value]>;

   func Create (Kind : JSON_Value_Kind) -> JSON_Value+;
   //  Create a JSON Value of the given kind

   abstract func Kind (Value : JSON_Value) -> JSON_Value_Kind;

   //  Allow a string literal to produce a JSON String
   op "from_univ"(Lit : Univ_String) -> JSON_Value+
     is (JSON_String_Value::Create(Lit));

   //  Allow a real literal to produce a JSON Number
   op "from_univ"(Lit : Univ_Real) -> JSON_Value+
    is (JSON_Number_Value::Create(Rational::(Lit)));

   //  Allow an int literal to produce a JSON Number
   op "from_univ"(Lit : Univ_Integer) -> JSON_Value+
    is (JSON_Number_Value::Create(Lit));

   //  Use jnull() to produce a JSON null
   func jnull() -> JSON_Value+
     is (JSON_Null_Value::Create());

   //  Allow an array or map aggregate to produce a JSON_Value
   //  ("[]" by itself is interpreted as an empty JSON array).
   op "[]"() -> JSON_Value+;

   //  Allow a [key => value, ...] aggregate to produce a JSON Object
   op "var_indexing" (ref var Val : JSON_Value+; Key : Univ_String) ->
     ref var JSON_Value+;

   //  Allow a [val, val, ...] aggregate to produce a JSON Array
   op "<|=" (var Val : JSON_Value+; var Elem : optional JSON_Value+);

   //  Allow indexing by a String key
   op "indexing"(ref Val : JSON_Value+; Key : Univ_String)
     -> ref JSON_Value+;

   //  Produce set of keys (presuming is a JSON Object)
   op "index_set"(Val : JSON_Value+) -> Ordered_Set<Univ_String>;

   //  Allow indexing by an integer, presuming is a JSON Array
   func Nth(ref Val : JSON_Value+; Key : Univ_Integer)
     -> ref JSON_Value+;

   //  Produce bounds of array (presuming is a JSON Array)
   func Bounds(Val : JSON_Value+) -> Countable_Range<Univ_Integer>;

   //  Provide general To/From_String operations
   func To_String (Val : JSON_Value+) -> Univ_String;
   func From_String (Str : Univ_String) -> JSON_Value+;
end interface PSL::Core::JSON_Value;

interface PSL::Core::JSON_Object_Value<> extends JSON_Value is
   //  A JSON_Object_Value can be used to represent a "JSON Object"
   //  which in ParaSail parlance is a Map with Keys that are Strings,
   //  and Values that are JSON Values.
   var Value : Ordered_Map<Univ_String, JSON_Value+> := [];

   func Create (Value : Ordered_Map <Univ_String, JSON_Value+> := [])
     -> JSON_Object_Value is ((Value => Value));

   func Kind (Value : JSON_Object_Value) -> JSON_Value_Kind
     is (#Object_Value);
end interface PSL::Core::JSON_Object_Value;

interface PSL::Core::JSON_Array_Value<> extends JSON_Value is
   //  A JSON_Array_Value can be used to represent a "JSON Array"
   //  which in ParaSail parlance is a Vector of JSON Values.
   var Value : Vector<JSON_Value+> := [];

   func Create (Value : Vector <JSON_Value+> := [])
     -> JSON_Array_Value is ((Value => Value));

   func Kind (Value : JSON_Array_Value) -> JSON_Value_Kind
     is (#Array_Value);
end interface PSL::Core::JSON_Array_Value;

interface PSL::Core::JSON_String_Value<> extends JSON_Value is
   //  A JSON_String_Value can be used to represent a "JSON String"
   //  which is equivalent to the ParaSail Univ_String.
   const Value : Univ_String;

   func Create (Value : Univ_String := "")
     -> JSON_String_Value is ((Value => Value));

   func Kind (Value : JSON_String_Value) -> JSON_Value_Kind
     is (#String_Value);

   op "from_univ"(Lit : Univ_String) -> JSON_String_Value
     is ((Value => Lit));
end interface PSL::Core::JSON_String_Value;

interface PSL::Core::JSON_Number_Value<> extends JSON_Value is
   //  A JSON_Number_Value can be used to represent a "JSON Number"
   //  which is equivalent to the ParaSail big-number Rational.
   const Value : Rational;

   func Is_Integer (Number : JSON_Number_Value) -> Boolean
     is (Number.Value.Den() == 1);

   func Create (Value : Rational := 0.0)
     -> JSON_Number_Value is ((Value => Value));

   func Create (Value : Univ_Integer)
     -> JSON_Number_Value is ((Value => Int_To_Rational (Value)));

   func Kind (Value : JSON_Number_Value) -> JSON_Value_Kind
     is (#Number_Value);

   op "from_univ"(Lit : Univ_Integer) -> JSON_Number_Value
     is (Create (Lit));

   op "from_univ"(Lit : Univ_Real) -> JSON_Number_Value
     is ((Value => Rational::(Lit)));
end interface PSL::Core::JSON_Number_Value;

interface PSL::Core::JSON_Boolean_Value<> extends JSON_Value is
   //  A JSON_Boolean_Value can be used to represent a "JSON Boolean"
   //  which is equivalent to the ParaSail type Boolean.
   const Value : Boolean;

   func Create (Value : Boolean := #false)
     -> JSON_Boolean_Value is ((Value => Value));

   func Kind (Value : JSON_Boolean_Value) -> JSON_Value_Kind
     is (#Boolean_Value);

   func false () -> JSON_Boolean_Value
     is ((Value => #false));

   func true () -> JSON_Boolean_Value
     is ((Value => #true));
end interface PSL::Core::JSON_Boolean_Value;

interface PSL::Core::JSON_Null_Value<> extends JSON_Value is
   //  A JSON_Null_Value can be used to represent a "JSON null"
   //  which is a type that has only one value, namely "null".
   //  It is usually combined with other JSON types as one
   //  alternative to indicate a lack of data.
   type Unit is Enum<[#Null_Value]>;
   const Value : Unit;

   func Create ()
     -> JSON_Null_Value is (JSON_Null_Value::(Value => #Null_Value))

   func Kind (Value : JSON_Null_Value) -> JSON_Value_Kind
     is (#Null_Value);
end interface PSL::Core::JSON_Null_Value;

class PSL::Core::JSON_Value is

   const Debug : Boolean := #false;

 exports

   func Create (Kind : JSON_Value_Kind) -> JSON_Value+ is
   //  Create a JSON Value of the given kind
      case Kind of
       [#Object_Value] =>
         return JSON_Object_Value::Create();
       [#Array_Value] =>
         return JSON_Array_Value::Create();
       [#String_Value] =>
         return JSON_String_Value::Create();
       [#Number_Value] =>
         return JSON_Number_Value::Create();
       [#Boolean_Value] =>
         return JSON_Boolean_Value::Create();
       [#Null_Value] =>
         return JSON_Null_Value::Create();
      end case;
   end func Create;

   //  Allow an array or map aggregate to produce a JSON_Value
   //  ("[]" by itself is interpreted as an empty JSON array).
   op "[]"() -> JSON_Value+
     is (JSON_Array_Value::Create());

   //  Allow a [key => value, ...] aggregate to produce a JSON Object
   op "var_indexing" (ref var Val : JSON_Value+; Key : Univ_String) ->
     ref var JSON_Value+ is
      loop
         case Val of
          [Obj : JSON_Object_Value] =>
            //  Val is already a JSON Object
            if Debug then
               Println("Adding \"`(Key)\" to JSON Object");
            end if;
               
            return Obj.Value[Key];

          [Arr : JSON_Array_Value] =>
            //  Convert (empty) JSON Array into JSON Object
            {|Arr.Value| == 0}

            if Debug then
               Println("Converting from empty JSON array to JSON object");
            end if;
               
            Val := JSON_Object_Value::Create();

            //  Now re-do the case statement
            continue loop;

          [X : JSON_Value+] =>
            //  Must be either a JSON Array or Object when called
            {#false}
            exit loop;
         end case;
      end loop;
   end op "var_indexing";

   //  Allow a [val, val, ...] aggregate to produce a JSON Array
   op "<|=" (var Val : JSON_Value+; var Elem : optional JSON_Value+) is
      case Val of
       [Arr : JSON_Array_Value] =>
         if Debug then
            Println("Adding element to JSON Array of length `(|Arr.Value|)");
         end if;
         Arr.Value <|= Elem;

       [X : JSON_Value+] =>
         //  Must be a JSON Array
         {#false}
         null;
      end case;
   end op "<|=";

   //  Allow indexing by a String key
   op "indexing"(ref Val : JSON_Value+; Key : Univ_String)
     -> ref JSON_Value+ is
      case Val of
       [Obj : JSON_Object_Value] =>
         return Obj.Value[Key];
       [X : JSON_Value+] =>
         {#false}
      end case;
   end op "indexing";

   //  Produce set of keys
   op "index_set"(Val : JSON_Value+) -> Ordered_Set<Univ_String> is
      case Val of
       [Obj : JSON_Object_Value] =>
         return Obj.Value.Keys();
       [X : JSON_Value+] =>
         return [];
      end case;
   end op "index_set";
   
   //  Allow indexing by an integer, presuming is a JSON Array
   func Nth(ref Val : JSON_Value+; Key : Univ_Integer)
     -> ref JSON_Value+ is
      case Val of
       [Arr : JSON_Array_Value] =>
         return Arr.Value[Key];
       [X : JSON_Value+] =>
         {#false}
      end case;
   end func Nth;

   //  Produce bounds of array
   func Bounds(Val : JSON_Value+) -> Countable_Range<Univ_Integer> is
      case Val of
       [Arr : JSON_Array_Value] =>
         return Arr.Value.Bounds();
       [X : JSON_Value+] =>
         return 1 .. 0;
      end case;
   end func Bounds;
   
   //  Provide general To_String operation
   func To_String (Val : JSON_Value+) -> Univ_String is
      var B_Strm : Byte_Stream_Buffer := Create();
      ref var JVS : JSON_Output_Value_Stream => Create(B_Strm);

      Write_JSON_Value (JVS, Val);

      //  Read everything in the stream
      return UTF::Input::From_UTF8_Stream (Read_Remainder(B_Strm));
   end func To_String;

   func From_String (Str : Univ_String) -> JSON_Value+ is
      var B_Strm : Byte_Stream_Buffer :=
         Create(UTF::Output::To_UTF8_Stream(Str));
      ref var JVS : JSON_Input_Value_Stream => Create(B_Strm);

      return Read_JSON_Value (JVS);
   end func From_String;
end class PSL::Core::JSON_Value;

interface PSL::Core::JSON_Output_Value_Stream<>
  extends PSL::Core::Output_Value_Stream<> is
   //  This kind of value stream is used for output of ParaSail values
   //  in JSON format, given a byte stream of some sort.

   func Create(ref var Output_Byte_Stream+) -> JSON_Output_Value_Stream;

   func Is_Self_Describing (JSON_Output_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Output_Value_Stream) -> Boolean;

   func Write_Int (var JSON_Output_Value_Stream; Val : Univ_Integer;
      Low, High : Univ_Integer) {Val in Low .. High};
   func Write_Optional_Int
     (var JSON_Output_Value_Stream; Val : optional Univ_Integer;
      Low, High : Univ_Integer);

   func Write_Float (var JSON_Output_Value_Stream; Val : Univ_Float;
      Digits : Univ_Integer);
   func Write_Optional_Float
     (var JSON_Output_Value_Stream; Val : optional Univ_Float;
      Digits : Univ_Integer);

   func Write_Rational (var JSON_Output_Value_Stream; Val : Rational;
      Digits : Univ_Integer);
   func Write_Optional_Rational
     (var JSON_Output_Value_Stream; Val : optional Rational;
      Digits : Univ_Integer);

   func Write_String (var JSON_Output_Value_Stream; Val : Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
      {Min_Len >= 0 and then |Val| in Min_Len .. Max_Len};
   func Write_Optional_String
     (var JSON_Output_Value_Stream; Val : optional Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer);

   func Write_Begin_Seq (var JSON_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer);
   func Write_Begin_Optional_Seq (var JSON_Output_Value_Stream;
      Min_Len, Max_Len : Univ_Integer; Actual_Len : optional Univ_Integer);

   func Write_End_Seq (var JSON_Output_Value_Stream);

   func Write_Begin_Map (var JSON_Output_Value_Stream);
   func Write_Begin_Optional_Map (var JSON_Output_Value_Stream;
      Is_Null : Boolean);

   func Write_End_Map (var JSON_Output_Value_Stream);

   func Write_Begin_Poly
     (var JSON_Output_Value_Stream; Type_Name : Univ_String);
   func Write_Begin_Optional_Poly (var JSON_Output_Value_Stream;
      Type_Name : optional Univ_String);
   func Write_End_Poly (var JSON_Output_Value_Stream);

   func Write_Begin_Obj (var JSON_Output_Value_Stream);
   func Write_Begin_Optional_Obj (var JSON_Output_Value_Stream;
      Is_Null : Boolean);
   func Write_End_Obj (var JSON_Output_Value_Stream);

   func Write_JSON_Value (var JSON_Output_Value_Stream; Value : JSON_Value+);
   //  Write a JSON value to the stream

   func Write_Newline (var JSON_Output_Value_Stream);
   //  Write out a newline to the stream
end interface PSL::Core::JSON_Output_Value_Stream;

class PSL::Core::JSON_Output_Value_Stream is
   ref var Byte_Str : Output_Byte_Stream+;
   var End_Reached : Boolean := #false;
   type JSON_Output_State is Enum
     <[#Initial, #Expecting_First_Seq_Elem, #Expecting_Seq_Elem,
       #Expecting_First_Map_Key, #Expecting_Map_Key, #Expecting_Map_Value]>;
   var State_Stack : Stack<JSON_Output_State> := [#Initial];
   var Indent := 0;
   const Indent_Inc := 2;  --  Indent by 2 each level of nesting

   const Debug : Boolean := #false;

   func Write_UTF8 (var OVS : JSON_Output_Value_Stream; Str : Univ_String) is
      //  Convert Univ_String to UTF8 and then write to OVS.
      //  Set OVS.End_Reached as appropriate.
      const End_Reached := UTF::Output::Encode_Str (OVS.Byte_Str, Str);

      if End_Reached then
         if Debug then
            Println("End Reached while UTF-8 encoding `(Str)");
         end if;
         OVS.End_Reached := #true;
      end if;
   end func Write_UTF8;

   func Start_Item (var OVS : JSON_Output_Value_Stream) is
      //  Emit extra JSON syntax according to current state
      case OVS.State_Stack.Top() of
       [#Initial] =>
         //  Should probably only start an object in this state.
         null;

       [#Expecting_First_Seq_Elem] =>
         //  We have seen a Begin_Seq and have emitted a '['
         //  Start a new line at the appropriate indent.
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

         //  Switch into a state where we should emit a comma before the
         //  emitting the newline.
         OVS.State_Stack.Top() := #Expecting_Seq_Elem;

       [#Expecting_Seq_Elem] =>
         //  We have emitted at least one element of a sequence.
         //  Emit a comma and then start a new line at the correct indent.
         Write_UTF8 (OVS, ",\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

       [#Expecting_First_Map_Key] =>
         //  We have seen a Begin_Map and have emitted a '{'
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

         //  Switch into a state where we should emit a colon before the
         //  value
         OVS.State_Stack.Top() := #Expecting_Map_Value;

       [#Expecting_Map_Key] =>
         //  We have seen a map value, so this must be a key;
         //  emit a ',' a newline, and an indent
         Write_UTF8 (OVS, ",\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

         //  Switch back into Expecting_Map_Value,
         //  since we are expecting a value
         OVS.State_Stack.Top() := #Expecting_Map_Value;

       [#Expecting_Map_Value] =>
         //  We have seen a map key, emit a ':' and a space
         Write_UTF8 (OVS, ": ");

         //  Switch into a state where we should emit a comma and a newline
         //  before the next key/value pair.
         OVS.State_Stack.Top() := #Expecting_Map_Key;

      end case;
   end func Start_Item;

   func End_Item (var OVS : JSON_Output_Value_Stream) is
      //  Emit new line if back to #Initial state
      if OVS.State_Stack.Top() == #Initial then
         Write_UTF8 (OVS, "\n");
      end if;
   end func End_Item;

   func Write_Begin_JSON_Array (var OVS: JSON_Output_Value_Stream) is
      OVS.Indent += Indent_Inc;
      Push (OVS.State_Stack, #Expecting_First_Seq_Elem);

      Write_UTF8 (OVS, "[");
   end func Write_Begin_JSON_Array;

   func Write_End_JSON_Array (var OVS: JSON_Output_Value_Stream) is
      OVS.Indent -= Indent_Inc;

      //  Pop the state stack
      const Old_State : JSON_Output_State := OVS.State_Stack.Pop();

      case Old_State of
       [#Expecting_First_Seq_Elem] =>
         //  We have seen a Begin_JSON_Array and have emitted a '['
         //  This must be an empty array.
         Write_UTF8 (OVS, "]");
         End_Item (OVS);

       [#Expecting_Seq_Elem] =>
         //  We have emitted at least one element of a sequence.
         //  Start a new line and write the closing ']' with indent.
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');
         Write_UTF8 (OVS, "]");
         End_Item (OVS);

       [#Initial |
        #Expecting_First_Map_Key |
        #Expecting_Map_Key |
        #Expecting_Map_Value] =>
         //  Not expected!
         if Debug then
            Println ("Expected state of #Expecting_First_Seq_Elem or " |
                     "#Expecting_Seq_Elem, found `(Old_State)");
         end if;

         {#false}
      end case;
   end func Write_End_JSON_Array;

   func Escape_Chars_In_Str (Str : Univ_String) -> Univ_String is
   //  Prefix any special characters that appear in Str so they are acceptable
   //  as a JSON string.
      var Escaped_Part : Vector<Univ_Character> := [];
      var Unescaped := 0;

      for I in 1 .. |Str| forward loop
         const C := Str[I];
         const Code := C - UTF::Nul_Ch;

         case (Code) of
          [0 .. 0x1F | 0x102000 .. (UTF::Last_Ch - UTF::Nul_Ch)] =>
            //  Figure out the letter to use with '\'
            var Letter : optional Univ_Character := null;

            case C of
             ['\b'] => Letter := 'b';
             ['\f'] => Letter := 'f';
             ['\n'] => Letter := 'n';
             ['\r'] => Letter := 'r';
             ['\t'] => Letter := 't';
             [..]   => Letter := 'u';
            end case;

            Escaped_Part |= '\\';
            Escaped_Part |= Letter;
            if Letter == 'u' then
               //  4 hex-digit unicode
               for Divisor := 16**3 then Divisor / 16 while Divisor > 0 loop
                  const Digit := (Code / Divisor) mod 16;

                  //  Append the correct hex digit
                  if Digit < 10 then
                     Escaped_Part |= Digit + '0';
                  else
                     Escaped_Part |= (Digit - 10) + 'A';
                  end if;
               end loop;
            end if;

          ['"' - UTF::Nul_Ch | '\\' - UTF::Nul_Ch] =>
             //  A simple escape
             Escaped_Part |= '\\';
             Escaped_Part |= C;

          [..] =>
            //  No escape
            if |Escaped_Part| > 0 then
               Escaped_Part |= C;
            else
               //  Have not seen a character needing an escape
               Unescaped := I;
            end if;
         end case;
      end loop;
      if |Escaped_Part| == 0 then
         //  Nothing needed escaping
         return Str;
      else
         //  Combine unescaped part with escaped part
         return Str[1 .. Unescaped] | From_Vector (Escaped_Part);
      end if;
   end func Escape_Chars_In_Str;

 exports

   func Create(ref var Output_Byte_Stream+) -> JSON_Output_Value_Stream is
     ((Byte_Str => Output_Byte_Stream));

   func Is_Self_Describing (JSON_Output_Value_Stream) -> Boolean is
     (#true);
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Output_Value_Stream) -> Boolean is
     (JSON_Output_Value_Stream.End_Reached);

   func Write_Int (var OVS: JSON_Output_Value_Stream; Val : Univ_Integer;
      Low, High : Univ_Integer) is

      {Val not null}
      Write_Optional_Int (OVS, Val, Low, High);
   end func Write_Int;

   func Write_Optional_Int
     (var OVS : JSON_Output_Value_Stream; Val : optional Univ_Integer;
      Low, High : Univ_Integer) is

      Start_Item (OVS);

      if Debug then
         Println
           ("JSON Write_(Optional_)Int, Low = `(Low), High = `(High)" |
            ", Val = `(Val)");
      end if;

      const Str := (if Val is null then "null" else To_String (Val));
      Write_UTF8 (OVS, Str);
      End_Item (OVS);
   end func Write_Optional_Int;

   func Write_Float (var OVS: JSON_Output_Value_Stream; Val : Univ_Float;
      Digits : Univ_Integer) is
      //  Just pass the buck to the optional one
      Write_Optional_Float (OVS, Val, Digits);
   end func Write_Float;

   func Write_Optional_Float
     (var OVS : JSON_Output_Value_Stream; Val : optional Univ_Float;
      Digits : Univ_Integer) is

      Start_Item(OVS);

      if Debug then
         Println
           ("JSON Write_Optional_Float, Digits = `(Digits)" |
            ", Val = `(Val)");
      end if;

      const Str := (if Val is null then "null" else To_String (Val));
      Write_UTF8 (OVS, Str);
      End_Item (OVS);
   end func Write_Optional_Float;

   func Write_Rational (var OVS : JSON_Output_Value_Stream; Val : Rational;
      Digits : Univ_Integer) is
      Write_Optional_Rational (OVS, Val, Digits);
   end func Write_Rational;

   func Write_Optional_Rational
     (var OVS : JSON_Output_Value_Stream; Val : optional Rational;
      Digits : Univ_Integer) is

      Start_Item(OVS);

      if Debug then
         Println
           ("JSON Write_Optional_Rational, Digits = `(Digits)" |
            ", Val = `(Val)");
      end if;

      const Str := (if Val is null then "null" else To_String (Val));
      Write_UTF8 (OVS, Str);
      End_Item (OVS);
   end func Write_Optional_Rational;

   func Write_String (var OVS : JSON_Output_Value_Stream; Val : Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer) is
      //  Use UTF-8
      
      {Val not null}
      //  Pass the buck
      Write_Optional_String (OVS, Val, Max_Char, Min_Len, Max_Len);
   end func Write_String;

   func Write_Optional_String
     (var OVS : JSON_Output_Value_Stream; Val : optional Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer) is
      //  Write a string surrounded by double quotes, or just the word null.

      Start_Item (OVS);

      const Str :=
        (if Val is null then "null"
         else '"' | Escape_Chars_In_Str (Val) | '"');

      Write_UTF8 (OVS, Str);
      End_Item (OVS);
   end func Write_Optional_String;

   func Write_Begin_Seq (var OVS : JSON_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer) is

      {Actual_Len not null}
      //  Just pass the buck to the "optional" version
      Write_Begin_Optional_Seq (OVS, Min_Len, Max_Len, Actual_Len);
   end func Write_Begin_Seq;
    
   func Write_Begin_Optional_Seq (var OVS : JSON_Output_Value_Stream;
      Min_Len, Max_Len : Univ_Integer; Actual_Len : optional Univ_Integer) is

      Start_Item (OVS);

      if Actual_Len is null then
         Write_UTF8 (OVS, "null");
      else
         Write_Begin_JSON_Array (OVS);
      end if;
   end func Write_Begin_Optional_Seq;

   func Write_End_Seq (var OVS : JSON_Output_Value_Stream) is
      //  Emit "]" optionally preceded by a newline
      //  Pop the state stack and reduce the indent

      Write_End_JSON_Array (OVS);
   end func Write_End_Seq;

   func Write_Begin_Map (var OVS : JSON_Output_Value_Stream) is
      //  Just pass the buck to the "optional" version
      Write_Begin_Optional_Map (OVS, Is_Null => #false);
   end func Write_Begin_Map;

   func Write_Begin_Optional_Map (var OVS : JSON_Output_Value_Stream;
      Is_Null : Boolean) is

      Start_Item (OVS);

      if Is_Null then
         Write_UTF8 (OVS, "null");
      else
         OVS.Indent += Indent_Inc;
         Push (OVS.State_Stack, #Expecting_First_Map_Key);

         Write_UTF8 (OVS, "{");
      end if;
   end func Write_Begin_Optional_Map;

   func Write_End_Map (var OVS : JSON_Output_Value_Stream) is
      //  Emit "}" optionally preceded by a newline
      //  Pop the state stack and reduce the indent

      OVS.Indent -= Indent_Inc;

      //  Pop the state stack
      const Old_State : JSON_Output_State := OVS.State_Stack.Pop();

      case Old_State of
       [#Expecting_First_Map_Key] =>
         //  We have seen a Begin_Map and have emitted a '{'
         //  This must be an empty object.
         Write_UTF8 (OVS, "}");

       [#Expecting_Map_Key] =>
         //  We have emitted at least one key/value pair.
         //  Start a new line and write the closing '}' with indent.
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');
         Write_UTF8 (OVS, "}");

       [#Initial |
        #Expecting_First_Seq_Elem |
        #Expecting_Seq_Elem |
        #Expecting_Map_Value] =>
         //  Not expected!
         if Debug then
            Println ("Expected state of #Expecting_First_Map_Key or " |
                     "#Expecting_Map_Key, found `(Old_State)");
         end if;

         {#false}
      end case;
   end func Write_End_Map;

   func Write_Begin_Poly
     (var OVS : JSON_Output_Value_Stream; Type_Name : Univ_String)
      is (Write_Begin_Optional_Poly (OVS, Type_Name));

   func Write_Begin_Optional_Poly (var OVS : JSON_Output_Value_Stream;
      Type_Name : optional Univ_String) is
      Write_Begin_Optional_Map (OVS, Is_Null => Type_Name is null);
      if Type_Name not null then
         Write_String (OVS, Type_Name,
                       Max_Char => Univ_Character::Last(),
                       Min_Len => 1, Max_Len => 100_000);
      end if;
   end func Write_Begin_Optional_Poly;

   func Write_End_Poly (var OVS : JSON_Output_Value_Stream)
     is (Write_End_Map (OVS));

   func Write_Begin_Obj (var OVS : JSON_Output_Value_Stream) is
      //  Just pass the buck to the "optional" version
      Write_Begin_Optional_Obj (OVS, Is_Null => #false);
   end func Write_Begin_Obj;

   func Write_Begin_Optional_Obj (var OVS : JSON_Output_Value_Stream;
      Is_Null : Boolean) is
      //  Treat an "object" as a sequence of components
      //  Preferred would be a set of key/value pairs

      Start_Item (OVS);

      if Is_Null then
         Write_UTF8 (OVS, "null");
      else
         Write_Begin_JSON_Array (OVS);
      end if;
   end func Write_Begin_Optional_Obj;

   func Write_End_Obj (var OVS : JSON_Output_Value_Stream) is
      //  Emit "]" optionally preceded by a newline
      //  Pop the state stack and reduce the indent

      Write_End_JSON_Array (OVS);
   end func Write_End_Obj;

   func Write_JSON_Value
     (var OVS : JSON_Output_Value_Stream; Value : JSON_Value+) is
   //  Write a JSON value to the stream
      {Value not null}
      case Value of
       [Obj : JSON_Object_Value] =>
         Write_Begin_Map (OVS);
         for each [Key => Val] of Obj.Value forward loop
            Write_String (OVS, Key, Univ_Character::Last(),
              Min_Len => 0, Max_Len => |Key|);
            Write_JSON_Value (OVS, Val);
         end loop;
         Write_End_Map (OVS);

       [Arr : JSON_Array_Value] =>
         Write_Begin_Seq (OVS,
           Min_Len => 0, Max_Len => |Arr.Value|, Actual_Len => |Arr.Value|);
         for each Elem of Arr.Value forward loop
            Write_JSON_Value (OVS, Elem);
         end loop;
         Write_End_Seq (OVS);

       [Str : JSON_String_Value] =>
         Write_String (OVS, Str.Value, Univ_Character::Last(),
           Min_Len => 0, Max_Len => |Str.Value|);

       [Num : JSON_Number_Value] =>
         Write_Rational (OVS, Num.Value, Digits => 1000);

       [Bool : JSON_Boolean_Value] =>
         Start_Item (OVS);
         Write_UTF8 (OVS, (if Bool.Value then "true" else "false"));
         End_Item (OVS);

       [JSON_Null : JSON_Null_Value] =>
         Start_Item (OVS);
         Write_UTF8 (OVS, "null");
         End_Item (OVS);
      end case;

   end func Write_JSON_Value;

   func Write_Newline (var OVS : JSON_Output_Value_Stream) is
   //  Write out a newline to the stream
      Write_UTF8 (OVS, "\n");
   end func Write_Newline;
end class PSL::Core::JSON_Output_Value_Stream;

interface PSL::Core::JSON_Input_Value_Stream<>
  extends PSL::Core::Input_Value_Stream<> is
   //  This kind of value stream is used for reading a ParaSail value
   //  from a byte stream in JSON format.

   func Create(ref var Input_Byte_Stream+) -> JSON_Input_Value_Stream;

   func Is_Self_Describing (JSON_Input_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Input_Value_Stream) -> Boolean;

   func Read_Int (var IVS : JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> Val : Univ_Integer
      {Val in Low .. High};

   func Read_Optional_Int
     (var JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> optional Univ_Integer;

   func Read_Float (var JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> Univ_Float;
   func Read_Optional_Float
     (var JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> optional Univ_Float;

   func Read_Rational (var JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> Rational;
   func Read_Optional_Rational
     (var JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> optional Rational;

   func Read_String (var JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> Univ_String;
   func Read_Optional_String
     (var JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> optional Univ_String;

   func Read_Begin_Seq (var JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : Univ_Integer;
   func Read_Begin_Optional_Seq (var JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer;

   func More_Seq_Elements (var JSON_Input_Value_Stream) -> Boolean;
   //  Return #true if there are more sequence elements, and
   //  absorb the comma separator (except for first element which
   //  isn't preceded by one.

   func Read_End_Seq (var JSON_Input_Value_Stream);
   //  Absorb end-of-seq indicator.

   func Read_Begin_Map (var JSON_Input_Value_Stream);
   func Read_Begin_Optional_Map (var JSON_Input_Value_Stream)
     -> Is_Null : Boolean;

   func More_Map_Elements (var JSON_Input_Value_Stream) -> Boolean;
   //  Return #true if there are more map elements, and
   //  absorb the comma separator (except for first element which
   //  isn't preceded by one).

   func Read_Key_Value_Separator (var JSON_Input_Value_Stream);
   //  Skip over the ':' in a Key/Value pair of a map

   func Read_End_Map (var JSON_Input_Value_Stream) -> Syntax_OK : Boolean;
   //  Absorb end-of-map indicator.
   //  Return #false if end-of-map indicator is missing.

   func Read_Begin_Poly (var JSON_Input_Value_Stream)
     -> Type_Name : Univ_String;
   func Read_Begin_Optional_Poly (var JSON_Input_Value_Stream)
     -> Type_Name : optional Univ_String;
   func Read_End_Poly (var JSON_Input_Value_Stream);

   func Read_Begin_Obj (var JSON_Input_Value_Stream);
   func Read_Begin_Optional_Obj (var JSON_Input_Value_Stream)
     -> Is_Null : Boolean;

   func Read_End_Obj (var JSON_Input_Value_Stream);

   func Read_JSON_Value
     (var IVS : JSON_Input_Value_Stream)
     -> optional JSON_Value+;
   //  Read one JSON value from the JSON-formatted byte stream.
   //  Return null if not good JSON syntax.

   func JSON_Syntax_Error
     (IVS : JSON_Input_Value_Stream; Err : Univ_String := "JSON syntax error");
   //  Give an error message, and indicate line and character
end interface PSL::Core::JSON_Input_Value_Stream;

class PSL::Core::JSON_Input_Value_Stream is
   ref var Byte_Str : Input_Byte_Stream+;
   var Peek_Char : optional Univ_Character := null;
   var End_Reached : Boolean := #false;
   var Source_Line : Integer<0 .. 100_000> := 1;
   var Source_Char : Integer<0 .. 10_000> := 1;

   const Debug : Boolean := #false;

   func Next (var IVS : JSON_Input_Value_Stream) is
      //  Get next decoded character from byte stream
      //  Keep track of line and char within line
      IVS.Peek_Char := UTF::Input::Decode_Char (IVS.Byte_Str);

      if IVS.Peek_Char is null then
         //  Reached end of file
         null;
      elsif IVS.Peek_Char == '\n' then
         IVS.Source_Line += 1;
         IVS.Source_Char := 0;
      else
         IVS.Source_Char += 1;
      end if;
   end func Next;

   func Scan_JSON_Token
     (var IVS : JSON_Input_Value_Stream; Ignore_Comma : Boolean := #false)
     -> optional Univ_String is
      //  Read in one token from input stream, decoding it into a Univ_String
      //  Ignore white space.
      //  IVS.Peek_Char provides a one-character peek-ahead when non-null.
      //  Return null at end of stream

      ref Peek => IVS.Peek_Char;

      func Decode_Hex_Digit (X : optional Univ_Character)
        -> optional Univ_Integer is
         //  Return value in range 0..15 or null, based on hex digit
         if X is null then
            return null;
         end if;
         case X of
          ['0'..'9'] =>
            return X - '0';
          ['a'..'f'] =>
            return X - 'a' + 10;
          ['A'..'F'] =>
            return X - 'A' + 10;
          [..] =>
            return null;
         end case;
      end func Decode_Hex_Digit;

      func Scan_Number () -> optional Univ_String is
      //  Scan a number, append to Result_Vec
      //  Presume IVS.Peek is initialized to first char of number
      //  (either '0'..'9' or '-').
         
         var Result_Vec : Vector<Univ_Character> := [];

         func Scan_Int () -> Boolean is
         //  Scan an integer, append to Result_Vec
         //  Presume IVS.Peek is initialized to first char of number
         //  or null.  Return #true if OK syntax, #false if not
            if Peek is null then
               IVS.Next();
               if Peek is null then
                  IVS.JSON_Syntax_Error ("EOF while reading an integer");
                  return #false;
               end if;
            end if;
            if Peek not in '0' .. '9' then
               IVS.JSON_Syntax_Error ("Expecting a digit");
               return #false;
            end if;
            while Peek in '0' .. '9' loop
               Result_Vec |= Peek;
               IVS.Next();
            end loop;
            // Syntax OK!
            return #true;
         end func Scan_Int;

         if Peek == '-' then
            //  Negative number
            Result_Vec |= Peek;
            IVS.Next();
         end if;

         if not Scan_Int () then
            //  Syntax error
            return null;
         end if;

         if Peek not null and then Peek == '.' then
            //  Fraction part
            Result_Vec |= Peek;
            Peek := null;
            if not Scan_Int () then
               //  Syntax error
               return null;
            end if;
         end if;

         if Peek not null and then Peek in 'e' | 'E' then
            //  Exponent part [E|e][+|-|]<int>
            Result_Vec |= Peek;
            IVS.Next();
            if Peek is null then
               //  Syntax error
               IVS.JSON_Syntax_Error ("EOF while reading an exponent");
               return null;
            end if;
            if Peek in '+' | '-' then
               Result_Vec |= Peek;
               IVS.Next();
               if Peek is null then
                  //  Syntax error
                  IVS.JSON_Syntax_Error ("EOF while reading an exponent");
                  return null;
               end if;
            end if;
            if not Scan_Int () then
               //  Syntax error
               return null;
            end if;
         end if;

         return From_Vector (Result_Vec);
      end func Scan_Number;

      func Scan_String () -> optional Univ_String is
         //  Read in a JSON string
         var Result_Vec : Vector<Univ_Character> := [Peek];

         loop
            IVS.Next();
            if Peek is null then
               //  Syntax error
               IVS.JSON_Syntax_Error ("EOF while reading a string");
               return null;
            elsif Peek == '\n' then
               //  Syntax error
               IVS.JSON_Syntax_Error ("Unterminated string");
               return null;
            elsif Peek == '\\' then
               IVS.Next();
               case Peek of
                ['r'] =>
                  Peek := '\r';
                ['n'] =>
                  Peek := '\n';
                ['t'] =>
                  Peek := '\t';
                ['f'] =>
                  Peek := '\f';
                ['b'] =>
                  Peek := '\b';
                ['u'] =>
                  //  Unicode using 4 hex digits 
                  var U_Val := 0;

                  for I in 1 .. 4 loop
                     IVS.Next();
                     const Dig := Decode_Hex_Digit (Peek);
                     if Dig is null then
                        return null;
                     end if;
                     U_Val := U_Val * 16 + Dig;
                  end loop;
                  Peek := UTF::Nul_Ch + U_Val;

                [..] =>
                  //  Peek not changed
                  null;
               end case;
               Result_Vec |= Peek;
            else
               Result_Vec |= Peek;
               if Peek == '"' then
                  exit loop;
               end if;
            end if;
         end loop;

         if Peek is null then
            //  Bad string
            return null;
         else
            //  Good string.  No peek-ahead left.
            Peek := null;
            return From_Vector (Result_Vec);
         end if;
      end func Scan_String;

      func Scan_Keyword (Keyword : Univ_String)
         -> optional Univ_String is
         for each C of Keyword forward loop
            if Peek is null or else Peek != C then
               return null;
            end if;
            IVS.Next();
         end loop;

         //  Syntax OK (TBD: should we require a separator after a keyword?)
         return Keyword;
      end func Scan_Keyword;

      //////

      if Peek is null then
         IVS.Next();
      end if;

      while Peek not null loop
         case Peek of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;

          ['0'..'9' | '-'] =>
            //  A JSON number
            return Scan_Number ();

          ['"'] =>
            //  A JSON string
            return Scan_String ();

          ['[' | ']' | '{' | '}' | ':' | ','] =>
            //  A separator
            const Result := Peek | "";
            //  No peak-ahead after a separator which means it can
            //  be "pushed back"
            Peek := null;
            if not Ignore_Comma or else Result != "," then
               return Result;
            end if;

          ['t'] =>
            return Scan_Keyword ("true");

          ['f'] =>
            return Scan_Keyword ("false");

          ['n'] =>
            return Scan_Keyword ("null");

          [..] =>
            IVS.JSON_Syntax_Error ("Invalid JSON token");
            //  Skip over bad character
            IVS.Next();
            return null;
         end case;

         //  Advance to next character
         IVS.Next();
      end loop;
   end func Scan_JSON_Token;

 exports

   func Create(ref var Input_Byte_Stream+) -> JSON_Input_Value_Stream is
     ((Byte_Str => Input_Byte_Stream));

   func Is_Self_Describing (JSON_Input_Value_Stream) -> Boolean is (#true);
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Input_Value_Stream) -> Boolean
     is (JSON_Input_Value_Stream.End_Reached);

   func Read_Int (var IVS : JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> Val : Univ_Integer is

      Val := Read_Optional_Int (IVS, Low, High);
      {Val not null}
   end func Read_Int;

   func Read_Optional_Int
     (var IVS : JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> optional Univ_Integer is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting an integer");
         return null;
      end if;

      case Token[1] of
       ['n'] =>
         //  "null"
         return null;
       ['0' .. '9' | '-'] =>
         //  From_String will return null if not good integer syntax
         return From_String (Token);
       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting '-' or a digit," |
                  " found \"`(Token)\"");
         return null;
      end case;
   end func Read_Optional_Int;

   func Read_Float (var JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> Univ_Float is
      (Read_Optional_Float (JSON_Input_Value_Stream, Digits));

   func Read_Optional_Float
     (var IVS : JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> Result : optional Univ_Float is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a floating-point number");
         return null;
      end if;

      case Token[1] of
       ['n'] =>
         //  "null"
         return null;
       ['0' .. '9' | '-'] =>
         //  From_String will return null if not good numerical syntax
         return From_String (Token);
       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a floating-point number");
         return null;
      end case;
   end func Read_Optional_Float;

   func Read_Rational (var IVS : JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> Rational
     is (Read_Optional_Rational (IVS, Digits));

   func Read_Optional_Rational
     (var IVS : JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> optional Rational is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON number");
         return null;
      end if;

      case Token[1] of
       ['n'] =>
         //  "null"
         return null;
       ['0' .. '9' | '-'] =>
         //  From_String will return null if not good numerical syntax
         return From_String (Token);
       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON number");
         return null;
      end case;
   end func Read_Optional_Rational;

   func Read_String (var IVS : JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> Univ_String is
      return Read_Optional_String (IVS, Max_Char, Min_Len, Max_Len);
   end func Read_String;
      
   func Read_Optional_String
     (var IVS : JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> optional Univ_String is
      
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON string");
         return null;
      end if;

      case Token[1] of
       ['"'] =>
         //  Strip off the double quotes
         return Token[2 .. |Token|-1];

       ['n'] =>
         //  "null"
         return null;

       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON string");
         return null;
      end case;
   end func Read_Optional_String;

   func Read_Begin_Seq (var IVS : JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : Univ_Integer is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token != "[" then
         {#false}
         return 0;
      end if;

      //  Always variable length
      return -1;
   end func Read_Begin_Seq;

   func Read_Begin_Optional_Seq (var IVS : JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null then
         IVS.JSON_Syntax_Error ("Expecting a JSON array");
         return 0;
      elsif Token == "null" then
         return null;
      elsif Token == "[" then
         //  Always variable length
         return -1;
      else
         IVS.JSON_Syntax_Error ("Expecting a JSON array");
         return 0;
      end if;
   end func Read_Begin_Optional_Seq;

   func More_Seq_Elements (var IVS : JSON_Input_Value_Stream) -> Boolean is
      if IVS.Peek_Char is null then
         //  Peek ahead
         IVS.Next();
      end if;

      while IVS.Peek_Char not null loop
         case IVS.Peek_Char of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;
          [']'] =>
            //  End of sequence
            return #false;
          [','] =>
            //  Absorb the comma and return #true.
            IVS.Peek_Char := null;
            return #true;
          [..] =>
            //  Anything might come immediately after a '['
            return #true;
         end case;
         //  Get next character
         IVS.Next();
      end loop;
      //  End of stream
      return #false;
   end func More_Seq_Elements;

   func Read_End_Seq (var IVS : JSON_Input_Value_Stream) is
   //  Absorb end-of-seq indicator.
      const Token := Scan_JSON_Token (IVS);
      if Token not null and then Token == "]" then
         return;
      else
         IVS.JSON_Syntax_Error ("Missing final ']' for JSON array");
         return;
      end if;
   end func Read_End_Seq;

   func Read_Begin_Map (var IVS : JSON_Input_Value_Stream) is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token != "{" then
         IVS.JSON_Syntax_Error ("Expecting JSON Object");
      end if;
   end func Read_Begin_Map;

   func Read_Begin_Optional_Map (var IVS : JSON_Input_Value_Stream)
     -> Is_Null : Boolean is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null then
         IVS.JSON_Syntax_Error ("Expecting JSON Object");
         return #true;
      elsif Token == "null" then
         return #true;
      elsif Token == "{" then
         return #false;
      else
         IVS.JSON_Syntax_Error ("Expecting JSON Object");
         return #true;
      end if;
   end func Read_Begin_Optional_Map;

   func More_Map_Elements (var IVS : JSON_Input_Value_Stream) -> Boolean is
      if IVS.Peek_Char is null then
         //  Peek ahead
         IVS.Next();
      end if;

      while IVS.Peek_Char not null loop
         case IVS.Peek_Char of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;
          ['}'] =>
            //  End of object
            return #false;
          [','] =>
            //  Absorb the comma and return #true.
            IVS.Peek_Char := null;
            return #true;
          [..] =>
            //  Anything might come immediately after a '{'
            return #true;
         end case;
         //  Get next character
         IVS.Next();
      end loop;
      //  End of stream
      return #false;
   end func More_Map_Elements;

   func Read_Key_Value_Separator (var IVS : JSON_Input_Value_Stream) is
   //  Skip over the ':' in a Key/Value pair of a map
      const Token := Scan_JSON_Token (IVS);
      if Token is null or else Token != ":" then
         IVS.JSON_Syntax_Error ("Expecting ':'");
      end if;
   end func Read_Key_Value_Separator;

   func Read_End_Map (var IVS : JSON_Input_Value_Stream)
     -> Syntax_OK : Boolean is
   //  Absorb end-of-map indicator.
   //  Return #false if end-of-map indicator is missing.
      const Token := Scan_JSON_Token (IVS);

      if Token not null and then Token == "}" then
         Syntax_OK := #true;
      else
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting '}'");
         Syntax_OK := #false;
      end if;
   end func Read_End_Map;

   func Read_Begin_Poly (var IVS : JSON_Input_Value_Stream)
     -> Type_Name : Univ_String
     is (Read_Begin_Optional_Poly (IVS));

   func Read_Begin_Optional_Poly (var IVS : JSON_Input_Value_Stream)
     -> Type_Name : optional Univ_String is
      if (Read_Begin_Optional_Map (IVS)) then
         return null;
      else
         return Read_String (IVS,
                             Max_Char => Univ_Character::Last(),
                             Min_Len => 1, Max_Len => 100_000);
      end if;
   end func Read_Begin_Optional_Poly;

   func Read_End_Poly (var IVS : JSON_Input_Value_Stream) is
      const OK := Read_End_Map (IVS);
      {OK}
   end func Read_End_Poly;

   func Read_Begin_Obj (var IVS : JSON_Input_Value_Stream) is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token != "[" then
         {#false}
         return;
      end if;
   end func Read_Begin_Obj;

   func Read_Begin_Optional_Obj (var IVS : JSON_Input_Value_Stream)
     -> Is_Null : Boolean is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null then
         {#false}
         return #true;

      elsif Token == "null" then
         return #true;

      elsif Token == "[" then
         return #false;

      else
         if Debug then
            Println("Expecting '[' or 'null' but found '`(Token)'");
         end if;
         {#false}
         return #true;
      end if;
      
   end func Read_Begin_Optional_Obj;

   func Read_End_Obj (var IVS : JSON_Input_Value_Stream) is 
      const Token := Scan_JSON_Token (IVS);
      {Token not null and then Token == "]"}
   end func Read_End_Obj;

   func Read_JSON_Value
     (var IVS : JSON_Input_Value_Stream)
     -> Result : optional JSON_Value+ is
   //  Read one JSON value from the JSON-formatted byte stream.
   //  Return null if not good JSON syntax.
      if IVS.Peek_Char is null then
         //  Peek ahead
         IVS.Next();
      end if;

      while IVS.Peek_Char not null loop
         case IVS.Peek_Char of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;

          ['{'] =>
            //  JSON Object
            if Debug then
               Println("Reading a JSON object");
            end if;
            var Obj : JSON_Object_Value for Result := Create();

            Read_Begin_Map (IVS);
            while More_Map_Elements (IVS) loop
               const Key :=
                 Read_Optional_String (IVS, Univ_Character::Last(),
                   Min_Len => 0, Max_Len => 10_000);

               if Key is null then
                  IVS.JSON_Syntax_Error ("Expecting JSON string for Key");
                  return null;
               end if;

               Read_Key_Value_Separator (IVS);

               Obj.Value[Key] := Read_JSON_Value (IVS);
            end loop;
            if Debug then
               Println("JSON Map is `(|Obj.Value|) in length");
            end if;
            if Read_End_Map (IVS) then
               return Obj;
            else
               //  Syntax error
               return null;
            end if;

          ['['] =>
            //  JSON Array
            if Debug then
               Println("Reading a JSON array");
            end if;
            var Arr : JSON_Array_Value for Result := Create();

            const Ignore_Len :=
              Read_Begin_Seq (IVS, Min_Len => 0, Max_Len => 2**15);
            while More_Seq_Elements (IVS) loop
               var Val for Arr := Read_JSON_Value (IVS);
               Arr.Value <|= Val;
            end loop;

            Read_End_Seq (IVS);

            if Debug then
               Println("JSON array is `(|Arr.Value|) in length");
            end if;

            return Arr;

          ['"'] =>
            //  JSON String
            if Debug then
               Println("Reading a JSON string");
            end if;
            const Str := Read_Optional_String
              (IVS, Univ_Character::Last(), Min_Len => 0, Max_Len => 10_000);
               //  Will return "null" on a syntax error

            if Str not null then
               return JSON_String_Value::Create (Str);
            else
               return null;
            end if;

          ['0' .. '9' | '-'] =>
            //  JSON number
            if Debug then
               Println("Reading a JSON number");
            end if;
            const Num := Read_Optional_Rational (IVS);
               //  Will return "null" on a syntax error

            if Num not null then
               return JSON_Number_Value::Create (Num);
            else
               return null;
            end if;

          ['t' | 'f'] =>
            //  JSON Boolean value
            if Debug then
               Println("Reading a JSON bool");
            end if;
            const Token := Scan_JSON_Token (IVS);
            
            if Debug then
               Println("bool token is `(Token)");
            end if;
            if Token not null then
               if Token == "true" then
                  return JSON_Boolean_Value::Create(#true);
               elsif Token == "false" then
                  return JSON_Boolean_Value::Create(#false);
               end if;
            end if;
            //  Syntax error
            IVS.JSON_Syntax_Error ("Expecting 'true' or 'false'");
            return null;

          ['n'] =>
            //  JSON Null value
            if Debug then
               Println("Reading a JSON null");
            end if;
            const Token := Scan_JSON_Token (IVS);
            
            if Token not null and then Token == "null" then
               return JSON_Value::Create(#Null_Value);
            else
               //  Syntax error
               IVS.JSON_Syntax_Error ("Expecting 'null'");
               return null;
            end if;

          [..] =>
            //  Anything else is unexpected
            //  Read and discard the token
            const Token := Scan_JSON_Token (IVS);

            IVS.JSON_Syntax_Error
              ("Unexpected token in JSON stream: \"`(Token)\"");
            return null;
         end case;
         //  Get next character
         IVS.Next();
      end loop;
      //  End of stream
      return null;
   end func Read_JSON_Value;

   func JSON_Syntax_Error
     (IVS : JSON_Input_Value_Stream; Err : Univ_String := "JSON syntax error")
   //  Give an error message, and indicate line and character
   is
      Println ("`(IVS.Source_Line):`(IVS.Source_Char): `(Err)");
   end func JSON_Syntax_Error;

end class PSL::Core::JSON_Input_Value_Stream;

func PSL::Test::Test_JSON_Stream() is

   var IO := IO::Get_IO();
   var B_File : Byte_Stream_Output_File := IO.Create ("json_test.json");

   ref var OVS : JSON_Output_Value_Stream => Create(B_File);

   ref var OOS : Output_Object_Stream => Create(OVS);

   var Next_Val_Out := 1111;
   var Next_Val_In := 1111;

   func Next_Out() -> Univ_Integer is
   //  Return a unique value
      Next_Val_Out := Next_Val_Out + 123;
      return Next_Val_Out;
   end func Next_Out;

   func Next_In() -> Univ_Integer is
   //  Return a unique value
      Next_Val_In := Next_Val_In + 123;
      return Next_Val_In;
   end func Next_In;

   Println ("Testing Read/Write_Optional_Object with a JSON value stream");
   Println (" output in json_test.json");

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Obj (OOS, Univ_Integer::(null));
      else
         Write_Optional_Obj (OOS, I**3);
      end if;
        
   end loop;

   Println ("Testing write sets rather than integers");

   type Int_Set is Set<Integer>;

   func Img(II : Int_Set) -> Univ_String is
      return "[" | (for (I : Integer in II; Sep := "" then ",") =>
                 <""> | Sep | To_String (I)) | "]";
   end func Img;

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Obj (OOS, Int_Set::(null));
      else
         var Test_Set : Int_Set := [for J in 1 .. I => Next_Out()];

         Write_Optional_Obj (OOS, Test_Set);
      end if;
        
   end loop;

   B_File.Close();

   //  Read back in

   var I_File : Byte_Stream_Input_File := IO.Open ("json_test.json");
   ref var IVS : JSON_Input_Value_Stream => Create(I_File);
   ref var IOS : Input_Object_Stream => Create(IVS);

   Println ("About to read in 7 (optional) Integers");

   for I in 1 .. 7 forward loop
      var Z : Univ_Integer;
      // Read_Optional_Obj (IOS, Z);
      Z := Read_Optional_Int (IVS, 0, High => 7**3);
      if I == 3 then
         if Z not null then
            Println ("Expected null but found `(Z)");
         end if;
      else
         if Z != I**3 then
            Println ("Expected `(I**3) but found `(Z)");
         end if;
      end if;
      // Println
      //   ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   Println ("Successful read of 7 optional integers");
   
   Println ("About to read in 7 (optional) Integer sets");
   for I in 1 .. 7 forward loop
      // Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      Println ("Reading set `(I)");
      const Expected : optional Int_Set :=
        (if I == 3 then null else [for J in 1 .. I => Next_In()]);

      if Expected is null then
         Println ("Expecting null");
      else

         Println ("Expecting `(Img(Expected))");
      end if;

      var Z : Int_Set;
      Read_Optional_Obj (IOS, Z);
      if Expected is null then
         if Z not null then
            Println ("Expected null but found `(Img(Z))");
         end if;
      else
         if Z != Expected then
            Println ("Expected `(Img(Expected)) but found `(Img(Z))");
         end if;
      end if;
      // Println
      //   ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   I_File.Close();
   Println ("All done");
end func PSL::Test::Test_JSON_Stream;

func PSL::Test::Test_JSON_Value_IO (From, To : Univ_String) is
   
   var IO := IO::Get_IO();

   var I_File : Byte_Stream_Input_File := IO.Open (From);

   if I_File is null then
      Println("Cannot open `(From)");
      return;
   end if;

   ref var IVS : JSON_Input_Value_Stream => Create(I_File);

   Println ("About to read JSON file \"`(From)\"");
   const JSON_Val := Read_JSON_Value (IVS);

   Println ("Done reading in JSON file");

   if JSON_Val is null then
      IVS.JSON_Syntax_Error ("JSON File `(From) has a syntax error");
      I_File.Close();
      return;
   end if;

   I_File.Close();

   Println ("About to write value back out to file \"`(To)\"");
   var O_File : Byte_Stream_Output_File := IO.Create (To);
   if O_File is null then
      Println("Cannot create file `(To)");
      return;
   end if;

   ref var OVS : JSON_Output_Value_Stream => Create(O_File);

   Write_JSON_Value (OVS, JSON_Val);
   Println ("Done writing to JSON file");
   O_File.Close();

end func PSL::Test::Test_JSON_Value_IO;
