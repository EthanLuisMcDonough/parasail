//  Byte stream used for (de)serializing values/objects
//
//  Streaming in ParaSail is a three layer cake:
//    Byte Stream is the lowest layer
//    Value Stream is the middle layer
//    Object Stream is the top layer
//
//  A byte stream abstracts away the actual file, network, or internal buffer
//  that holds the bytes of the stream.
//  The minimal operations for a byte stream are:
//    For input:
//      func Read
//        (var Input_Byte_Stream;
//         var Data : Stream_Element_Array)
//        -> Bytes_Read : Stream_Count;
//    For output: 
//      func Write
//        (var Output_Byte_Stream;
//         Data : Stream_Element_Array)
//        -> Bytes_Written : Stream_Count;
//  Other operations depend on the kind of the byte stream.
//  For example, for a file byte stream, there are operations to
//  create and/or open the file.
//
//  A value stream abstracts away the byte representation of any given
//  value, where a value could be a number or a string, possibly optional,
//  and possibly surrounded by syntax to indicate that the value is part of
//  a larger composite object, such as a sequence or a dictionary, or
//  an object of some user-defined type.
//  A value stream could be in binary, or in some textual form such as
//  JSON or XML.  A binary value stream generally has no need for extra
//  indicators of the start or finish of, for example, a sequence or a
//  dictionary.  A textual form generally will need some sort of extra
//  syntax.  Each kind of value stream provides its own way of indicating
//  the begin or end of a sequence, a map (i.e. a dictionary), an object,
//  or a "polymorphic" object, where the type itself is encoded within
//  the value stream.  The operations which emit this syntax (if any)
//  are Begin/End_Seq, Begin/End_Map, Begin/End_Object, and Begin/End_Poly.
//
//  An object stream abstracts away the set of values and other syntax
//  that are used to represent a high-level object.
//  The ParaSail run-time library provides a default representation of
//  any ParaSail object.  The user can also define a "custom" representation
//  for a given type of object.  The implementation of the "custom" streaming
//  operations ("read" and "write") can use the "default" streaming operations
//  (Write_Default, Read_Default) as a fall-back, perhaps preceded or followed
//  by additional values or other syntax.

interface PSL::Core::Byte_Stream<> is
   const Stream_Elem_Size := 8;

   type Stream_Element is Modular<2**Stream_Elem_Size>;
   type Stream_Index is Integer<0 .. Integer_64::Last()>;
   type Stream_Count is Stream_Index;

   type Stream_Element_Array is Packed_Array<Stream_Element, Stream_Index>;

   func Num_Bytes_For_Int
     (Low, High : Univ_Integer {Low <= High}; Is_Optional : Boolean)
      -> Num_Bytes : Univ_Integer;
     //  Determine representation to use for integers
     //  based on low and high bound.

   func Null_To_Use
     (Low, High : Univ_Integer {Low <= High})
      -> optional Univ_Integer;
     //  Determine value to use to represent "null" given non-null value range.

   const Null_8_Byte_Arr : Stream_Element_Array := [0, 0, 0, 0, 0, 0, 0, 0x80];
   //  Representation of "null" in stream when Null_To_Use returns null

end interface PSL::Core::Byte_Stream;

class PSL::Core::Byte_Stream is

 exports

   func Num_Bytes_For_Int
     (Low, High : Univ_Integer {Low <= High}; Is_Optional : Boolean)
      -> Num_Bytes : Univ_Integer is
     //  Determine representation to use for integers
     //  based on low and high bound.
     //  If Low >= 0 will presume an unsigned representation.
      const Room_For_Null := (if Is_Optional then 1 else 0);

      if Low >= 0 then
         --  Can use unsigned

         if High <= 2**8 - 1 - Room_For_Null then
            Num_Bytes := 1;
         elsif High <= 2**16 - 1 - Room_For_Null then
            Num_Bytes := 2;
         elsif High <= 2**24 - 1 - Room_For_Null then
            Num_Bytes := 3;
         elsif High <= 2**32 - 1 - Room_For_Null then
            Num_Bytes := 4;
         elsif High <= 2**64 - 1 - Room_For_Null then
            Num_Bytes := 8;
         else
            --  Use variable length
            Num_Bytes := -1;
         end if;
      else
         --  Use signed

         if High <= 2**7-1 and then Low >= -2**7 + Room_For_Null then
            --  Use 8-bit elements
            Num_Bytes := 1;
         elsif High <= 2**15-1 and then Low >= -2**15 + Room_For_Null then
            --  Use 16-bit elements
            Num_Bytes := 2;
         elsif High <= 2**31-1 and then Low >= -2**31 + Room_For_Null then
            --  Use 32-bit elements
            Num_Bytes := 4;
         elsif High <= 2**63-1 and then Low >= -2**63 + Room_For_Null then
            --  Use 64-bit elements
            Num_Bytes := 8;
         else
            --  Use variable length
            Num_Bytes := -1;
         end if;
      end if;
   end func Num_Bytes_For_Int;

   func Null_To_Use
     (Low, High : Univ_Integer {Low <= High})
      -> optional Univ_Integer is
     //  Determine value to use to represent "null" given non-null value range.
      const Num_Bytes :=
        Num_Bytes_For_Int (Low, High, Is_Optional => #true);

      if Low < 0 then
         //  Use most-negative value that fits in num bytes
         if Num_Bytes < 0 then
            //  Just below "Low" -- TBD: round down to power of 2
            return Low-1;
         elsif Num_Bytes == 8 then
            --  Use "regular" null
            return null;
         else
            //  Use most-negative value that fits
            return -2**(Num_Bytes * 8 - 1);
         end if;
      else
         //  Unsigned value.
         //  Use most-positive value that fits in num bytes
         if Num_Bytes < 0 then
            //  Just above "High"  --  TBD: round up to power of 2
            return High+1;
         elsif Num_Bytes == 8
           and then High <= 2**63-1
         then
            //  Use regular null
            return null;
         else
            //  Use most-positive value that fits
            return 2**(Num_Bytes * 8) - 1;
         end if;
      end if;
   end func Null_To_Use;
end class PSL::Core::Byte_Stream;

abstract interface PSL::Core::Input_Byte_Stream<>
  extends Byte_Stream<> is
   func Read  (var Input_Byte_Stream;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count;
end interface PSL::Core::Input_Byte_Stream;

abstract interface PSL::Core::Output_Byte_Stream<>
  extends Byte_Stream<> is
   func Write (var Output_Byte_Stream;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count;
end interface PSL::Core::Output_Byte_Stream;

interface PSL::Core::Byte_Stream_Buffer<>
  extends Byte_Stream<> implements Input_Byte_Stream, Output_Byte_Stream is

   func Create (Size : Stream_Count) -> Byte_Stream_Buffer;

   func Create (Initial_Content : Stream_Element_Array) -> Byte_Stream_Buffer;
   //  Create a new buffer from a stream-element array

   func Write (var BSB : Byte_Stream_Buffer;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count;

   func Read  (var BSB : Byte_Stream_Buffer;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count;

   func Bytes_To_Read (BSB : Byte_Stream_Buffer) -> Univ_Integer;

   func Bytes_To_Write (BSB : Byte_Stream_Buffer) -> Univ_Integer;

end interface PSL::Core::Byte_Stream_Buffer;

interface PSL::Core::Byte_Stream_Output_File<>
  extends Output_Byte_Stream<> is

   func Create (var IO; Name : Univ_String)
     -> optional Byte_Stream_Output_File
      is import(#create_output_file)

   func Append (var IO; Name : Univ_String)
     -> optional Byte_Stream_Output_File
      is import(#append_output_file)

   func Flush(var Byte_Stream_Output_File)
      is import(#flush_output_file)

   func Close(var optional Byte_Stream_Output_File)
      is import(#close_output_file)

   func Delete(var optional Byte_Stream_Output_File)
      is import(#delete_output_file)

   func Write (var Byte_Stream_Output_File;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count
       is import(#write_bytes_to_file)

end interface PSL::Core::Byte_Stream_Output_File;

interface PSL::Core::Byte_Stream_Input_File<>
  extends Input_Byte_Stream<> is
   func Open (var IO; Name : Univ_String) -> optional Byte_Stream_Input_File
      is import(#open_input_file)

   func Close(var optional Byte_Stream_Input_File)
      is import(#close_input_file)

   func Read  (var Byte_Stream_Input_File;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count
       is import(#read_bytes_from_file)

end interface PSL::Core::Byte_Stream_Input_File;

class PSL::Core::Byte_Stream_Buffer is

   var Buf : Stream_Element_Array;
   var Write_Index : Byte_Stream::Stream_Index := 0;
   var Read_Index : Byte_Stream::Stream_Index := 0;
   const Debug : Boolean := #true;
 exports
   func Create (Size : Stream_Count) -> Result : Byte_Stream_Buffer is

      Result := (Buf => Create (0 ..< Size, 0));

   end func Create;

   func Create (Initial_Content : Stream_Element_Array)
     -> Byte_Stream_Buffer is
      //  Create a new buffer from a stream-element array
      return (Buf => Initial_Content, Write_Index => |Initial_Content|);
   end func Create;

   func Write (var BSB : Byte_Stream_Buffer;
     Data : Stream_Element_Array) -> Bytes_Written : Stream_Count is
      Bytes_Written := Min (|Data|, |BSB.Buf| - BSB.Write_Index);

      for (Left in BSB.Write_Index .. BSB.Buf.Last();
           Right in Data.Bounds()) forward loop
         BSB.Buf [Left] := Data [Right];
         // Println("write BSB.Buf[`(Left)] = `(BSB.Buf[Left])");
      end loop;

      if Debug and then Bytes_Written != |Data| then
         Println("|Data| = `(|Data|) but Bytes_Written = `(Bytes_Written)");
      end if;

      BSB.Write_Index += Bytes_Written;
   end func Write;

   func Read  (var BSB : Byte_Stream_Buffer;
     var Data : Stream_Element_Array) -> Bytes_Read : Stream_Count is
      Bytes_Read := Min (|Data|, BSB.Write_Index - BSB.Read_Index);

      for (Left in Data.Bounds();
           Right in BSB.Read_Index ..< BSB.Write_Index) forward loop
         // Println("read BSB.Buf[`(Right)] = `(BSB.Buf[Right])");
         Data [Left] := BSB.Buf [Right];
      end loop;
      BSB.Read_Index += Bytes_Read;

      if BSB.Read_Index == BSB.Write_Index then
         --  Buffer is empty, so reset indices
         BSB.Read_Index := 0;
         BSB.Write_Index := 0;
      end if;
   end func Read;

   func Bytes_To_Read (BSB : Byte_Stream_Buffer) -> Univ_Integer is
     (BSB.Write_Index - BSB.Read_Index);

   func Bytes_To_Write (BSB : Byte_Stream_Buffer) -> Univ_Integer is
     (BSB.Buf.Last() - BSB.Write_Index + 1);
end class PSL::Core::Byte_Stream_Buffer;

class PSL::Core::Byte_Stream_Output_File is
    const Name : Univ_String
    const Index : Univ_Integer
  exports
end class PSL::Core::Byte_Stream_Output_File;

class PSL::Core::Byte_Stream_Input_File is
    const Name : Univ_String
    const Index : Univ_Integer
  exports
end class PSL::Core::Byte_Stream_Input_File;

func PSL::Test::Test_Byte_Stream() is
   var Buf : Byte_Stream_Buffer := Create (Size => 100);

   for I in 1 .. 7 forward loop
      const Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 15, I);
      const Written := Buf.Write(Arr)
      if Written != 15 then
         Println ("Tried to write 15 bytes, but only `(Written) were written");
      else
         Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
      end if;
   end loop;

   var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 15, 0);

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Bytes_Read := Buf.Read(Arr)
      Println ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
      if Bytes_Read != 15 then
         Println ("Tried to read 15 bytes, but only `(Bytes_Read) were read");
      else
         for Z in 1 .. 10 loop
            if Arr[Z] != I then
               Println ("Expected `(I) in Arr[`(Z)] but found `(Arr[Z])");
            end if;
         end loop;
      end if;
   end loop;
   
   Println (" Now using zero-based array");

   for I in 1 .. 7 forward loop
      const ZB_Arr : Byte_Stream::Stream_Element_Array := Create(0 ..< 15, I);
      const Written := Buf.Write(ZB_Arr)
      if Written != 15 then
         Println ("Tried to write 15 bytes, but only `(Written) were written");
      else
         Println ("Bytes_To_Write = `(Buf.Bytes_To_Write())");
      end if;
   end loop;

   var ZB_Arr : Byte_Stream::Stream_Element_Array := Create(0 ..< 15, 0);

   for I in 1 .. 7 forward loop
      Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      const Bytes_Read := Buf.Read(ZB_Arr)
      Println ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
      if Bytes_Read != 15 then
         Println ("Tried to read 15 bytes, but only `(Bytes_Read) were read");
      else
         for Z in ZB_Arr.Bounds() loop
            if ZB_Arr[Z] != I then
               Println
                 ("Expected `(I) in ZB_Arr[`(Z)] but found `(ZB_Arr[Z])");
            end if;
         end loop;
      end if;
   end loop;
   
   Println ("All done");
end func PSL::Test::Test_Byte_Stream;

func PSL::Test::Test_File_Stream() is
   var IO := IO::Get_IO()

   var Out_File : Byte_Stream_Output_File := IO.Create ("test_file");

   for I in 1 .. 7 forward loop
      const Arr : Byte_Stream::Stream_Element_Array :=
         Create(1 .. (I == 7? 10: 15), I);
      const Written := Out_File.Write(Arr)
      if Written != 15 then
         Println ("Tried to write 15 bytes, but only `(Written) were written");
      end if;
   end loop;

   Out_File.Close();

   var In_File : Byte_Stream_Input_File := IO.Open ("test_file");

   var Arr : Byte_Stream::Stream_Element_Array := Create(1 .. 15, 0);

   for I in 1 .. 7 forward loop
      const Bytes_Read := In_File.Read(Arr)
      if Bytes_Read != 15 then
         Println ("Tried to read 15 bytes, but only `(Bytes_Read) were read");
      else
         for Z in 1 .. 10 loop
            if Arr[Z] != I then
               Println ("Expected `(I) in Arr[`(Z)] but found `(Arr[Z])");
            end if;
         end loop;
      end if;
   end loop;

   In_File.Close();
   
   Println ("All done");
end func PSL::Test::Test_File_Stream;
