// Example ParaSail program -- Finite State Automaton module

// Copyright (C) 2023, AdaCore, New York, NY
// This program is provided "as is" with no warranty.
// Report errors: http://groups.google.com/group/parasail-programming-language

interface FSA<> is
  // Interface to a Finite State Automaton module
  // The FSA can be either nondeterministic (NFA) or deterministic (DFA)
  // Each state in the FSA is represented by a node
  // Each possible transition is represented by an edge

  // There is one start state, and any number of end states.
  // Each non-end-state is labeled by a Query ID, and each edge is labeled
  // by a value set the associated node's query must satisfy for the
  // transition to be allowed.
  // Each end state is labeled by a set of Action IDs.
  // Action IDs are fully ordered.

  // A value set must be of a type that implements an interface that supports
  // union, intersection, is_subset, is_equal, empty set, univ set, invert set.

  // A Query ID can have a prerequisite, which is that some other Query ID
  // is within a specified value set.  Query IDs are fully ordered
  // consistent with a requirement that any Query ID with a prerequisite
  // comes after the prerequisite's Query ID in this order.
  // Nodes along a path from the start state to any end state have Query IDs
  // that monotonically increase in this Query ID order.
  // Note: This requirement simplifies translating an NFA to a DFA.

  // A check is made that a node with a Query ID that has a prerequisite is
  // only reachable via some state labeled with the prerequisite Query ID
  // along an outgoing edge that specifies a value set that is a subset of
  // that specified in the prerequisite.
  // Note: The prerequisite notion is to support the notion of
  //       "variant record" like structures.  It turns out it is not
  //       directly relevant to other checks that can be performed as
  //       part of the conversion from NFA to DFA, such as nonambiguity,
  //       exhaustiveness, or nonredundancy.

  // If a Query ID does not appear along a path from the start state to
  // an end state, it can be assumed to be a "don't care" query, where any
  // value is acceptable (or the Query ID is not permitted because its
  // prerequisite is not satisfied).

  // An FSA can be tested to see whether it is deterministic by checking
  // that at each state, the various edges are labeled by non-overlapping
  // value sets, and every end state has exactly one Action ID.

    const Debug : Boolean := #true;

    type Node_Id is new Integer<0..10**6>;
      // A unique id for each node in the FSA

    type Node_Set is Countable_Set<Node_Id>;
      // A set of nodes

    type Query_Id is new Integer<0..10**6>;
      // A unique id for each distinct query that is performed

    type Action_Id is new Integer<0..10**6>;
      // A unique id for each distinct action in the FSA

    func Num_Nodes (FSA) -> Univ_Integer;
    //  Count of nodes within FSA

    func Add_Action_Id (var FSA; Action : Univ_String) -> Action_Id;
    //  Add a new Action_Id to the FSA
    //  Action is a string representing the action to be performed.

    func Add_Action_Node (var FSA; Action : Univ_String) -> Node_Id;
    //  Add a node that has one (new) action ID;
    //  Action is a string representing the action to be performed.

    func Num_Actions (FSA) -> Univ_Integer;
    //  Count of end states ("action" nodes)

    func Action_String(FSA; Action_Id) -> Univ_String;
      //  Return string representing action to be performed

    func Add_Query_Id (var FSA; Formula : Univ_String) -> Query_Id;
    //  Add a new Query_Id to the FSA, representing the given Formula

    func Num_Queries (FSA) -> Univ_Integer;
    //  Count of distinct queries within FSA

    func Query_Formula (FSA; Query_Id) -> Univ_String;
    //  Return query formula

    type Edge_Count is new Integer<0..10**6>;
    type Edge_Index is Edge_Count {Edge_Index >= 1};

    interface Node<> is

        func Create(optional Node_Id := null; optional Query_Id := null)
          -> Node;
        //  Create a node with given node id and query id.

        func Set_Id (var Node; Node_Id);
        //  Fill in the Node_Id; might already have a value

        func Id (Node) -> optional Node_Id;
        //  Unique Node_Id for node within FSA
        //  This is null for a "template" node

        func Query (Node) -> optional Query_Id;
        //  Identifies which query this node is performing
        //  This is null for an action node/end state

        func Add_Successor(var From : Node; To : Node_Id)
          {Successor_Index(From', To) not null};
         // Add an edge in the FSA

        func Num_Successors (Node) -> Edge_Index;
        //  Number of successor nodes.
        //  Will be zero for an end state.

        func Successor (Node; Index : Edge_Index)
          {Index <= Num_Successors (Node)}
          -> Node_Id;
        //  Return Node_Id for given successor

        func Successor_Index (From : Node; To : Node_Id)
          -> optional Edge_Index;
        //  Return non-null Edge_Index if To is a successor of From.

        func Is_End_State (Node) -> Boolean is (#false);
        //  Return True if Node is an end state (i.e. is an Action_Node).

        func Dump_Node(FSA; Node; Indent : Univ_Integer);
        // Produce human-understandable dump of node, at given indent

        abstract func Is_Nondeterministic (Node) -> Boolean;
        //  Return True if Node has outgoing edges with overlapping value sets

        abstract func Disambiguate (Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set>;
        //  Update Node in FSA[Id(Node)] so that each edge has a value set
        //  that is disjoint from the value sets of other edges.
        //  Create new Node_Ids for the new nodes that will
        //  be mergers of other nodes.
        //  Return a mapping from Node_Ids for the updated Node (both
        //  existing Node_Ids and Node_Ids created by Disambiguate) to
        //  the set of old Node_Ids whose nodes need to be merged to create
        //  the node to go with each Node_Id of the updated node.
        //  Note that the passed-in Node is a read only copy of the original
        //  FSA[Id(Node)]

        abstract func Merge_Nodes
          (var New_Node : Node; FSA; Nodes_To_Merge : Node_Set);
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
    end interface Node;

    interface Action_Node<> extends Node is
      //  End state of FSA contains a set of actions

       func Create(optional Node_Id := null; optional Query_Id := null)
         -> Action_Node;
        //  Must override inherited constructors.

        //  Create a node with given node id and query id.

       func Is_End_State (Action_Node) -> Boolean is (#true);
         //  Return True if Node is an end state (i.e. is an Action_Node).

       func Is_Nondeterministic (Action_Node) -> Boolean is
         (|Action_Ids(Action_Node)| > 1);
        //  Return True if Node has outgoing edges with overlapping value sets
        //  or is a leaf node with multiple Action_Ids.

       func Disambiguate (Action_Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set> is ([]);
        //  Not relevant for an action node.
        //  TBD: We could use this as the time to complain about action sets
        //       which are not reducible to a single action.

       func Merge_Nodes
         (var New_Node : Action_Node; FSA; Nodes_To_Merge : Node_Set);
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
        //  If New_Node is an Action_Node, then just include their Action_Ids
        //  in New_Node.

       func Dump_Node(FSA; Action_Node; Indent : Univ_Integer);

     new

       func Create(Action_Id) -> Action_Node;
         //  Create an action node with initial single Action Id

       func Add_Action(var Action_Node; Action_Id);
         // Add another action to the node

       func Action_Ids (Action_Node) -> Ordered_Set<Action_Id>;
        //  Action Ids of node.  

    end interface Action_Node;

    interface Ordered_Node
      <Val_Type is Imageable<>; Univ_Set : Range_Set<Val_Type>>
      extends Node<> is
       //  Extension of Node where value type is some (fully) ordered
       //  type such as integer, string, or float, and Univ_Set is the
       //  universal set for the given type.
       //  We go further and require it to be Imageable (which implies
       //  Comparable and Hashable), merely so Dump_FSA can work.
        
       func Create(optional Node_Id := null; optional Query_Id := null)
          -> Ordered_Node {Num_Successors(Create) == 0};
         //  Create an ordered node, initially with no successors

       func Add_Successor(var From : Ordered_Node; To : Node_Id)
         // Add an edge in the FSA, with a default value set of "Node_Univ_Set"

       func Is_Nondeterministic (Ordered_Node) -> Boolean;
        //  Return True if Node has outgoing edges with overlapping value sets

       func Disambiguate (N : Ordered_Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set>;
        //  Update node in FSA[Id(N)] so that each edge has a value set
        //  that is disjoint from the value sets of other edges.
        //  Create new Node_Ids for the new nodes that will
        //  be mergers of other nodes.
        //  Return a mapping from Node_Ids for the updated Node (both
        //  existing Node_Ids and Node_Ids created by Disambiguate) to
        //  the set of old Node_Ids whose nodes need to be merged to create
        //  the node to go with each Node_Id of the updated node.
        //  Note that the passed-in node is a read only copy of the original
        //  FSA[Id(N)]

       func Merge_Nodes
         (var New_Node : Ordered_Node; FSA; Nodes_To_Merge : Node_Set);
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.

       func Dump_Node(FSA; Ordered_Node; Indent : Univ_Integer);

     new

       func Add_Successor(var From : Ordered_Node; To : Node_Id;
         Values : Range_Set<Val_Type>)
         {Successor_Index(From', To) not null;
          Successor_Values(From', Successor_Index(From', To)) == Values};
         // Add an edge in the FSA

       func Successor_Values(From : Ordered_Node; Succ : Edge_Index)
         {Succ in 1 .. Num_Successors(From)}
         -> Range_Set<Val_Type>;
         //  Values associated with given successor

       func Set_Successor_Values
         (var From : Ordered_Node;
          Succ : Edge_Index;
          Values : Range_Set<Val_Type>)
         {Successor_Values(From', Succ) == Values};
         //  Set values associated with given successor
        
       func Create(optional Node_Id := null; optional Query_Id := null;
         Node_Univ_Set : Range_Set<Val_Type>)
          -> Ordered_Node {Num_Successors(Create) == 0};
         //  Create an ordered node, initially with no successors,
         //  with a restricted Univ_Set.

       func Set_Node_Univ_Set
         (var Ordered_Node; Node_Univ_Set : Range_Set<Val_Type>);
         //  Set Node_Univ_Set to a non-default value

       func Node_Univ_Set(Ordered_Node) -> Range_Set<Val_Type>;
         //  Universal set associated with Ordered_Node

    end interface Ordered_Node;

    interface Countable_Node
      <Val_Type is Countable<>; Univ_Set : Range_Set<Val_Type>>
      extends Ordered_Node<Val_Type, Univ_Set> is
       //  Same as ordered node, but takes advantage of fact
       //  that Val_Type is countable so no need for open interval bounds.

       func Disambiguate (N : Countable_Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set>;
       // Disambiguate and then remove open bounds from value sets

       func Add_Successor(var From : Countable_Node; To : Node_Id;
         Values : Range_Set<Val_Type>)
         {Successor_Index(From', To) not null;
          Successor_Values(From', Successor_Index(From', To)) == Values};
         // Add an edge in the FSA

       func Set_Successor_Values
         (var From : Countable_Node;
          Succ : Edge_Index;
          Values : Range_Set<Val_Type>)
         {Successor_Values(From', Succ) == Values};
         //  Set values associated with given successor
        
    end interface Countable_Node;

    func Create() -> FSA {Num_Nodes (Create) == 0};
      // Create an empty FSA

    op "[]"() -> FSA is Create;

    func Assign_Node_Id (var FSA) -> Node_Id
      {Num_Nodes (FSA') == Num_Nodes (FSA) + 1;
       Node_Is_Filled (FSA', Assign_Node_Id) == #false};
      //  Assign a new Node_Id for a node to be added to the given FSA

    func Node_Is_Filled (FSA; Node_Id)
      {Node_Id in 1 .. Num_Nodes (FSA)}
      -> Boolean
      //  Indicates whether node has been filled in.
      
    func Set_Node (var FSA; Node_Id; Node+);  // "for FSA"
      //  Fill in or replace node at given Node_Id

    func Add_Node(var FSA; Node+) -> Node_Id;
      //  Add a node to a FSA, and return its node id
      //  This is equivalent to Assign_Node_Id followed by Set_Node.

    op "in"(Node_Id; FSA) -> Boolean;
      // Return #true if Node_Id is in FSA

    op "indexing"(ref FSA; Node_Id) 
      {Node_Id in FSA}
      -> ref Node+;
      // Return a reference to a node of the FSA

    func Node_Range(FSA) -> Countable_Range<Node_Id>;
      // The range of node-ids in use in FSA

    func Set_Root(var FSA; Node_Id);

    func Root(FSA) -> optional Node_Id;

    func Dump_One_Node(FSA; Node_Id; Indent : Univ_Integer);
      // Produce a human-readable representation of the node, if any, with
      // given Node_Id, at given indent.
 
    func Dump_FSA(FSA) {Root(FSA) not null};
      // Produce a human-readable representation of the FSA

    func Is_Nondeterministic(FSA) -> Boolean;
      //  Return True if some node within the FSA is nondeterministic

    func Disambiguate_FSA(var FSA);
      //  Remove nondeterminism from FSA

end interface FSA;

class FSA is
  // Class defining the FSA module
    var Nodes : Vector<optional Node+> := [];
    var Action_Strings : Vector<Univ_String> := [];
    var Query_Formulae : Vector<Univ_String> := [];
    var Root_Node_Id : optional Node_Id := null;

  exports

    func Num_Nodes (FSA) -> Univ_Integer is (|FSA.Nodes|);
    //  Count of nodes within FSA

    func Add_Action_Id (var FSA; Action : Univ_String) -> Action_Id is
    //  Add a new Action_Id to the FSA
    //  Action is a string representing the action to be performed.
       FSA.Action_Strings |= Action;
       return |FSA.Action_Strings|;
    end func Add_Action_Id;

    func Add_Action_Node (var FSA; Action : Univ_String) -> Node_Id is
    //  Add a node that has one (new) action ID;
    //  Action is a string representing the action to be performed.
       const Act_Id := Add_Action_Id(FSA, Action);
       return Add_Node(FSA, Action_Node::Create(Act_Id));
    end func Add_Action_Node;

    func Action_String(FSA; Action_Id) -> Univ_String
      is (FSA.Action_Strings[Action_Id]);
      //  Return string representing action to be performed

    func Num_Actions (FSA) -> Univ_Integer is (|FSA.Action_Strings|);
    //  Count of end states ("action" nodes)

    func Add_Query_Id (var FSA; Formula : Univ_String) -> Query_Id is
    //  Add a new Query_Id to the FSA, representing the given Formula
       FSA.Query_Formulae |= Formula;
       return |FSA.Query_Formulae|;
    end func Add_Query_Id;

    func Num_Queries (FSA) -> Univ_Integer is (|FSA.Query_Formulae|);
    //  Count of distinct queries within FSA

    func Query_Formula (FSA; Query_Id) -> Univ_String
      is (FSA.Query_Formulae[Query_Id]);
    //  Return query formula
    
    class Node<> is

        var Id : optional Node_Id := null;
        var Q_Id : optional Query_Id := null;
        var Successors : Vector<Node_Id> := [];

      exports
        func Create(optional Node_Id; optional Query_Id) -> Node
          is (Id => Node_Id, Q_Id => Query_Id);
        //  Create a node with given node id and query id.

        func Set_Id (var Node; Node_Id) is
        //  Fill in the Node_Id; might already have a value
           Node.Id := Node_Id;
        end func Set_Id;

        func Id (Node) -> optional Node_Id is (Node.Id);
        //  Unique Node_Id for node within FSA
        //  This is null for a "template" node

        func Query (Node) -> optional Query_Id is (Node.Q_Id);
        //  Identifies which query this node is performing
        //  This is null for an action node/end state

        func Add_Successor(var From : Node; To : Node_Id)
         // Add an edge in the FSA
        is
            From.Successors |= To;
        end func Add_Successor;

        func Num_Successors (Node) -> Edge_Index is (|Node.Successors|);
        //  Number of successor nodes.
        //  Will be zero for an end state.

        func Successor (Node; Index : Edge_Index)
          {Index <= Num_Successors (Node)}
          -> Node_Id is (Node.Successors[Index]);
        //  Return Node_Id for given successor

        func Successor_Index (From : Node; To : Node_Id)
          -> optional Edge_Index is
        //  Return non-null Edge_Index if To is a successor of From.
            for Index in From.Successors.Bounds() loop
               if From.Successors [Index] == To then
                  return Index;
               end if;
            end loop;
            return null;
        end func Successor_Index;

        func Dump_Node(FSA; Node; Indent : Univ_Integer) is
           const Ind := Indent * " ";
           Println(Ind | "Node: `(Id(Node)), " |
                   "Query: `(Query_Formula(FSA, Query(Node)))");
           for Succ_Ix in 1 .. Num_Successors(Node) forward loop
              Dump_One_Node(FSA, Successor(Node, Succ_Ix), Indent + 2);
           end loop;
        end func Dump_Node;
    end class Node;

    class Action_Node is
      //  End state of FSA contains a set of actions

       var Actions : Ordered_Set<Action_Id> := [];

       func Plural(Univ_Integer) -> Univ_String
         is (Univ_Integer != 1? "s": "");
     exports

       func Create(optional Node_Id := null; optional Query_Id := null)
         -> Action_Node is (Node => Create(Node_Id, Query_Id));
        //  Must override inherited constructors.

       func Merge_Nodes
         (var New_Node : Action_Node; FSA; Nodes_To_Merge : Node_Set)
       is
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
        //  If New_Node is an Action_Node, then just include their Action_Ids
        //  in New_Node.
          if Debug then
             Println(" In Merge_Nodes for Action Node `(Id(New_Node))");
             Println("  Nodes_To_Merge:" |
               (for each N_Id of Nodes_To_Merge forward =>
                  <""> | " " | N_Id));
          end if;

          for each N_Id of Nodes_To_Merge loop
             case FSA[N_Id] of
              [A : Action_Node] =>
                New_Node.Actions |= A.Actions;
              [N : Node+] =>
                {*"Cannot merge non-action into Action node"* #false}
                null;
             end case;
          end loop;
       end func Merge_Nodes;

       func Dump_Node(FSA; A : Action_Node; Indent : Univ_Integer) is
          const Ind := Indent * " ";
          Println(Ind | "Node: `(Id(A)), Action`(Plural(|A.Actions|)):" |
            (for (each Act of A.Actions; Sep := " " then ", ")
              forward => <""> | Sep | "`(Action_String(FSA, Act))"));
       end func Dump_Node;

     new

       func Create(Action_Id) -> Action_Node is
         //  Create an action node with initial single Action Id
          return (Node => Create(), Actions => [Action_Id]);
       end func Create;

       func Add_Action(var Action_Node; Action_Id) is
         // Add another action to the node
          Action_Node.Actions |= Action_Id;
       end func Add_Action;

       func Action_Ids (Action_Node) -> Ordered_Set<Action_Id>
         is (Action_Node.Actions);
        //  Action Ids of node.  

    end class Action_Node;

    class Ordered_Node is
       //  Extension of Node where value type is some countable
       //  type such as an integer or an enumeration type.

        var Edge_Value_Sets : Vector<Range_Set<Val_Type>> := [];
          //  Value set associated with each outgoing edge

        var Node_Univ_Set : Range_Set<Val_Type> := Univ_Set;

        interface Interval_And_Edge<> is
           const Ival : Interval<Val_Type>;
           const Edge : Edge_Index;

           func Strict_Compare(Left, Right : Interval_And_Edge)
             -> Ordered::Full_Ordering
             is ((Strict_Compare(Left.Ival, Right.Ival) != #equal?
                     Strict_Compare(Left.Ival, Right.Ival) :
                     Left.Edge =? Right.Edge));
           op "=?"(Left, Right : Interval_And_Edge) -> Ordering
             is (Strict_Compare(Left, Right));
        end interface Interval_And_Edge;

        interface High_Bound_And_Edge<> is
          //  Used for seeing the order in which an active interval ends.
           const High : Val_Type;
           const High_Is_Open : Boolean;
           const Edge : Edge_Index;

           func Strict_Compare(Left, Right : High_Bound_And_Edge)
             -> Ordered::Full_Ordering
             is ((if Left.High != Right.High then
                    Left.High =? Right.High
                  elsif Left.High_Is_Open != Right.High_Is_Open then
                    Right.High_Is_Open =? Left.High_Is_Open  // inverted
                  else Left.Edge =? Right.Edge));
           op "=?"(Left, Right : High_Bound_And_Edge) -> Ordering
              is (Strict_Compare(Left, Right));
        end interface High_Bound_And_Edge;

        func Interval_Set(Ordered_Node)
          -> Result : Ordered_Set<Interval_And_Edge> is
          //  Set of intervals and associated edges, ordered
          //  by low bound of interval (and edge if necessary to break
          //  a tie).
           Result := [];
           for Edge in Ordered_Node.Edge_Value_Sets.Bounds() loop
              for each Ival of Ordered_Node.Edge_Value_Sets[Edge] loop
                 Result |= Interval_And_Edge::(Ival => Ival, Edge => Edge);
              end loop;
           end loop;

           if Debug then
              Println("Set of intervals for edges from Node " |
                "`(Id(Ordered_Node)):");
              for each IE of Result forward loop
                 Println("  `(IE.Ival.Low_Is_Open? "(" : "[")`(IE.Ival.Low)" |
                  "..`(IE.Ival.High)`(IE.Ival.High_Is_Open? ")" : "]") -- " |
                  IE.Edge | ", Node `(Successor(Ordered_Node, IE.Edge))");
              end loop;
           end if;
        end func Interval_Set;
        
        interface Value_Set_And_Edge<> is
           var Val_Set : Range_Set<Val_Type>;
           const Edge : Edge_Index;
        end interface Value_Set_And_Edge;

        func Dump_Range_Set (Vals : Range_Set<Val_Type>) is
           for (each Ival of Vals; Sep := "" then " | ") forward loop
              if Ival.Low == Ival.High
                and then not Ival.Low_Is_Open
                and then not Ival.High_Is_Open
              then
                 Print(Sep | "[`(Ival.Low)]");
              else
                 Print(Sep | (Ival.Low_Is_Open? "(" : "[") | Ival.Low |
                   ".." | Ival.High | (Ival.High_Is_Open? ")" : "]"));
              end if;
           end loop;
        end func Dump_Range_Set;

      exports

        func Create(optional Node_Id := null; optional Query_Id := null)
          -> Ordered_Node
         //  Create an ordered node, initially with no successors
          is (Node => Create(Node_Id, Query_Id));

        func Add_Successor(var From : Ordered_Node; To : Node_Id)
         // Add an edge in the FSA, with a default value set of "Node_Univ_Set"
        is
            Add_Successor(From.Node, To);
            //  Provide a default for the edge value set
            From.Edge_Value_Sets |= Node_Univ_Set(From);
        end func Add_Successor;

        func Is_Nondeterministic (Ordered_Node) -> Boolean is
        //  Return True if Node has outgoing edges with overlapping value sets

           //  Look at the set of intervals associated with each edge,
           //  ordered by low bound of each interval making up a range
           //  set for a given edge.  If there is an overlap between
           //  two successive intervals, then the node is nondeterministic.

           var Prior_IE : optional Interval_And_Edge := null;
           const Ival_Set := Ordered_Node.Interval_Set();

           for each Next_IE of Ival_Set forward loop
              if Prior_IE not null
                and then Overlaps (Next_IE.Ival, Prior_IE.Ival)
              then
                 return #true;
              end if;
              Prior_IE := Next_IE;
           end loop;

           return #false;
        end func Is_Nondeterministic;

        func Disambiguate (N : Ordered_Node; var FSA)
          -> Result : Ordered_Map<Node_Id, Node_Set> is
        //  Update node in FSA[Id(N)] so that each edge has a value set
        //  that is disjoint from the value sets of other edges.
        //  Create new Node_Ids for the new nodes that will
        //  be mergers of other nodes.
        //  Return a mapping from Node_Ids for the updated Node (both
        //  existing Node_Ids and Node_Ids created by Disambiguate) to
        //  the set of old Node_Ids whose nodes need to be merged to create
        //  the node to go with each Node_Id of the updated node.
        //  Note that the passed-in node is a read only copy of the original
        //  FSA[Id(N)]
           var Updated_Node : Ordered_Node :=
             Create(Node_Id => Id(N), Query_Id => Query(N));
              //  TBD: It would be good if we could set the Node_Univ_Set

           var Edge_Combos : Ordered_Set
                <Countable_Set<Edge_Index>> := [];
             //  Unique combinations of edges that all share some of the
             //  same values.

           var Edge_Val_Mapping :
             Ordered_Map<Countable_Set<Node_Id>,
                         Value_Set_And_Edge> := [];
           //  Mapping from the Node_Ids that are being combined
           //  to produce a new node.

           var Active_Combo : Countable_Set<Edge_Index> := [];
             //  Edges associated with active intervals during iteration.

           func Remember_Combos
             (Finished_Intervals : Ordered_Set<Interval_And_Edge>) is
             //  Remember the active combo as an "interesting" combo,
             //  as well as combos of intervals that are ending.

              if Debug then
                 Println("Remember_Combos");
              end if;

              if |Active_Combo| > 0 then
                 //  Active combo has at least one value unique to it
                 if Debug then
                    Println(" Adding full Active_Combo to Edge_Combos:" |
                      (for each Edge of Active_Combo forward =>
                         <""> | " " | Edge) | ", Nodes:" |
                      (for each Edge of Active_Combo forward =>
                         <""> | " " | Successor(N, Edge)));
                 end if;

                 Edge_Combos |= Active_Combo;
                 if Debug then
                    Println(" |Edge_Combos| = `(|Edge_Combos|)");
                 end if;
              end if;

              //  Now look at intervals that have ended to see whether
              //  there are unique combos to be remembered.
              if |Finished_Intervals| > 0 then
                 var Finished_High_Bounds : Ordered_Set<High_Bound_And_Edge>
                   := [];

                 for each Finished_IE of Finished_Intervals loop
                    Finished_High_Bounds |=
                      (Finished_IE.Ival.High,
                       Finished_IE.Ival.High_Is_Open,
                       Finished_IE.Edge);
                 end loop;

                 var Prior_HB : optional High_Bound_And_Edge := null;
                 for each Finished_HB of Finished_High_Bounds forward loop
                    if Prior_HB not null
                      and then
                       (Finished_HB.High != Prior_HB.High
                         or else
                        Finished_HB.High_Is_Open != Prior_HB.High_Is_Open)
                    then
                       //  Finished is later, so the combo of this edge
                       //  plus any edges with later high bounds
                       //  is "interesting".
                       if Debug then
                          Println(" Adding to Edge_Combos:" |
                            (for each Edge of Active_Combo forward =>
                               <""> | " " | Edge) | ", Nodes:" |
                            (for each Edge of Active_Combo forward =>
                               <""> | " " | Successor(N, Edge)));
                       end if;

                       Edge_Combos |= Active_Combo;
                       if Debug then
                          Println(" |Edge_Combos| = `(|Edge_Combos|)");
                       end if;
                    end if;
                    Active_Combo -= Finished_HB.Edge;

                    //  Remember prior HB for next iteration
                    Prior_HB := Finished_HB;
                 end loop;
              end if;
           end func Remember_Combos;

           //  Look at the set of intervals associated with each edge,
           //  ordered by low bound of each interval making up a range
           //  set for a given edge.  We keep track of intervals that
           //  are "active" as we go through the iteration to determine
           //  what are the overlaps.

           var Active_Intervals : Ordered_Set<Interval_And_Edge> := [];
             //  Intervals that are still "active" as we iterate through
             //  the set of all intervals used in edge value sets.

           for each Next_IE of N.Interval_Set() forward loop
              var Finished_Intervals : Ordered_Set<Interval_And_Edge> := [];

              var Next_IE_Starts_Later : Boolean := #true;

              for each Active_IE of Active_Intervals loop
                 if Active_IE.Ival.Low == Next_IE.Ival.Low
                      and then
                    Active_IE.Ival.Low_Is_Open == Next_IE.Ival.Low_Is_Open
                 then
                    //  Same starting point as at least one of the
                    //  active intervals, so can just add to existing combo
                    Next_IE_Starts_Later := #false;
                 elsif not Overlaps (Active_IE.Ival, Next_IE.Ival) then
                    //  We can finish Active_IE, since it ends before Next_IE
                    //  begins.
                    Finished_Intervals += Active_IE;
                 end if;
              end loop;

              if not Next_IE_Starts_Later then
                 //  Next_IE starts at same point as at least one of
                 //  the active intervals.

                 {*"No intervals should be ending"* |Finished_Intervals| == 0}

              else
                 //  Active combo has at least one value unique to it
                 //  Remember it, as well as combos of intervals that
                 //  are ending.
                 Remember_Combos(Finished_Intervals);

                 //  Remove intervals that have finished
                 Active_Intervals -= Finished_Intervals;
              end if;

              //  Add Next_IE to set of active intervals
              Active_Intervals += Next_IE;
              Active_Combo += Next_IE.Edge;
           end loop;

           //  Reached end of intervals, remember interesting combos
           Remember_Combos(Active_Intervals);

           if Debug then
              Println("Edge combos for Node `(Id(N)):");
              for each Combo of Edge_Combos loop
                 Println((for Edge in Combo forward => <""> | " " | Edge) |
                   ", Nodes:" |
                   (for Edge in Combo forward => <""> | " " |
                      Successor(N, Edge)));
              end loop;
           end if;

           //  Convert set of interesting combos into desired mapping.

           //  Initialize the result mapping
           Result := [];

           for each Combo of Edge_Combos loop
              var New_Node_Id : Node_Id;

              if |Combo| == 1 then
                 //  This successor node should remain, though its value
                 //  set might shrink.
                 New_Node_Id := Successor(N, Any_Element(Combo));
              else
                 //  Assign a new Node_Id
                 New_Node_Id := Assign_Node_Id(FSA);
              end if;

              // Convert to a set of node ids
              const Old_Node_Set : Node_Set :=
                (for Edge in Combo => <[]> | Successor(N, Edge));

              //  Add a mapping to the set of old nodes from the edge combo
              Result |= [New_Node_Id => Old_Node_Set];

              // Compute intersection of value sets for the combined edges
              const Edge_Val_Intersection : Range_Set<Val_Type> :=
                (for Edge in Combo =>
                   <Node_Univ_Set(N)> and Successor_Values(N, Edge));

              if Debug then
                 Println("Node `(New_Node_Id) has Edge Combo:" |
                   (for Edge in Combo => <""> | " " | Edge) | ", Nodes:" |
                   (for N_Id in Old_Node_Set => <""> | " " | N_Id));
                 Print(" Intersection of values is:");
                 Dump_Range_Set(Edge_Val_Intersection);
                 Println("");
              end if;

              //  Add successor
              Add_Successor (Updated_Node, New_Node_Id);
              const New_Edge : Edge_Index := |Num_Successors(Updated_Node)|;

              Edge_Val_Mapping[Old_Node_Set] :=
                (Edge => New_Edge, Val_Set => Edge_Val_Intersection);
              
           end loop;

           //  Now remove values for a combo of nodes from all proper subsets
           for each [Old_Node_Set => Val_And_Edge] of Edge_Val_Mapping
             reverse loop
              //  Remove value set from subsets
              //  Convert to array of Node Ids

              const Elems : Vector<Node_Id> :=
                [for each N_Id of Old_Node_Set forward => N_Id];

              if Debug then
                 Println("Combo of nodes:" |
                   (for each N_Id of Elems forward => <""> | " " | N_Id));
              end if;

              //  Iterate over all proper subsets
              for Mask in 1 .. Unsigned_64::(2**|Elems|-2) forward loop
                 var Subset : Node_Set := [];

                 //  Build up a proper subset
                 for I in 0 ..< |Elems| {(Mask and 2**I) != 0} loop
                    Subset |= Elems[I+1];
                 end loop;

                 if Debug then
                    Println(" Subset of combo for Mask `(Mask):" |
                      (for each N_Id of Subset forward => <""> | " " | N_Id));
                 end if;

                 //  If the subset appeared in Old_Node_Set, then
                 //  remove values of this superset from this subset.
                 if Subset in Edge_Val_Mapping then
                    if Debug then
                       Println("  Subset is in Edge_Val_Mapping");
                    end if;
                    Edge_Val_Mapping[Subset].Val_Set -=
                      Val_And_Edge.Val_Set;
                 end if;
              end loop;
           end loop;

           //  Now copy the value sets onto the edges
           for each Val_And_Edge of Edge_Val_Mapping loop
              Set_Successor_Values
                (Updated_Node, Val_And_Edge.Edge, Val_And_Edge.Val_Set);
           end loop;

           //  Replace old node with updated node
           Set_Node(FSA, Id(N), Updated_Node);
        end func Disambiguate;

        func Merge_Nodes
          (var New_Node : Ordered_Node; FSA; Nodes_To_Merge : Node_Set) is
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
           const Q_Id := Query(New_Node);

           if Debug then
              Println(" In Merge_Nodes for Node `(Id(New_Node)), " |
                "Query `(Query_Formula(FSA, Q_Id))");
              Println("  Nodes_To_Merge:" |
                (for each N_Id of Nodes_To_Merge forward =>
                   <""> | " " | N_Id));
           end if;

           for each O_Id of Nodes_To_Merge loop
              ref Old_Node => FSA[O_Id];
              const Old_Q_Id := Query(Old_Node);

              if Old_Q_Id not null
                and then Old_Q_Id == Q_Id
              then
                 //  Query Id matches, check type
                 case Old_Node of
                  [O : Ordered_Node] =>
                    //  Type matches as well.  Carry over its successors.
                    if Debug then
                       Println("Old Ordered Node `(O_Id) being merged in");
                    end if;
                    for Succ in 1 .. Num_Successors(O) loop
                       if Debug then
                          Println(" Adding edge to `(Successor(O, Succ))");
                       end if;
                       New_Node.Add_Successor
                         (To => Successor(O, Succ),
                          Values => Successor_Values(O, Succ));
                    end loop;

                    //  Loop around to handle next old node
                    continue loop;

                  [N : Node+] =>
                    //  Different type, treat as though query doesn't match
                    null;  
                 end case;
              end if;

              //  Create unconditional edge to existing node
              if Debug then
                 Println(" Old Node `(O_Id) has different type/query");
                 Println("  Creating unconditional edge to old node");
              end if;
              New_Node.Add_Successor
                (To => O_Id,
                 Values => Node_Univ_Set(New_Node));
           end loop;
        end func Merge_Nodes;

        func Dump_Node(FSA; N : Ordered_Node; Indent : Univ_Integer) is
           const Ind := Indent * " ";

           Println(Ind | "Node: `(Id(N))");
           for Succ_Ix in 1 .. Num_Successors(N) forward loop
              const Vals := N.Successor_Values(Succ_Ix);

              Print(Ind | " `(Query_Formula(FSA, Query(N))) in ");
              Dump_Range_Set(Vals);
              Println (" =>");
              Dump_One_Node(FSA, N.Successor(Succ_Ix), Indent + 2);
           end loop;
        end func Dump_Node;

     new

        func Add_Successor(var From : Ordered_Node; To : Node_Id;
          Values : Range_Set<Val_Type>)
          // {Successor_Index(From', To) not null;
          //  Successor_Values(From', Successor_Index(From', To)) == Values}
          // Add an edge in the FSA
        is
           //  At this point, should have one value set per successor
           {Num_Successors(From) == |From.Edge_Value_Sets|}

           From.Node.Add_Successor (To);
           From.Edge_Value_Sets |= Values;
        end func Add_Successor;

        func Successor_Values(From : Ordered_Node; Succ : Edge_Index)
          {Succ in 1 .. Num_Successors(From)}
          -> Range_Set<Val_Type> is
          //  Values associated with given successor
           return From.Edge_Value_Sets[Succ];
        end func Successor_Values;

        func Set_Successor_Values
          (var From : Ordered_Node;
           Succ : Edge_Index;
           Values : Range_Set<Val_Type>)
          //  Set values associated with given successor
        is
           From.Edge_Value_Sets[Succ] := Values;
        end func Set_Successor_Values;

        func Create(optional Node_Id := null; optional Query_Id := null;
          Node_Univ_Set : Range_Set<Val_Type>)
           -> Ordered_Node
          //  Create an ordered node, initially with no successors,
          //  with a restricted Univ_Set.
          is (Node => Create(Node_Id, Query_Id),
              Node_Univ_Set => Node_Univ_Set);

        func Set_Node_Univ_Set
          (var Ordered_Node; Node_Univ_Set : Range_Set<Val_Type>) is
          //  Set Node_Univ_Set to a non-default value
           Ordered_Node.Node_Univ_Set := Node_Univ_Set;
        end func Set_Node_Univ_Set;

        func Node_Univ_Set(Ordered_Node) -> Range_Set<Val_Type>
          //  Universal set associated with Ordered_Node
          is (Ordered_Node.Node_Univ_Set);

    end class Ordered_Node;

    class Countable_Node is
       //  Same as ordered node, but takes advantage of fact
       //  that Val_Type is countable so no need for open interval bounds.

       func Close_Bounds (Range_Set<Val_Type>)
         -> Result : Range_Set<Val_Type>
          //  Close any open intervals by adjusting bound up/down
       is
          Result := [];
          for Ival in Range_Set loop
             var Closed_Ival for Result := Ival;

             //  Close either side of interval that is open
             if Closed_Ival.Low_Is_Open then
                Closed_Ival.Low_Is_Open := #false;
                Closed_Ival.Low += 1;
             end if;

             if Closed_Ival.High_Is_Open then
                Closed_Ival.High_Is_Open := #false;
                Closed_Ival.High -= 1;
             end if;

             //  Add closed interval into result
             Add_Interval (Result, Closed_Ival);
          end loop;
       end func Close_Bounds;

       type Ordered_Base is Ordered_Node<Val_Type, Univ_Set>;

     exports

       func Add_Successor(var From : Countable_Node; To : Node_Id;
         Values : Range_Set<Val_Type>) is
         // Add an edge in the FSA
          Add_Successor(From.Ordered_Node, To, Close_Bounds(Values));
       end func Add_Successor

       func Set_Successor_Values
         (var From : Countable_Node;
          Succ : Edge_Index;
          Values : Range_Set<Val_Type>) is
         //  Set values associated with given successor
          Set_Successor_Values (From.Ordered_Node, Succ, Close_Bounds(Values));
       end func Set_Successor_Values
        
       func Disambiguate (N : Countable_Node; var FSA)
          -> Result : Ordered_Map<Node_Id, Node_Set> is
       // Disambiguate and then remove open bounds from value sets

          Result := Disambiguate (N.Ordered_Node, FSA);

          case FSA[Id(N)] of
            [Updated : Ordered_Base] =>

              // Close bounds of all intervals in value sets of all edges
              for Edge in 1 .. Num_Successors(Updated) loop
                 const Vals := Successor_Values(Updated, Edge);
                 Set_Successor_Values(Updated, Edge, Close_Bounds(Vals));
              end loop;

              // Update FSA node
              // Build a Countable_Node with same content as ordered node
              var C : Countable_Node := (Ordered_Node => Updated);
              Set_Id (C, Id(N));

              Set_Node(FSA, Id(N), C);

            [X : Node+] =>
               {*"Expecting Ordered_Node"* #false}
          end case;
       end func Disambiguate;

    end class Countable_Node;

    func Create() -> FSA is
      // Create an empty FSA
       return ();
    end func Create;

    func Assign_Node_Id (var FSA) -> Result : Node_Id is
      //  Assign a new Node_Id for a node to be added to the given FSA
       const N : optional Node+ := null;
       FSA.Nodes |= N;
       Result := |FSA.Nodes|;
    end func Assign_Node_Id;

    func Node_Is_Filled (FSA; Node_Id)
      -> Boolean is (FSA.Nodes[Node_Id] not null);
      //  Indicates whether node has been filled in.
      
    func Set_Node (var FSA; Node_Id; Node+) is  //  for FSA
      //  Fill in or replace node at given Node_Id
       FSA.Nodes[Node_Id] := Node;
       if Id(Node) is null then
          //  Fill in Id of node if null
          Set_Id (FSA.Nodes[Node_Id], Node_Id);
       else
          //  Node Id should already match
          {Id(Node) == Node_Id}
       end if;
    end func Set_Node;

    func Add_Node(var FSA; Node+) -> Result : Node_Id is
      // Add a node to a FSA, and return its node id
       FSA.Nodes |= Node;
       Result := |FSA.Nodes|;
       Set_Id (FSA.Nodes[Result], Result);
    end func Add_Node;

    op "in"(Node_Id; FSA) -> Boolean is (Node_Id in 1 .. |FSA.Nodes|);
      // Return #true if Node_Id is in FSA

    op "indexing"(ref FSA; Node_Id) 
      {Node_Id in FSA}
      -> ref Node+ is (FSA.Nodes[Node_Id]);
      // Return a reference to a node of the FSA

    func Node_Range(FSA) -> Countable_Range<Node_Id> is (1 .. |FSA.Nodes|);
      // The range of node-ids in use in FSA

    func Set_Root(var FSA; Node_Id) is
       FSA.Root_Node_Id := Node_Id;
    end func Set_Root;

    func Root(FSA) -> optional Node_Id is (FSA.Root_Node_Id);
 
    func Dump_One_Node(FSA; Node_Id; Indent : Univ_Integer) is
       if not FSA.Node_Is_Filled(Node_Id) then
          Println(Indent * " " | "Node: `(Node_Id) not filled in yet");
       else
          Dump_Node(FSA, FSA[Node_Id], Indent);
       end if;
    end func Dump_One_Node;

    func Dump_FSA(FSA) is
      // Produce a human-readable representation of the FSA
       Dump_One_Node(FSA, FSA.Root(), Indent => 0);
    end func Dump_FSA;

    func Is_Nondeterministic(FSA) -> Boolean is
      //  Return True if some node within the FSA is nondeterministic
       func Subtree_Is_Nondeterministic(Tree_Root : Node_Id) -> Boolean is
          ref Tree => FSA[Tree_Root];

          if Is_Nondeterministic(Tree) then
             //  Root of subtree is nondeterministic
             return #true;
          else
             //  Check each successor
             return (for some Succ in 1 .. Num_Successors(Tree) =>
                       Subtree_Is_Nondeterministic(Successor(Tree, Succ)));
          end if;
       end func Subtree_Is_Nondeterministic;

       return Subtree_Is_Nondeterministic (Root (FSA));
    end func Is_Nondeterministic;

    func Disambiguate_FSA(var FSA) is
      //  Remove nondeterminism from FSA for all but Action_Nodes

       func Disambiguate_Subtree(Tree_Root : Node_Id) is
          //  NOTE: Do not want to create a "ref" to FSA[Tree_Root] here
          //        as it should be treated as a long-lived R/W alias,
          //        which can cause trouble if the FSA vector is re-shaped
          //  TBD:  Fix ParaSail analyzer so it detects this problem.

          if Debug then
             Println("Node in Disambiguate_Subtree:");
             Dump_One_Node(FSA, Tree_Root, Indent => 2);
          end if;

          const Tree_Copy := FSA[Tree_Root];  //  Make copy to avoid aliasing

          const Remap : Ordered_Map<Node_Id, Node_Set> :=
                         Disambiguate(Tree_Copy, FSA);
            //  Map from each successor of updated Root
            //  to set of Node_Ids of old successors of Tree_Root
            //  that should be merged to produce new successor.
            //  If old successor set is a singleton, then that implies
            //  there was no change for that successor, other than a
            //  possible narrowing of its associated value set.
            //  If old successor set has multiple Node_Ids, then
            //  the (new) successor has a new Node_Id, that has not
            //  been filled in yet.

          for each [New_Node_Id => Old_Nodes] of Remap loop
             if |Old_Nodes| == 1 then
                //  Only one node in new successor, so should be same
                //  as original successor.
                {New_Node_Id in Old_Nodes}

                if Debug then
                   Println("Node survives into DFA:");
                   Dump_One_Node(FSA, New_Node_Id, Indent => 2);
                end if;

                null;  //  Nothing to be done.
             else
                //  Multiple nodes, implies New_Node_Id is really new
                {New_Node_Id not in Old_Nodes;
                 not Node_Is_Filled(FSA, New_Node_Id)}

                //  Determine which Query Id
                var Old_Node_To_Clone : optional Node_Id := null;
                var Earliest_Query : optional Query_Id := null;
                for each O_Id of Old_Nodes forward loop
                   const Old_Q := Query(FSA[O_Id]);

                   if Earliest_Query is null
                     or else
                      (Old_Q not null and then Old_Q < Earliest_Query)
                   then
                      Earliest_Query := Old_Q;
                      Old_Node_To_Clone := O_Id;
                   end if;
                end loop;

                //  Make a new node, using the old node with the earliest
                //  query.
                var New_Node := FSA[Old_Node_To_Clone];

                //  Set Node_Id to new value.
                Set_Id (New_Node, New_Node_Id);
                
                //  Now fill in node at New_Node_Id
                Set_Node(FSA, New_Node_Id, New_Node);

                if Debug then
                   Println
                     ("New node in DFA based on Node `(Old_Node_To_Clone):");
                   Dump_One_Node(FSA, New_Node_Id, Indent => 2);
                end if;

                //  Merge in other old nodes
                Merge_Nodes
                  (FSA[New_Node_Id], FSA, Old_Nodes - Old_Node_To_Clone);

                if Debug then
                   Println("New node in DFA after merge:");
                   Dump_One_Node(FSA, New_Node_Id, Indent => 2);
                end if;

             end if;
          end loop;

          //  Now recurse to disambiguate sub-subtrees
          for Edge in 1 .. Num_Successors(FSA[Tree_Root]) loop
             Disambiguate_Subtree(Successor(FSA[Tree_Root], Edge));
          end loop;
       end func Disambiguate_Subtree;

       Disambiguate_Subtree(Root(FSA));
    end func Disambiguate_FSA;

end class FSA;

func Test_FSA() is

   type Int_Node is
     FSA::Countable_Node
       <Integer, Univ_Set => 1..3>;

   var FSA1 := FSA::Create();

   const Query_X := FSA1.Add_Query_Id("X");
   const Query_Y := FSA1.Add_Query_Id("Y");

   const Action_A := FSA1.Add_Action_Node("A");
   var Y_Eq_2 := Int_Node::Create(Query_Id => Query_Y);
   Y_Eq_2.Add_Successor (To => Action_A, Values => 2..2);
   const Y_Eq_2_Id := FSA1.Add_Node(Y_Eq_2);

   const Action_B := FSA1.Add_Action_Node("B");
   var Y_In_2_3 := Int_Node::Create(Query_Id => Query_Y);
   Y_In_2_3.Add_Successor (To => Action_B, Values => 2..3);
   const Y_In_2_3_Id := FSA1.Add_Node(Y_In_2_3);

   const Action_C := FSA1.Add_Action_Node("C");
   var Y_In_1_2 := Int_Node::Create(Query_Id => Query_Y);
   Y_In_1_2.Add_Successor (To => Action_C, Values => 1..2);
   const Y_In_1_2_Id := FSA1.Add_Node(Y_In_1_2);

   const Action_E := FSA1.Add_Action_Node("E");

   var X_Test := Int_Node::Create(Query_Id => Query_X);
   X_Test.Add_Successor (To => Y_Eq_2_Id, Values => 2..2);
   X_Test.Add_Successor (To => Y_In_2_3_Id, Values => 1..2);
   X_Test.Add_Successor (To => Y_In_1_2_Id, Values => 2..3);
   X_Test.Add_Successor (To => Action_E, Values => 1..3);
   const X_Test_Id := FSA1.Add_Node(X_Test);

   FSA1.Set_Root(X_Test_Id);

   Dump_FSA(FSA1);

   Println("FSA is `(Is_Nondeterministic(FSA1)? "non": "")deterministic");
   Println("\nAbout to disambiguate\n");
   Disambiguate_FSA(FSA1);

   Println
     ("Now, FSA is `(Is_Nondeterministic(FSA1)? "non": "")deterministic");

   Println("Dump of disambiguated FSA");
   Dump_FSA(FSA1);
end func Test_FSA;
