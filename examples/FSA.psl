// Example ParaSail program -- Finite State Automaton module

// Copyright (C) 2023, AdaCore, New York, NY
// This program is provided "as is" with no warranty.
// Report errors: http://groups.google.com/group/parasail-programming-language

interface FSA<> is
  // Interface to a Finite State Automaton module
  // The FSA can be either nondeterministic (NFA) or deterministic (DFA)
  // Each state in the FSA is represented by a node
  // Each possible transition is represented by an edge

  // There is one start state, and any number of end states.
  // Each non-end-state is labeled by a Query ID, and each edge is labeled
  // by a value set the associated node's query must satisfy for the
  // transition to be allowed.
  // Each end state is labeled by a set of Action IDs.
  // Action IDs are fully ordered.

  // A value set must be of a type that implements an interface that supports
  // union, intersection, is_subset, is_equal, empty set, univ set, invert set.

  // A Query ID can have a prerequisite, which is that some other Query ID
  // is within a specified value set.  Query IDs are fully ordered
  // consistent with a requirement that any Query ID with a prerequisite
  // comes after the prerequisite's Query ID in this order.
  // Nodes along a path from the start state to any end state have Query IDs
  // that monotonically increase in this Query ID order.
  // Note: This requirement simplifies translating an NFA to a DFA.

  // A check is made that a node with a Query ID that has a prerequisite is
  // only reachable via some state labeled with the prerequisite Query ID
  // along an outgoing edge that specifies a value set that is a subset of
  // that specified in the prerequisite.
  // Note: The prerequisite notion is to support the notion of
  //       "variant record" like structures.  It turns out it is not
  //       directly relevant to other checks that can be performed as
  //       part of the conversion from NFA to DFA, such as nonambiguity,
  //       exhaustiveness, or nonredundancy.

  // If a Query ID does not appear along a path from the start state to
  // an end state, it can be assumed to be a "don't care" query, where any
  // value is acceptable (or the Query ID is not permitted because its
  // prerequisite is not satisfied).

  // An FSA can be tested to see whether it is deterministic by checking
  // that at each state, the various edges are labeled by non-overlapping
  // value sets, and every end state has exactly one Action ID.

    type Node_Id is new Integer<0..10**6>;
      // A unique id for each node in the FSA

    type Node_Set is Countable_Set<Node_Id>;
      // A set of nodes

    type Query_Id is new Integer<0..10**6>;
      // A unique id for each distinct query that is performed

    const Others_Branching_Query_Id : Query_Id := Query_Id::Last();
      // Query Id for a "others" branching node
      // Give it the maximum Query_Id value so it sorts last
      // when looking for the lowest Query_Id when disambiguating.

    const Branching_Query_Id : Query_Id := Query_Id::Last() - 1;
      // Give "normal" branching nodes a Query_Id that sorts
      // after all non-branching nodes, but before an "others" branching node.

    type Action_Id is new Integer<0..10**6>;
      // A unique id for each distinct action in the FSA

    func Num_Nodes (FSA) -> Univ_Integer;
    //  Count of nodes within FSA

    func Add_Action_Id (var FSA; Action : Univ_String) -> Action_Id;
    //  Add a new Action_Id to the FSA
    //  Action is a string representing the action to be performed.

    func Add_Action_Node (var FSA; Action : Univ_String) -> Node_Id;
    //  Add a node that has one (new) action ID;
    //  Action is a string representing the action to be performed.

    func Num_Actions (FSA) -> Action_Id;
    //  Count of distinct actions

    func Action_String(FSA; Action_Id) -> Univ_String;
      //  Return string representing action to be performed

    func Add_Query_Id (var FSA; Formula : Univ_String) -> Query_Id;
    //  Add a new Query_Id to the FSA, representing the given Formula

    func Num_Queries (FSA) -> Univ_Integer;
    //  Count of distinct queries within FSA

    func Query_Formula (FSA; Query_Id) -> Univ_String;
    //  Return query formula

    type Edge_Count is new Integer<0..10**6>;
    type Edge_Index is Edge_Count {Edge_Index >= 1};

    interface Node<> is
      //  The FSA is a graph of Nodes, each representing a state in the
      //  automaton.  Each Node has a Node_Id, a set of Action_Ids
      //  if it is an end state, or a Query_Id if it is not an end state.
      //  Each edge to a successor of a non-end state is labeled by
      //  the set of values produced by the associated Query that lead
      //  to that successor.  The node is non-deterministic if any two
      //  edges are labeled with overlapping value sets.

        func Create(optional Node_Id := null; optional Query_Id := null)
          -> Node;
        //  Create a node with given node id and query id.

        func Set_Id (var Node; Node_Id);
        //  Fill in the Node_Id; might already have a value

        func Id (Node) -> optional Node_Id;
        //  Unique Node_Id for node within FSA
        //  This is null for a "template" node

        func Query (Node) -> optional Query_Id;
        //  Identifies which query this node is performing
        //  This is null for an action node/end state

        func Add_Successor(var From : Node; To : Node_Id)
          {Successor_Index(From', To) not null};
         // Add an edge in the FSA

        func Num_Successors (Node) -> Edge_Index;
        //  Number of successor nodes.
        //  Will be zero for an end state.

        func Successor (Node; Index : Edge_Index)
          {Index <= Num_Successors (Node)}
          -> Node_Id;
        //  Return Node_Id for given successor

        func Successor_Index (From : Node; To : Node_Id)
          -> optional Edge_Index;
        //  Return non-null Edge_Index if To is a successor of From.

        func Is_End_State (Node) -> Boolean is (#false);
        //  Return True if Node is an end state (i.e. is an Action_Node).

        func Dump_Node(FSA; Node; Indent : Univ_Integer);
        // Produce human-understandable dump of node, at given indent

        func Dump_Edge(FSA; N : Node; Outgoing_Edge : Edge_Index) is (null);
        //  Dump query and value set associated with given outgoing edge
        //  (by default is a no-op).

        abstract func Is_Nondeterministic
          (Node; Check_Actions : Boolean := #false)
         -> Boolean;
         //  Return True if Node has outgoing edges with overlapping value sets
         //  Only Check for ambiguous actions if Check_Actions is true.

        abstract func Disambiguate (Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set>;
        //  Update Node in FSA[Id(Node)] so that each edge has a value set
        //  that is disjoint from the value sets of other edges.
        //  Create new Node_Ids for the new nodes that will
        //  be mergers of other nodes.
        //  Return a mapping from Node_Ids for the updated Node (both
        //  existing Node_Ids and Node_Ids created by Disambiguate) to
        //  the set of old Node_Ids whose nodes need to be merged to create
        //  the node to go with each Node_Id of the updated node.
        //  Note that the passed-in Node is a read only copy of the original
        //  FSA[Id(Node)]

        abstract func Merge_Nodes
          (var New_Node : Node; FSA; Nodes_To_Merge : Node_Set);
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
    end interface Node;

    interface Branching_Node<> extends Node is
      //  A Branching_Node is used for the (one and only) starting node,
      //  and for any nested pattern match constructs.
      //  All successors of a Branching_Node effectively have a
      //  "universal" value set on their edge, meaning that any
      //  edge can be chosen.
      //  Each separate "arm" of the original pattern match is a
      //  successor of the starting node.
      //  Each "arm" of a nested pattern match is a successor of the
      //  Branching_Node representing the nested pattern match.

       func Create(optional Node_Id := null; optional Query_Id := null)
         -> Branching_Node;
        //  Must override inherited constructors.

        //  Create a node with given node id and query id.

       func Is_End_State (Branching_Node) -> Boolean is (#false);
         //  Return True if Node is an end state (never)

       func Is_Nondeterministic
          (Branching_Node; Check_Actions : Boolean := #false)
         -> Boolean is
         (|Num_Successors(Branching_Node)| > 1);
        //  Return True if Branching_Node has more than one outgoing edge

       func Disambiguate (S : Branching_Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set>;
        //  All successor nodes will be mapped to a single new node.

       func Merge_Nodes
         (var New_Node : Branching_Node; FSA; Nodes_To_Merge : Node_Set);
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
        //  For a Branching_Node, we combine all the non-others branching nodes
        //  together into New_Node, with an edge to each edge of the
        //  original branching node.

     new

       func Create_Others_Branch(optional Node_Id := null)
         -> Result : Branching_Node is
         (Create(Node_Id, Others_Branching_Query_Id));
        //  Create an Others branching node, with special "others" Query ID

    end interface Branching_Node;

    interface Action_Node<> extends Node is
      //  End state of FSA contains a set of actions

       func Create(optional Node_Id := null; optional Query_Id := null)
         -> Action_Node;
        //  Must override inherited constructors.

        //  Create a node with given node id and query id.

       func Is_End_State (Action_Node) -> Boolean is (#true);
         //  Return True if Node is an end state (i.e. is an Action_Node).

        func Is_Nondeterministic
          (Action_Node; Check_Actions : Boolean := #false)
         -> Boolean is
         (Check_Actions and then |Action_Ids(Action_Node)| > 1);
         //  Return True if Node has outgoing edges with overlapping value sets
         //  Only Check for ambiguous actions if Check_Actions is true.

       func Disambiguate (Action_Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set> is ([]);
        //  Not relevant for an action node.
        //  TBD: We could use this as the time to complain about action sets
        //       which are not reducible to a single action.

       func Merge_Nodes
         (var New_Node : Action_Node; FSA; Nodes_To_Merge : Node_Set);
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
        //  If New_Node is an Action_Node, then just include their Action_Ids
        //  in New_Node.

       func Dump_Node(FSA; Action_Node; Indent : Univ_Integer);

     new

       func Create(Action_Id) -> Action_Node;
         //  Create an action node with initial single Action Id

       func Add_Action(var Action_Node; Action_Id);
         // Add another action id to the node

       func Remove_Action(var Action_Node; Action_Id);
         // Remove action id from the node

       func Action_Ids (Action_Node) -> Ordered_Set<Action_Id>;
        //  Action Ids of node.  

    end interface Action_Node;

    interface Ordered_Node
      <Val_Type is Imageable<>; Univ_Set : Range_Set<Val_Type>>
      extends Node<> is
       //  Extension of Node where value type is some (fully) ordered
       //  type such as integer, string, or float, and Univ_Set is the
       //  universal set for the given type.
       //  We go further and require it to be Imageable (which implies
       //  Comparable and Hashable), merely so Dump_FSA can work.
        
       func Create(optional Node_Id := null; optional Query_Id := null)
          -> Ordered_Node {Num_Successors(Create) == 0};
         //  Create an ordered node, initially with no successors

       func Add_Successor(var From : Ordered_Node; To : Node_Id);
         // Add an edge in the FSA, with a default value set of "Node_Univ_Set"

       func Is_Nondeterministic
         (Ordered_Node; Check_Actions : Boolean := #false)
         -> Boolean;
         //  Return True if Node has outgoing edges with overlapping value sets
         //  Only Check for ambiguous actions if Check_Actions is true.

       func Disambiguate (N : Ordered_Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set>;
        //  Update node in FSA[Id(N)] so that each edge has a value set
        //  that is disjoint from the value sets of other edges.
        //  Create new Node_Ids for the new nodes that will
        //  be mergers of other nodes.
        //  Return a mapping from Node_Ids for the updated Node (both
        //  existing Node_Ids and Node_Ids created by Disambiguate) to
        //  the set of old Node_Ids whose nodes need to be merged to create
        //  the node to go with each Node_Id of the updated node.
        //  Note that the passed-in node is a read only copy of the original
        //  FSA[Id(N)]

       func Merge_Nodes
         (var New_Node : Ordered_Node; FSA; Nodes_To_Merge : Node_Set);
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.

       func Dump_Edge(FSA; Ordered_Node; Outgoing_Edge : Edge_Index);
        //  Dump query and value set associated with given outgoing edge

       func Dump_Node(FSA; Ordered_Node; Indent : Univ_Integer);

     new

       func Add_Successor(var From : Ordered_Node; To : Node_Id;
         Values : Range_Set<Val_Type>)
         {Successor_Index(From', To) not null;
          Successor_Values(From', Successor_Index(From', To)) == Values};
         // Add an edge in the FSA

       func Add_Successor(var From : Ordered_Node; To : Node_Id;
         Value : Val_Type) is
         (Add_Successor(From, To, Value .. Value));
         // Add an edge in the FSA

       func Successor_Values(From : Ordered_Node; Succ : Edge_Index)
         {Succ in 1 .. Num_Successors(From)}
         -> Range_Set<Val_Type>;
         //  Values associated with given successor

       func Set_Successor_Values
         (var From : Ordered_Node;
          Succ : Edge_Index;
          Values : Range_Set<Val_Type>)
         {Successor_Values(From', Succ) == Values};
         //  Set values associated with given successor
        
       func Create(optional Node_Id := null; optional Query_Id := null;
         Node_Univ_Set : Range_Set<Val_Type>)
          -> Ordered_Node {Num_Successors(Create) == 0};
         //  Create an ordered node, initially with no successors,
         //  with a restricted Univ_Set.

       func Set_Node_Univ_Set
         (var Ordered_Node; Node_Univ_Set : Range_Set<Val_Type>);
         //  Set Node_Univ_Set to a non-default value

       func Node_Univ_Set(Ordered_Node) -> Range_Set<Val_Type>;
         //  Universal set associated with Ordered_Node

    end interface Ordered_Node;

    interface Countable_Node
      <Val_Type is Countable<>; Univ_Set : Range_Set<Val_Type> :=
        Val_Type::First() .. Val_Type::Last()>
      extends Ordered_Node<Val_Type, Univ_Set> is
       //  Same as ordered node, but takes advantage of fact
       //  that Val_Type is countable so no need for open interval bounds.

       func Disambiguate (N : Countable_Node; var FSA)
          -> Ordered_Map<Node_Id, Node_Set>;
       // Disambiguate and then remove open bounds from value sets

       func Add_Successor(var From : Countable_Node; To : Node_Id;
         Values : Range_Set<Val_Type>)
         {Successor_Index(From', To) not null;
          Successor_Values(From', Successor_Index(From', To)) == Values};
         // Add an edge in the FSA

       func Set_Successor_Values
         (var From : Countable_Node;
          Succ : Edge_Index;
          Values : Range_Set<Val_Type>)
         {Successor_Values(From', Succ) == Values};
         //  Set values associated with given successor
        
    end interface Countable_Node;

    func Create() -> FSA {Num_Nodes (Create) == 1};
      // Create an FSA with a single Start node

    func Assign_Node_Id (var FSA) -> Node_Id
      {Num_Nodes (FSA') == Num_Nodes (FSA) + 1;
       Node_Is_Filled (FSA', Assign_Node_Id) == #false};
      //  Assign a new Node_Id for a node to be added to the given FSA

    func Node_Is_Filled (FSA; Node_Id)
      {Node_Id in 1 .. Num_Nodes (FSA)}
      -> Boolean
      //  Indicates whether node has been filled in.
      
    func Set_Node (var FSA; Node_Id; Node+);  // "for FSA"
      //  Fill in or replace node at given Node_Id

    func Add_Node(var FSA; Node+) -> Node_Id;
      //  Add a node to a FSA, and return its node id
      //  This is equivalent to Assign_Node_Id followed by Set_Node.

    func Add_Root_Successor(var FSA; To : Node_Id);
      //  Add a successor to the Starting Node of the FSA

    func Add_Root_Successor(var FSA; To : Node+)
      is (Add_Root_Successor(FSA, FSA.Add_Node(To)));
      //  Add a successor to the Starting Node of the FSA

    op "in"(Node_Id; FSA) -> Boolean;
      // Return #true if Node_Id is in FSA

    op "indexing"(ref FSA; Node_Id) 
      {Node_Id in FSA}
      -> ref Node+;
      // Return a reference to a node of the FSA

    func Node_Range(FSA) -> Countable_Range<Node_Id>;
      // The range of node-ids in use in FSA

    func Root_Id(FSA) -> optional Node_Id;

    func Dump_One_Node(FSA; Node_Id; Indent : Univ_Integer);
      // Produce a human-readable representation of the node, if any, with
      // given Node_Id, at given indent.
 
    func Dump_FSA(FSA; Check_Actions : Boolean := #false)
      // Produce a human-readable representation of the FSA
      // Pass Check_Actions to Is_Nondeterministic.

    func Is_Nondeterministic
      (FSA; Check_Actions : Boolean := #false)
      -> Boolean;
      //  Return True if some node within the FSA
      //  has outgoing edges with overlapping value sets.
      //  Only Check for ambiguous actions if Check_Actions is true.

    func Queries_Are_Ordered(FSA; Node_Id) -> Boolean;
      //  Return True if a sequence of non-end-states have queries
      //  ordered by Query_Id.

    func Disambiguate_FSA(var FSA);
      //  Remove nondeterminism from FSA

    func FSA_Node_Action_Sets(FSA)
      -> Result : Ordered_Map<Node_Id, Ordered_Set<Action_Id>>;
       //  Return map of reachable nodes that are action nodes
       //  to their action sets

    func FSA_Action_Node_Paths(FSA)
      -> Result : Ordered_Map
                    <Node_Id, Ordered_Set<Imageable_Vector<Edge_Index>>>;
       //  Return map from reachable nodes that are action nodes
       //  to the path(s) that reach(es) them (as a vector of edge indices).

    func Winnow_And_Check_Actions
      (var FSA;
       Error_Action : optional Action_Id := null)
      //  Remove "superset" actions, and check for
      //  Completeness, Ambiguity, and Redundancy
      //  Patterns are incomplete if the Error_Action
      //  (if any) remains after winnowing.

end interface FSA;

class FSA is
  // Class defining the FSA module
    const Root_Node_Id : Node_Id := 1
    var Nodes : Vector<optional Node+> :=
      [Branching_Node::Create(Node_Id => Root_Node_Id)];
    var Action_Strings : Vector<Univ_String> := [];
    var Query_Formulae : Vector<Univ_String> := [];

    const Debug : Boolean := #false;

    func Dump_Node_Path
      (FSA; Path : Imageable_Vector<Edge_Index>; Indent : Univ_Integer := 0) is
    //  Dump edge information along the given path from the root node.
       var N_Id : Node_Id := Root_Node_Id;
       var Ind := Indent;

       for each Edge of Path forward loop
          ref Next_Node : Node+ => FSA[N_Id];

          case Next_Node of
           [S : Branching_Node] => null;

           [A : Action_Node] =>
             {*"Should not reach action node"* #false}

           [N : Node+] =>
             //  Show value set that selects edge
             Print(Ind * " ");
             Dump_Edge(FSA, N, Edge);
             Println("");
             Ind += 2;
          end case;

          N_Id := Next_Node.Successor(Edge);
       end loop;
    end func Dump_Node_Path;

  exports

    func Num_Nodes (FSA) -> Univ_Integer is (|FSA.Nodes|);
    //  Count of nodes within FSA

    func Add_Action_Id (var FSA; Action : Univ_String) -> Action_Id is
    //  Add a new Action_Id to the FSA
    //  Action is a string representing the action to be performed.
       FSA.Action_Strings |= Action;
       return |FSA.Action_Strings|;
    end func Add_Action_Id;

    func Add_Action_Node (var FSA; Action : Univ_String) -> Node_Id is
    //  Add a node that has one (new) action ID;
    //  Action is a string representing the action to be performed.
       const Act_Id := Add_Action_Id(FSA, Action);
       return Add_Node(FSA, Action_Node::Create(Act_Id));
    end func Add_Action_Node;

    func Action_String(FSA; Action_Id) -> Univ_String
      is (FSA.Action_Strings[Action_Id]);
      //  Return string representing action to be performed

    func Num_Actions (FSA) -> Action_Id is (|FSA.Action_Strings|);
    //  Count of distinct actions

    func Add_Query_Id (var FSA; Formula : Univ_String) -> Query_Id is
    //  Add a new Query_Id to the FSA, representing the given Formula
       FSA.Query_Formulae |= Formula;
       return |FSA.Query_Formulae|;
    end func Add_Query_Id;

    func Num_Queries (FSA) -> Univ_Integer is (|FSA.Query_Formulae|);
    //  Count of distinct queries within FSA

    func Query_Formula (FSA; Query_Id) -> Univ_String
      is (Query_Id == Others_Branching_Query_Id?
            "Others Branching node" :
          Query_Id == Branching_Query_Id?
            "Branching node" : FSA.Query_Formulae[Query_Id]);
    //  Return query formula
    
    class Node<> is

        var Id : optional Node_Id := null;
        var Q_Id : optional Query_Id := null;
        var Successors : Vector<Node_Id> := [];

      exports
        func Create(optional Node_Id; optional Query_Id) -> Node
          is (Id => Node_Id, Q_Id => Query_Id);
        //  Create a node with given node id and query id.

        func Set_Id (var Node; Node_Id) is
        //  Fill in the Node_Id; might already have a value
           Node.Id := Node_Id;
        end func Set_Id;

        func Id (Node) -> optional Node_Id is (Node.Id);
        //  Unique Node_Id for node within FSA
        //  This is null for a "template" node

        func Query (Node) -> optional Query_Id is (Node.Q_Id);
        //  Identifies which query this node is performing
        //  This is null for an action node/end state

        func Add_Successor(var From : Node; To : Node_Id)
         // Add an edge in the FSA
        is
            From.Successors |= To;
        end func Add_Successor;

        func Num_Successors (Node) -> Edge_Index is (|Node.Successors|);
        //  Number of successor nodes.
        //  Will be zero for an end state.

        func Successor (Node; Index : Edge_Index)
          {Index <= Num_Successors (Node)}
          -> Node_Id is (Node.Successors[Index]);
        //  Return Node_Id for given successor

        func Successor_Index (From : Node; To : Node_Id)
          -> optional Edge_Index is
        //  Return non-null Edge_Index if To is a successor of From.
            for Index in From.Successors.Bounds() loop
               if From.Successors [Index] == To then
                  return Index;
               end if;
            end loop;
            return null;
        end func Successor_Index;

        func Dump_Node(FSA; Node; Indent : Univ_Integer) is
           const Ind := Indent * " ";
           Println(Ind | "Node: `(Id(Node)), " |
                   "`(Id(Node) == Root_Node_Id? "Starting node":
                      Query_Formula(FSA, Query(Node)))");
           for Succ_Ix in 1 .. Num_Successors(Node) forward loop
              Dump_One_Node(FSA, Successor(Node, Succ_Ix), Indent + 2);
           end loop;
        end func Dump_Node;
    end class Node;

    class Branching_Node is

      exports

       func Create(optional Node_Id := null; optional Query_Id := null)
         -> Branching_Node is
        //  Create a Branching_Node
          {*"Query_Id if non-null should be a branching query_id"*
            Query_Id is null or else Query_Id >= Branching_Query_Id}
          return (Node =>
            Create (Node_Id, Query_Id is null? Branching_Query_Id: Query_Id));
       end func Create;

       func Disambiguate (S : Branching_Node; var FSA)
          -> Result : Ordered_Map<Node_Id, Node_Set> is
        //  All successor nodes will be mapped to a single new node.
          Result := [];

          if Num_Successors(S) == 1 then
             //  Weird special case where branching node has only one successor
             const Only_Successor : Node_Id := Successor(S, 1);

             Result |= [Only_Successor => [Only_Successor]];
          else
             var New_B_Node : Branching_Node :=
               Create(Id(S), Query(S))
          
             //  Assign new Node_Id into which all successors will be merged
             const New_Node_Id : Node_Id := Assign_Node_Id(FSA);

             Add_Successor (New_B_Node, New_Node_Id);

             //  Update node with disambiguated node
             Set_Node(FSA, Id(S), New_B_Node);

             const All_Succs : Node_Set :=
                    [for Edge in 1 .. Num_Successors(S) =>
                       Successor(S, Edge)];

             Result |= [New_Node_Id => All_Succs];
          end if;
       end func Disambiguate;

       func Merge_Nodes
         (var New_Node : Branching_Node; FSA; Nodes_To_Merge : Node_Set) is
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
        //  For a Branching_Node, we combine all the non-others branching nodes
        //  together into New_Node, with an edge to each edge of the
        //  original branching node.
           for each AB_Id of Nodes_To_Merge loop
              ref Old_Node => FSA[AB_Id];
              const Old_Q_Id := Query(Old_Node);

              {*"All nodes should be branching nodes or action nodes"*
                 Old_Q_Id is null
                   or else Old_Q_Id == Branching_Query_Id
                   or else Old_Q_Id == Others_Branching_Query_Id}

              case Old_Node of
               [B : Branching_Node] =>
                 //  Is a branching node; carry over its successors
                 //  unless is an "others" branching node
                 if Query(B) == Others_Branching_Query_Id then
                    //  Make the Others branching node a successor
                    if Debug then
                       Println
                         ("Others Branching Node `(AB_Id) becoming successor");
                    end if;
                    New_Node.Add_Successor(To => AB_Id);
                 else
                    if Debug then
                       Println("Old Branching Node `(AB_Id) being merged in");
                    end if;
                    for Succ in 1 .. Num_Successors(B) loop
                       if Debug then
                          Println(" Adding edge to `(Successor(B, Succ))");
                       end if;
                       New_Node.Add_Successor
                         (To => Successor(B, Succ));
                    end loop;
                 end if;

               [A : Action_Node] =>
                 //  Create a successor to action node
                 New_Node.Add_Successor(To => AB_Id);

               [N : Node+] =>
                 //  Should be a branching or action node
                 {*"All nodes should be branching or action nodes"* #false}
              end case;
           end loop;
       end func Merge_Nodes;

    end class Branching_Node

    class Action_Node is
      //  End state of FSA contains a set of actions

       var Actions : Ordered_Set<Action_Id> := [];

       func Plural(Univ_Integer) -> Univ_String
         is (Univ_Integer != 1? "s": "");
     exports

       func Create(optional Node_Id := null; optional Query_Id := null)
         -> Action_Node is (Node => Create(Node_Id, Query_Id));
        //  Must override inherited constructors.

       func Merge_Nodes
         (var New_Node : Action_Node; FSA; Nodes_To_Merge : Node_Set)
       is
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
        //  If New_Node is an Action_Node, then just include their Action_Ids
        //  in New_Node.
          if Debug then
             Println(" In Merge_Nodes for Action Node `(Id(New_Node))");
             Println("  Nodes_To_Merge:" |
               (for each N_Id of Nodes_To_Merge forward =>
                  <""> | " " | N_Id));
          end if;

          for each N_Id of Nodes_To_Merge loop
             case FSA[N_Id] of
              [A : Action_Node] =>
                New_Node.Actions |= A.Actions;

              [B : Branching_Node] =>
                if Query(B) == Others_Branching_Query_Id then
                   //  We simply drop an "others" on the "floor" since
                   //  we don't want the "others" nested pattern match
                   //  to be ambiguous with any actions outside the
                   //  nested pattern match.
                   if Debug then
                      Println("  Ignoring Others branch `(N_Id) in merge");
                   end if;
                else
                   {*"Cannot merge non-others branching node into action node"*
                     #false}
                end if;

              [N : Node+] =>
                {*"Cannot merge non-action into Action node"* #false}
                null;
             end case;
          end loop;
       end func Merge_Nodes;

       func Dump_Node(FSA; A : Action_Node; Indent : Univ_Integer) is
          const Ind := Indent * " ";
          Println(Ind | "Node: `(Id(A)), Action`(Plural(|A.Actions|)):" |
            (for (each Act of A.Actions; Sep := " " then ", ")
              forward => <""> | Sep | "`(Action_String(FSA, Act))"));
       end func Dump_Node;

     new

       func Create(Action_Id) -> Action_Node is
         //  Create an action node with initial single Action Id
          return (Node => Create(), Actions => [Action_Id]);
       end func Create;

       func Add_Action(var Action_Node; Action_Id) is
         // Add another action to the node
          Action_Node.Actions |= Action_Id;
       end func Add_Action;

       func Remove_Action(var Action_Node; Action_Id) is
         // Remove action id from the node
          Action_Node.Actions -= Action_Id;
       end func Remove_Action;

       func Action_Ids (Action_Node) -> Ordered_Set<Action_Id>
         is (Action_Node.Actions);
        //  Action Ids of node.  

    end class Action_Node;

    class Ordered_Node is
       //  Extension of Node where value type is some countable
       //  type such as an integer or an enumeration type.

        var Edge_Value_Sets : Vector<Range_Set<Val_Type>> := [];
          //  Value set associated with each outgoing edge

        var Node_Univ_Set : Range_Set<Val_Type> := Univ_Set;

        interface Interval_And_Edge<> is
           const Ival : Interval<Val_Type>;
           const Edge : Edge_Index;

           func Strict_Compare(Left, Right : Interval_And_Edge)
             -> Ordered::Full_Ordering
             is ((Strict_Compare(Left.Ival, Right.Ival) != #equal?
                     Strict_Compare(Left.Ival, Right.Ival) :
                     Left.Edge =? Right.Edge));
           op "=?"(Left, Right : Interval_And_Edge) -> Ordering
             is (Strict_Compare(Left, Right));
        end interface Interval_And_Edge;

        interface High_Bound_And_Edge<> is
          //  Used for seeing the order in which an active interval ends.
           const High : Val_Type;
           const High_Is_Open : Boolean;
           const Edge : Edge_Index;

           func Strict_Compare(Left, Right : High_Bound_And_Edge)
             -> Ordered::Full_Ordering
             is ((if Left.High != Right.High then
                    Left.High =? Right.High
                  elsif Left.High_Is_Open != Right.High_Is_Open then
                    Right.High_Is_Open =? Left.High_Is_Open  // inverted
                  else Left.Edge =? Right.Edge));
           op "=?"(Left, Right : High_Bound_And_Edge) -> Ordering
              is (Strict_Compare(Left, Right));
        end interface High_Bound_And_Edge;

        func Interval_Set(Ordered_Node)
          -> Result : Ordered_Set<Interval_And_Edge> is
          //  Set of intervals and associated edges, ordered
          //  by low bound of interval (and edge if necessary to break
          //  a tie).
           Result := [];
           for Edge in Ordered_Node.Edge_Value_Sets.Bounds() loop
              for each Ival of Ordered_Node.Edge_Value_Sets[Edge] loop
                 Result |= Interval_And_Edge::(Ival => Ival, Edge => Edge);
              end loop;
           end loop;

           if Debug then
              Println("Set of intervals for edges from Node " |
                "`(Id(Ordered_Node)):");
              for each IE of Result forward loop
                 Println("  `(IE.Ival.Low_Is_Open? "(" : "[")`(IE.Ival.Low)" |
                  "..`(IE.Ival.High)`(IE.Ival.High_Is_Open? ")" : "]") -- " |
                  IE.Edge | ", Node `(Successor(Ordered_Node, IE.Edge))");
              end loop;
           end if;
        end func Interval_Set;
        
        interface Value_Set_And_Edge<> is
           var Val_Set : Range_Set<Val_Type>;
           const Edge : Edge_Index;
        end interface Value_Set_And_Edge;

        func Dump_Range_Set (Vals : Range_Set<Val_Type>) is
           for (each Ival of Vals; Sep := "" then " | ") forward loop
              if Ival.Low == Ival.High
                and then not Ival.Low_Is_Open
                and then not Ival.High_Is_Open
              then
                 Print(Sep | "[`(Ival.Low)]");
              else
                 Print(Sep | (Ival.Low_Is_Open? "(" : "[") | Ival.Low |
                   ".." | Ival.High | (Ival.High_Is_Open? ")" : "]"));
              end if;
           end loop;
        end func Dump_Range_Set;

      exports

        func Create(optional Node_Id := null; optional Query_Id := null)
          -> Ordered_Node
         //  Create an ordered node, initially with no successors
          is (Node => Create(Node_Id, Query_Id));

        func Add_Successor(var From : Ordered_Node; To : Node_Id)
         // Add an edge in the FSA, with a default value set of "Node_Univ_Set"
        is
            Add_Successor(From.Node, To);
            //  Provide a default for the edge value set
            From.Edge_Value_Sets |= Node_Univ_Set(From);
        end func Add_Successor;

        func Is_Nondeterministic
          (Ordered_Node; Check_Actions : Boolean := #false)
         -> Boolean is
        //  Return True if Node has outgoing edges with overlapping value sets

           //  Look at the set of intervals associated with each edge,
           //  ordered by low bound of each interval making up a range
           //  set for a given edge.  If there is an overlap between
           //  two successive intervals, then the node is nondeterministic.

           var Prior_IE : optional Interval_And_Edge := null;
           const Ival_Set := Ordered_Node.Interval_Set();

           for each Next_IE of Ival_Set forward loop
              if Prior_IE not null
                and then Overlaps (Next_IE.Ival, Prior_IE.Ival)
              then
                 return #true;
              end if;
              Prior_IE := Next_IE;
           end loop;

           return #false;
        end func Is_Nondeterministic;

        func Disambiguate (N : Ordered_Node; var FSA)
          -> Result : Ordered_Map<Node_Id, Node_Set> is
        //  Update node in FSA[Id(N)] so that each edge has a value set
        //  that is disjoint from the value sets of other edges.
        //  Create new Node_Ids for the new nodes that will
        //  be mergers of other nodes.
        //  Return a mapping from Node_Ids for the updated Node (both
        //  existing Node_Ids and Node_Ids created by Disambiguate) to
        //  the set of old Node_Ids whose nodes need to be merged to create
        //  the node to go with each Node_Id of the updated node.
        //  Note that the passed-in node is a read only copy of the original
        //  FSA[Id(N)]
           var Updated_Node : Ordered_Node :=
             Create(Node_Id => Id(N), Query_Id => Query(N));
              //  TBD: It would be good if we could set the Node_Univ_Set

           var Edge_Combos : Ordered_Set
                <Countable_Set<Edge_Index>> := [];
             //  Unique combinations of edges that all share some of the
             //  same values.

           var Active_Combo : Countable_Set<Edge_Index> := [];
             //  Edges associated with active intervals during iteration.

           func Remember_Combos
             (Finished_Intervals : Ordered_Set<Interval_And_Edge>) is
             //  Remember the active combo as an "interesting" combo,
             //  as well as combos of intervals that are ending.

              if Debug then
                 Println("Remember_Combos");
              end if;

              if |Active_Combo| > 0 then
                 //  Active combo has at least one value unique to it
                 if Debug then
                    Println(" Adding full Active_Combo to Edge_Combos:" |
                      (for each Edge of Active_Combo forward =>
                         <""> | " " | Edge) | ", Nodes:" |
                      (for each Edge of Active_Combo forward =>
                         <""> | " " | Successor(N, Edge)));
                 end if;

                 Edge_Combos |= Active_Combo;
                 if Debug then
                    Println(" |Edge_Combos| = `(|Edge_Combos|)");
                 end if;
              end if;

              //  Now look at intervals that have ended to see whether
              //  there are unique combos to be remembered.
              if |Finished_Intervals| > 0 then
                 var Finished_High_Bounds : Ordered_Set<High_Bound_And_Edge>
                   := [];

                 for each Finished_IE of Finished_Intervals loop
                    Finished_High_Bounds |=
                      (Finished_IE.Ival.High,
                       Finished_IE.Ival.High_Is_Open,
                       Finished_IE.Edge);
                 end loop;

                 var Prior_HB : optional High_Bound_And_Edge := null;
                 for each Finished_HB of Finished_High_Bounds forward loop
                    if Prior_HB not null
                      and then
                       (Finished_HB.High != Prior_HB.High
                         or else
                        Finished_HB.High_Is_Open != Prior_HB.High_Is_Open)
                    then
                       //  Finished is later, so the combo of this edge
                       //  plus any edges with later high bounds
                       //  is "interesting".
                       if Debug then
                          Println(" Adding to Edge_Combos:" |
                            (for each Edge of Active_Combo forward =>
                               <""> | " " | Edge) | ", Nodes:" |
                            (for each Edge of Active_Combo forward =>
                               <""> | " " | Successor(N, Edge)));
                       end if;

                       Edge_Combos |= Active_Combo;
                       if Debug then
                          Println(" |Edge_Combos| = `(|Edge_Combos|)");
                       end if;
                    end if;
                    Active_Combo -= Finished_HB.Edge;

                    //  Remember prior HB for next iteration
                    Prior_HB := Finished_HB;
                 end loop;
              end if;
           end func Remember_Combos;

           //  Look at the set of intervals associated with each edge,
           //  ordered by low bound of each interval making up a range
           //  set for a given edge.  We keep track of intervals that
           //  are "active" as we go through the iteration to determine
           //  what are the overlaps.

           var Active_Intervals : Ordered_Set<Interval_And_Edge> := [];
             //  Intervals that are still "active" as we iterate through
             //  the set of all intervals used in edge value sets.

           for each Next_IE of N.Interval_Set() forward loop
              var Finished_Intervals : Ordered_Set<Interval_And_Edge> := [];

              var Next_IE_Starts_Later : Boolean := #true;

              for each Active_IE of Active_Intervals loop
                 if Active_IE.Ival.Low == Next_IE.Ival.Low
                      and then
                    Active_IE.Ival.Low_Is_Open == Next_IE.Ival.Low_Is_Open
                 then
                    //  Same starting point as at least one of the
                    //  active intervals, so can just add to existing combo
                    Next_IE_Starts_Later := #false;
                 elsif not Overlaps (Active_IE.Ival, Next_IE.Ival) then
                    //  We can finish Active_IE, since it ends before Next_IE
                    //  begins.
                    Finished_Intervals += Active_IE;
                 end if;
              end loop;

              if not Next_IE_Starts_Later then
                 //  Next_IE starts at same point as at least one of
                 //  the active intervals.

                 {*"No intervals should be ending"* |Finished_Intervals| == 0}

              else
                 //  Active combo has at least one value unique to it
                 //  Remember it, as well as combos of intervals that
                 //  are ending.
                 Remember_Combos(Finished_Intervals);

                 //  Remove intervals that have finished
                 Active_Intervals -= Finished_Intervals;
              end if;

              //  Add Next_IE to set of active intervals
              Active_Intervals += Next_IE;
              Active_Combo += Next_IE.Edge;
           end loop;

           //  Reached end of intervals, remember interesting combos
           Remember_Combos(Active_Intervals);

           if Debug then
              Println("Edge combos for Node `(Id(N)):");
              for each Combo of Edge_Combos loop
                 Println((for Edge in Combo forward => <""> | " " | Edge) |
                   ", Nodes:" |
                   (for Edge in Combo forward => <""> | " " |
                      Successor(N, Edge)));
              end loop;
           end if;

           //  Convert set of interesting combos into desired mapping.

           //  Initialize the result mapping
           Result := [];

           for each Combo of Edge_Combos loop
              var New_Node_Id : Node_Id;

              if |Combo| == 1 then
                 //  This successor node should remain, though its value
                 //  set might shrink.
                 New_Node_Id := Successor(N, Any_Element(Combo));
              else
                 //  Assign a new Node_Id
                 New_Node_Id := Assign_Node_Id(FSA);
              end if;

              // Convert to a set of node ids
              const Old_Node_Set : Node_Set :=
                (for Edge in Combo => <[]> | Successor(N, Edge));

              //  Add a mapping to the set of old nodes from the edge combo
              Result |= [New_Node_Id => Old_Node_Set];

              // Compute intersection of value sets for the combined edges
              var Edge_Val_Intersection : Range_Set<Val_Type> :=
                Node_Univ_Set(N);

              for Edge in 1 .. Num_Successors(N) loop
                 if Edge in Combo then
                    --  *Keep* values in value set of present edge
                    Edge_Val_Intersection and= Successor_Values(N, Edge);
                 else
                    --  *Remove* values in value set of absent edge
                    Edge_Val_Intersection -= Successor_Values(N, Edge);
                 end if;
              end loop;

              if Debug then
                 Println("Node `(New_Node_Id) has Edge Combo:" |
                   (for Edge in Combo => <""> | " " | Edge) | ", Nodes:" |
                   (for N_Id in Old_Node_Set => <""> | " " | N_Id));
                 Print(" Intersection of values is:");
                 Dump_Range_Set(Edge_Val_Intersection);
                 Println("");
              end if;

              //  Add successor
              Add_Successor (Updated_Node, New_Node_Id);

              const New_Edge : Edge_Index := |Num_Successors(Updated_Node)|;

              //  Now copy the value sets onto the new edge
              Set_Successor_Values
                (Updated_Node, New_Edge, Edge_Val_Intersection);
              
           end loop;

           //  Replace old node with updated node
           Set_Node(FSA, Id(N), Updated_Node);
        end func Disambiguate;

        func Merge_Nodes
          (var New_Node : Ordered_Node; FSA; Nodes_To_Merge : Node_Set) is
        //  Merge in nodes in Nodes_To_Merge of same Node type and with
        //  matching Query_Id (will be null if an Action_Node) into New_Node.
        //  For other nodes in Nodes_To_Merge, create
        //  an unconditional edge to existing node.
           const Q_Id := Query(New_Node);

           if Debug then
              Println(" In Merge_Nodes for Node `(Id(New_Node)), " |
                "Query `(Query_Formula(FSA, Q_Id))");
              Println("  Nodes_To_Merge:" |
                (for each N_Id of Nodes_To_Merge forward =>
                   <""> | " " | N_Id));
           end if;

           for each O_Id of Nodes_To_Merge loop
              ref Old_Node => FSA[O_Id];
              const Old_Q_Id := Query(Old_Node);

              if Old_Q_Id not null
                and then Old_Q_Id == Q_Id
              then
                 //  Query Id matches, check type
                 case Old_Node of
                  [O : Ordered_Node+] =>
                    //  Type matches as well.  Carry over its successors.
                    if Debug then
                       Println("Old Ordered Node `(O_Id) being merged in");
                    end if;
                    for Succ in 1 .. Num_Successors(O) loop
                       if Debug then
                          Println(" Adding edge to `(Successor(O, Succ))");
                       end if;
                       New_Node.Add_Successor
                         (To => Successor(O, Succ),
                          Values => Successor_Values(O, Succ));
                    end loop;

                    //  Loop around to handle next old node
                    continue loop;

                  [N : Node+] =>
                    //  Different type, treat as though query doesn't match
                    null;  
                 end case;
              end if;

              //  Create unconditional edge to existing node
              if Debug then
                 Println(" Old Node `(O_Id) has different type/query");
                 Println("  Creating unconditional edge to old node");
              end if;
              New_Node.Add_Successor
                (To => O_Id,
                 Values => Node_Univ_Set(New_Node));
           end loop;
        end func Merge_Nodes;

        func Dump_Edge(FSA; N : Ordered_Node; Outgoing_Edge : Edge_Index) is
         //  Dump query and value set associated with given edge
           Print(Query_Formula(FSA, Query(N)) | " in ");
           Dump_Range_Set (N.Successor_Values(Outgoing_Edge));
        end func Dump_Edge;

        func Dump_Node(FSA; N : Ordered_Node; Indent : Univ_Integer) is
           const Ind := Indent * " ";

           //  Build up a mapping ordered by value set
           var Val_Ordered_Map :
             Ordered_Map<Range_Set<Val_Type>, Node_Set> := [];
           for Succ_Ix in 1 .. Num_Successors(N) loop
              const Vals := N.Successor_Values(Succ_Ix);
              if Vals not in Val_Ordered_Map then
                 Val_Ordered_Map |= [Vals => []];
              end if;
              Val_Ordered_Map[Vals] |= N.Successor(Succ_Ix);
           end loop;

           Println(Ind | "Node: `(Id(N))");
           for each [Vals => Succ_Nodes] of Val_Ordered_Map forward loop
              for each Succ_Id of Succ_Nodes forward loop
                 Print(Ind | " `(Query_Formula(FSA, Query(N))) in ");
                 Dump_Range_Set(Vals);
                 Println (" =>");
                 Dump_One_Node(FSA, Succ_Id, Indent + 2);
              end loop;
           end loop;
        end func Dump_Node;

     new

        func Add_Successor(var From : Ordered_Node; To : Node_Id;
          Values : Range_Set<Val_Type>)
          // {Successor_Index(From', To) not null;
          //  Successor_Values(From', Successor_Index(From', To)) == Values}
          // Add an edge in the FSA
        is
           //  At this point, should have one value set per successor
           {Num_Successors(From) == |From.Edge_Value_Sets|}

           From.Node.Add_Successor (To);
           From.Edge_Value_Sets |= Values;
        end func Add_Successor;

        func Successor_Values(From : Ordered_Node; Succ : Edge_Index)
          {Succ in 1 .. Num_Successors(From)}
          -> Range_Set<Val_Type> is
          //  Values associated with given successor
           return From.Edge_Value_Sets[Succ];
        end func Successor_Values;

        func Set_Successor_Values
          (var From : Ordered_Node;
           Succ : Edge_Index;
           Values : Range_Set<Val_Type>)
          //  Set values associated with given successor
        is
           From.Edge_Value_Sets[Succ] := Values;
        end func Set_Successor_Values;

        func Create(optional Node_Id := null; optional Query_Id := null;
          Node_Univ_Set : Range_Set<Val_Type>)
           -> Ordered_Node
          //  Create an ordered node, initially with no successors,
          //  with a restricted Univ_Set.
          is (Node => Create(Node_Id, Query_Id),
              Node_Univ_Set => Node_Univ_Set);

        func Set_Node_Univ_Set
          (var Ordered_Node; Node_Univ_Set : Range_Set<Val_Type>) is
          //  Set Node_Univ_Set to a non-default value
           Ordered_Node.Node_Univ_Set := Node_Univ_Set;
        end func Set_Node_Univ_Set;

        func Node_Univ_Set(Ordered_Node) -> Range_Set<Val_Type>
          //  Universal set associated with Ordered_Node
          is (Ordered_Node.Node_Univ_Set);

    end class Ordered_Node;

    class Countable_Node is
       //  Same as ordered node, but takes advantage of fact
       //  that Val_Type is countable so no need for open interval bounds.

       func Close_Bounds (Range_Set<Val_Type>)
         -> Result : Range_Set<Val_Type>
          //  Close any open intervals by adjusting bound up/down
       is
          Result := [];
          for Ival in Range_Set loop
             var Closed_Ival for Result := Ival;

             //  Close either side of interval that is open
             if Closed_Ival.Low_Is_Open then
                Closed_Ival.Low_Is_Open := #false;
                Closed_Ival.Low += 1;
             end if;

             if Closed_Ival.High_Is_Open then
                Closed_Ival.High_Is_Open := #false;
                Closed_Ival.High -= 1;
             end if;

             //  Add closed interval into result
             Add_Interval (Result, Closed_Ival);
          end loop;
       end func Close_Bounds;

       type Ordered_Base is Ordered_Node<Val_Type, Univ_Set>;

     exports

       func Add_Successor(var From : Countable_Node; To : Node_Id;
         Values : Range_Set<Val_Type>) is
         // Add an edge in the FSA
          Add_Successor(From.Ordered_Node, To, Close_Bounds(Values));
       end func Add_Successor

       func Set_Successor_Values
         (var From : Countable_Node;
          Succ : Edge_Index;
          Values : Range_Set<Val_Type>) is
         //  Set values associated with given successor
          Set_Successor_Values (From.Ordered_Node, Succ, Close_Bounds(Values));
       end func Set_Successor_Values
        
       func Disambiguate (N : Countable_Node; var FSA)
          -> Result : Ordered_Map<Node_Id, Node_Set> is
       // Disambiguate and then remove open bounds from value sets

          Result := Disambiguate (N.Ordered_Node, FSA);

          case FSA[Id(N)] of
            [Updated : Ordered_Base] =>

              // Close bounds of all intervals in value sets of all edges
              for Edge in 1 .. Num_Successors(Updated) loop
                 const Vals := Successor_Values(Updated, Edge);
                 Set_Successor_Values(Updated, Edge, Close_Bounds(Vals));
              end loop;

              // Update FSA node
              // Build a Countable_Node with same content as ordered node
              var C : Countable_Node := (Ordered_Node => Updated);
              Set_Id (C, Id(N));

              Set_Node(FSA, Id(N), C);

            [X : Node+] =>
               {*"Expecting Ordered_Node"* #false}
          end case;
       end func Disambiguate;

    end class Countable_Node;

    func Create() -> FSA is
      // Create an empty FSA
       return ();
    end func Create;

    func Assign_Node_Id (var FSA) -> Result : Node_Id is
      //  Assign a new Node_Id for a node to be added to the given FSA
       const N : optional Node+ := null;
       FSA.Nodes |= N;
       Result := |FSA.Nodes|;
    end func Assign_Node_Id;

    func Node_Is_Filled (FSA; Node_Id)
      -> Boolean is (FSA.Nodes[Node_Id] not null);
      //  Indicates whether node has been filled in.
      
    func Set_Node (var FSA; Node_Id; Node+) is  //  for FSA
      //  Fill in or replace node at given Node_Id
       FSA.Nodes[Node_Id] := Node;
       if Id(Node) is null then
          //  Fill in Id of node if null
          Set_Id (FSA.Nodes[Node_Id], Node_Id);
       else
          //  Node Id should already match
          {Id(Node) == Node_Id}
       end if;
    end func Set_Node;

    func Add_Node(var FSA; Node+) -> Result : Node_Id is
      // Add a node to a FSA, and return its node id
       FSA.Nodes |= Node;
       Result := |FSA.Nodes|;
       Set_Id (FSA.Nodes[Result], Result);
    end func Add_Node;

    func Add_Root_Successor(var FSA; To : Node_Id) is
      //  Add a successor to the Starting Node of the FSA
       Add_Successor(FSA[Root_Node_Id], To);
    end func Add_Root_Successor;

    op "in"(Node_Id; FSA) -> Boolean is (Node_Id in 1 .. |FSA.Nodes|);
      // Return #true if Node_Id is in FSA

    op "indexing"(ref FSA; Node_Id) 
      {Node_Id in FSA}
      -> ref Node+ is (FSA.Nodes[Node_Id]);
      // Return a reference to a node of the FSA

    func Node_Range(FSA) -> Countable_Range<Node_Id> is (1 .. |FSA.Nodes|);
      // The range of node-ids in use in FSA

    func Root_Id(FSA) -> optional Node_Id is (Root_Node_Id);
 
    func Dump_One_Node(FSA; Node_Id; Indent : Univ_Integer) is
       if not FSA.Node_Is_Filled(Node_Id) then
          Println(Indent * " " | "Node: `(Node_Id) not filled in yet");
       else
          Dump_Node(FSA, FSA[Node_Id], Indent);
       end if;
    end func Dump_One_Node;

    func Dump_FSA(FSA; Check_Actions : Boolean := #false) is
      // Produce a human-readable representation of the FSA
      // Pass Check_Actions to Is_Nondeterministic.
       Println("  FSA is " |
         (Is_Nondeterministic(FSA, Check_Actions)?  "non": "") |
         "deterministic");
       Println
         ("  FSA Queries_Are_Ordered: " |
           FSA.Queries_Are_Ordered(FSA.Root_Id()));
       Println("");
       Dump_One_Node(FSA, FSA.Root_Id(), Indent => 0);
    end func Dump_FSA;

    func Is_Nondeterministic(FSA; Check_Actions : Boolean := #false)
      -> Boolean is
      //  Return True if some node within the FSA is nondeterministic
      //  Only Check for ambiguous actions if Check_Actions is true.
       func Subtree_Is_Nondeterministic(Tree_Root : Node_Id) -> Boolean is
          ref Tree => FSA[Tree_Root];

          if Is_Nondeterministic(Tree, Check_Actions) then
             //  Root of subtree is nondeterministic
             return #true;
          else
             //  Check each successor
             return (for some Succ in 1 .. Num_Successors(Tree) =>
                       Subtree_Is_Nondeterministic(Successor(Tree, Succ)));
          end if;
       end func Subtree_Is_Nondeterministic;

       return Subtree_Is_Nondeterministic (Root_Id (FSA));
    end func Is_Nondeterministic;

    func Queries_Are_Ordered(FSA; Node_Id) -> Boolean is
      //  Return True if a sequence of non-end-states have queries
      //  ordered by Query_Id.
       ref N : Node+ => FSA[Node_Id];

       const Num_Outgoing := Num_Successors(N);
       const Q_Id := Query(N);
       var Some_In_Order : Boolean := #false;
       var All_Are_End_States : Boolean := #true;
          
       for Edge in 1 .. Num_Outgoing loop
          const Succ_Id := Successor(N, Edge);

          if not Is_End_State(N)
            and then Q_Id not null
          then
             ref Succ : Node+ => FSA[Succ_Id];

             All_Are_End_States := #false;

             if Query(Succ) is null
                  or else
                Query(Succ) > Q_Id
             then
                //  Something is in order
                Some_In_Order := #true;
             end if;
          end if;

          //  Recurse
          if not Queries_Are_Ordered(FSA, Succ_Id) then
             return #false;
          end if;
       end loop;

       //  Make sure that at least one path is in the expected order
       //  unless all are end states.
       return Some_In_Order or else All_Are_End_States;
    end func Queries_Are_Ordered;

    func Disambiguate_FSA(var FSA) is
      //  Remove nondeterminism from FSA for all but Action_Nodes

       func Disambiguate_Subtree(Tree_Root : Node_Id) is
          //  NOTE: Do not want to create a "ref" to FSA[Tree_Root] here
          //        as it should be treated as a long-lived R/W alias,
          //        which can cause trouble if the FSA vector is re-shaped
          //  TBD:  Fix ParaSail analyzer so it detects this problem.

          if Debug then
             Println("Node in Disambiguate_Subtree:");
             Dump_One_Node(FSA, Tree_Root, Indent => 2);
          end if;

          const Tree_Copy := FSA[Tree_Root];  //  Make copy to avoid aliasing

          const Remap : Ordered_Map<Node_Id, Node_Set> :=
                         Disambiguate(Tree_Copy, FSA);
            //  Map from each successor of updated Root
            //  to set of Node_Ids of old successors of Tree_Root
            //  that should be merged to produce new successor.
            //  If old successor set is a singleton, then that implies
            //  there was no change for that successor, other than a
            //  possible narrowing of its associated value set.
            //  If old successor set has multiple Node_Ids, then
            //  the (new) successor has a new Node_Id, that has not
            //  been filled in yet.

          for each [New_Node_Id => Old_Nodes] of Remap loop
             if |Old_Nodes| == 1 then
                //  Only one node in new successor, so should be same
                //  as original successor.
                {New_Node_Id in Old_Nodes}

                if Debug then
                   Println("Node survives into DFA:");
                   Dump_One_Node(FSA, New_Node_Id, Indent => 2);
                end if;

                null;  //  Nothing to be done.
             else
                //  Multiple nodes, implies New_Node_Id is really new
                {New_Node_Id not in Old_Nodes;
                 not Node_Is_Filled(FSA, New_Node_Id)}

                //  Determine which Query Id to merge
                //  by picking the query that comes first
                //  in the total ordering of query ids.
                //  NOTE: We are assuming the Branching_Query_Id
                //        comes later in the order than any "real" query id.
                var Old_Node_To_Clone : optional Node_Id := null;
                var Earliest_Query : optional Query_Id := null;
                for each O_Id of Old_Nodes forward loop
                   const Old_Q := Query(FSA[O_Id]);

                   if Old_Node_To_Clone is null  //  Nothing saved yet
                     or else
                      (Earliest_Query is null    //  Only actions so far
                       and then Old_Q not null   //  This is not an action
                       and then Old_Q != Others_Branching_Query_Id)
                                                 //  and not an others branch
                     or else
                      (Earliest_Query not null   //  Non-action saved
                       and then Old_Q not null   //  Next node not an action
                       and then Old_Q < Earliest_Query)  // with earlier query
                   then
                      Earliest_Query := Old_Q;
                      Old_Node_To_Clone := O_Id;
                   end if;
                end loop;

                //  Make a new node, using the old node with the earliest
                //  query.
                var New_Node := FSA[Old_Node_To_Clone];

                //  Set Node_Id to new value.
                Set_Id (New_Node, New_Node_Id);
                
                //  Now fill in node at New_Node_Id
                Set_Node(FSA, New_Node_Id, New_Node);

                if Debug then
                   Println
                     ("New node in DFA based on Node `(Old_Node_To_Clone):");
                   Dump_One_Node(FSA, New_Node_Id, Indent => 2);
                end if;

                //  Merge in other old nodes
                Merge_Nodes
                  (FSA[New_Node_Id], FSA, Old_Nodes - Old_Node_To_Clone);

                if Debug then
                   Println("New node in DFA after merge:");
                   Dump_One_Node(FSA, New_Node_Id, Indent => 2);
                end if;

             end if;
          end loop;

          //  Now recurse to disambiguate sub-subtrees
          for Edge in 1 .. Num_Successors(FSA[Tree_Root]) loop
             Disambiguate_Subtree(Successor(FSA[Tree_Root], Edge));
          end loop;
       end func Disambiguate_Subtree;

       Disambiguate_Subtree(Root_Id(FSA));
    end func Disambiguate_FSA;

    func FSA_Node_Action_Sets(FSA)
      -> Result : Ordered_Map<Node_Id, Ordered_Set<Action_Id>> is
       //  Return map of reachable nodes that are action nodes
       //  to their action sets
       Result := [];

       func Find_Action_Nodes(N : Node+) is
          case N of
             [A : Action_Node] =>
                //  Found an action_node, add it to the mapping
                Result |= [Id(A) => Action_Ids(A)];

             [M : Node+] =>
                for Edge in 1 .. Num_Successors(M) loop
                   //  Recurse on all successors of non-Action nodes
                   Find_Action_Nodes (FSA[Successor(N, Edge)]);
                end loop;
          end case;
       end func Find_Action_Nodes;
       
       Find_Action_Nodes(FSA[Root_Id(FSA)]);
    end func FSA_Node_Action_Sets;

    func FSA_Action_Node_Paths(FSA)
      -> Result : Ordered_Map
                    <Node_Id, Ordered_Set<Imageable_Vector<Edge_Index>>> is
       //  Return map from reachable nodes that are action nodes
       //  to the path(s) that reach(es) them (as a vector of edge indices).
       Result := [];

       func Build_Edge_Vectors
         (N : Node+; Path : Imageable_Vector<Edge_Index>) is
          case N of
             [A : Action_Node] =>
                //  Found an action_node, add it to the mapping
                if Id(A) not in Result then
                   //  First appearance of this action node.
                   //  Initialize its set of paths to []
                   Result |= [Id(A) => []];
                end if;

                //  Add the path to the set of paths
                Result[Id(A)] |= Path;

             [M : Node+] =>
                for Edge in 1 .. Num_Successors(M) loop
                   //  Recurse on all successors of non-Action nodes
                   //  with path augmented with edge index to the successor.
                   Build_Edge_Vectors (FSA[Successor(N, Edge)], Path | Edge);
                end loop;
          end case;
       end func Build_Edge_Vectors;
       
       Build_Edge_Vectors(FSA[Root_Id(FSA)], Path => []);
       if Debug then
          Println("Action Node Paths:");
          for each [Act_Node_Id => Paths] of Result forward loop
             Println(" `(Act_Node_Id) =>");
             for each Path of Paths forward loop
                Println("  " |(for each E of Path forward => <""> | " " | E));
             end loop;
          end loop;
       end if;
    end func FSA_Action_Node_Paths;

    func Winnow_And_Check_Actions
      (var FSA;
       Error_Action : optional Action_Id := null) is
      //  Remove "superset" actions, and check for
      //  Completeness, Ambiguity, and Redundancy
      //  Patterns are incomplete if the Error_Action
      //  (if any) remains after winnowing.

       const Initial_Node_Actions := FSA_Node_Action_Sets(FSA);

       const Action_Node_Paths := FSA_Action_Node_Paths(FSA);

       func Action_Node_Sets
         (Node_Actions : Ordered_Map<Node_Id, Ordered_Set<Action_Id>>)
         -> Result : Ordered_Map<Action_Id, Node_Set> is
         //  Create a mapping from each Action_Id to the set of Node_Ids
         //  where it appears.

          Result := [for Act_Id in 1 .. Num_Actions(FSA) => []];

          for each [N => Act_Set] of Node_Actions loop
             for each Act_Id of Act_Set loop
                //  Add node id to set associated with Act_Id
                Result[Act_Id] |= N;
             end loop;
          end loop;
       end func Action_Node_Sets;

       if Debug then
          Println("Action nodes are:" |
            (for each [N => Act_Set] of Initial_Node_Actions forward =>
               <""> | " " | N));
       end if;

       //  Create a mappng from each Action_Id to the set of Node_Ids
       //  where it appears.
       const Initial_Action_Node_Sets :=
         Action_Node_Sets(Initial_Node_Actions);

       if Debug then
          Println("Initial Action Id => Node Id mapping:");
          for each [Act_Id => N_Set] of Initial_Action_Node_Sets loop
             Println("  `(FSA.Action_String(Act_Id)) =>" |
               (for each N_Id of N_Set forward => <""> | " " | N_Id));
          end loop;
       end if;

       //  Remove an Action_Id from a given node, if another,
       //  earlier, Action_Id also appears in the given node,
       //  and the given Action_Id appears in all action nodes
       //  where the earlier Action_Id appears (i.e. the given
       //  Action_Id is a "superset" of the earlier Action_Id).

       for each [N_Id => Orig_Act_Ids] of Initial_Node_Actions loop
          //  Convert ordered set of action ids to a vector
          const Orig_Act_Vec : Vector<Action_Id> :=
            [for each Act_Id of Orig_Act_Ids forward => Act_Id];

          for each [I => Later_Act_Id] of Orig_Act_Vec reverse loop
            *Inner*
             for J in 1 ..< I loop
                const Earlier_Act_Id := Orig_Act_Vec[J];

                if Initial_Action_Node_Sets[Earlier_Act_Id] <=
                  Initial_Action_Node_Sets[Later_Act_Id]
                then
                   //  Later_Act_Id appears in a set of nodes that is a
                   //  superset of the Earlier_Act_Id, so remove it from
                   //  this node's Action_Ids
                   if Debug then
                      Println("  Removing `(Action_String
                                             (FSA,Later_Act_Id)) from" |
                        " node `(N_Id)");
                   end if;

                   case FSA[N_Id] of
                    [A : Action_Node] =>
                      Remove_Action(A, Later_Act_Id);
                    [N : Node+] =>
                      {*"Expected only Action_Nodes"* #false}
                   end case;

                   exit loop Inner;
                end if;
             end loop Inner;
          end loop;
       end loop;

       //  Get the updated node action sets
       const Final_Node_Actions := FSA_Node_Action_Sets(FSA);

       //  Get the final mappng from Action_Id to the set of Node_Ids
       //  where it still appears.
       const Final_Action_Node_Sets := Action_Node_Sets(Final_Node_Actions);

       if Debug then
          Println("Final Action Id => Node Id mapping:");
          for each [Act_Id => N_Set] of Final_Action_Node_Sets loop
             Println("  `(FSA.Action_String(Act_Id)) =>" |
               (for each N_Id of N_Set forward => <""> | " " | N_Id));
          end loop;
       end if;

       Print("Completeness check: ");
       if Error_Action is null then
          Println("not performed since no Error_Action provided");
       else
          ref Error_Nodes => Final_Action_Node_Sets[Error_Action];

          if |Error_Nodes| == 0 then
             Println("Patterns cover all possible values.");
          else
             Println("Patterns are incomplete; values not covered:");
             for N_Id in Error_Nodes forward loop
                for Path in Action_Node_Paths[N_Id] forward loop
                   Dump_Node_Path(FSA, Path, Indent => 2);
                end loop;
             end loop;
          end if;
       end if;

       Print("Ambiguity check: ");
       if (for all A_Set of Final_Node_Actions => |A_Set| == 1) then
          Println("No ambiguity found.");
       else
          Println("");
          for each [N_Id => A_Set] of Final_Node_Actions
            {|A_Set| > 1} forward loop
             Println("  Actions" |
               (for (each A_Id of A_Set;Sep := " " then ", ") forward =>
                 <""> | Sep | Action_String(FSA, A_Id)) |
               " overlap on values:");
             for Path in Action_Node_Paths[N_Id] forward loop
                Dump_Node_Path(FSA, Path, Indent => 4);
             end loop;
          end loop;
       end if;

       var All_Reachable : Boolean := #true;

       for each [A_Id => N_Set] of Final_Action_Node_Sets
         {Error_Action is null or else A_Id != Error_Action}
           forward loop
          if |N_Set| == 0 then
             if All_Reachable then
                Print("Some actions not reachable:");
                All_Reachable := #false;
             end if;
             Println(" `(Action_String(FSA, A_Id)) is hidden by:");

             //  Find all nodes where action originally appeared
             //  and say which values now go elsewhere.
             for each Orig_N_Id of Initial_Action_Node_Sets[A_Id] loop
                ref Orig_Node => FSA[Orig_N_Id];
                case Orig_Node of
                 [A : Action_Node] =>
                   const Final_Acts := Action_Ids(A);

                   //  Normally only one action after winnowing
                   //  unless there was ambiguity.
                   for (Final_Act in Final_Acts;
                        Is_First := #true then #false) forward loop
                      Print (Is_First? "  ": " and ");
                      Print(Action_String(FSA, Final_Act));
                   end loop;
                   Print(" with values:");
                   for Path in Action_Node_Paths[Orig_N_Id] forward loop
                      Dump_Node_Path(FSA, Path, Indent => 4);
                   end loop;

                 [N : Node+] =>
                   {*"Expecting only action nodes"* #false}
                end case;
             end loop;

          end if;
       end loop;
       if All_Reachable then
          Println("All `(Error_Action not null?"non-error ":"")actions " |
            "are reachable.");
       else
          Println("");
       end if;
    end func Winnow_And_Check_Actions;

end class FSA;

func Test_FSA() is

   func First_FSA() is
      type Int_Node is
        FSA::Countable_Node
          <Integer, Univ_Set => 1..3>;

      var FSA1 := FSA::Create();

      const Query_X := FSA1.Add_Query_Id("X");
      const Query_Y := FSA1.Add_Query_Id("Y");

      const Action_A := FSA1.Add_Action_Node("A");
      var Y_Eq_2 := Int_Node::Create(Query_Id => Query_Y);
      Y_Eq_2.Add_Successor (To => Action_A, Value => 2);
      var X_Eq_2 := Int_Node::Create(Query_Id => Query_X);
      X_Eq_2.Add_Successor (To => FSA1.Add_Node(Y_Eq_2), Value => 2);
      FSA1.Add_Root_Successor (X_Eq_2);

      const Action_B := FSA1.Add_Action_Node("B");
      var Y_In_2_3 := Int_Node::Create(Query_Id => Query_Y);
      Y_In_2_3.Add_Successor (To => Action_B, Values => 2..3);
      var X_In_1_2 := Int_Node::Create(Query_Id => Query_X);
      X_In_1_2.Add_Successor (To => FSA1.Add_Node(Y_In_2_3), Values => 1..2);
      FSA1.Add_Root_Successor (X_In_1_2);

      const Action_C := FSA1.Add_Action_Node("C");
      var Y_In_1_2 := Int_Node::Create(Query_Id => Query_Y);
      Y_In_1_2.Add_Successor (To => Action_C, Values => 1..2);
      var X_In_2_3 := Int_Node::Create(Query_Id => Query_X);
      X_In_2_3.Add_Successor (To => FSA1.Add_Node(Y_In_1_2), Values => 2..3);
      FSA1.Add_Root_Successor (X_In_2_3);

      const Action_E_Id := FSA1.Add_Action_Id("E");
      const Action_E_Node := FSA::Action_Node::Create(Action_E_Id);
      FSA1.Add_Root_Successor (Action_E_Node);

      Println("\nDump of original FSA");
      Dump_FSA(FSA1, Check_Actions => #true);

      Println("\nAbout to disambiguate\n");
      Disambiguate_FSA(FSA1);

      Println
        ("Now, FSA is `(Is_Nondeterministic(FSA1)? "non": "")deterministic");

      Println("\nDump of disambiguated FSA");
      Dump_FSA(FSA1);

      Winnow_And_Check_Actions(FSA1, Error_Action => Action_E_Id);

      Println("\nDump of winnowed FSA");
      Dump_FSA(FSA1, Check_Actions => #true);
   end func First_FSA;

   /////////////////////////
   func Second_FSA() is

      Println("\n--------------\n  Second FSA  \n--------------\n");
      var FSA2 := FSA::Create();

      type Bool_Node is FSA::Countable_Node
        <Boolean, Univ_Set => #false .. #true>;

      type Kind_Enum is Enum<[#univ_string, #basic_array, #normal]>;
      type Kind_Node is FSA::Countable_Node
        <Kind_Enum, Univ_Set => #univ_string .. #normal>;

      const Q_Null := FSA2.Add_Query_Id("Obj_Base.Is_Large_Null");
      const Q_Bad := FSA2.Add_Query_Id("Obj_Base.Is_Bad_Address");
      const Q_Kind := FSA2.Add_Query_Id("Type_Of_Obj.Kind");
      const Q_Poly := FSA2.Add_Query_Id("Type_Of_Obj.Is_Polymorphic");

      const A_Null := FSA2.Add_Action_Node("Prt(null)");
      const A_Bad := FSA2.Add_Action_Node("Prt(bad)");
      const A_Arr := FSA2.Add_Action_Node("ARR");
      const A_Poly := FSA2.Add_Action_Node("POLY");
      const A_Norm := FSA2.Add_Action_Node("NORM");
      const A_Simp := FSA2.Add_Action_Node("SIMP");
      const A_Error_Id := FSA2.Add_Action_Id("ERROR");

      var Is_Null_Node := Bool_Node::Create(Query_Id => Q_Null);
      Is_Null_Node.Add_Successor(A_Null, Value => #true);

      var Is_Bad_Node := Bool_Node::Create(Query_Id => Q_Bad);
      Is_Bad_Node.Add_Successor(A_Bad, Value => #true);
      
      var Nested_Case_Node := FSA::Branching_Node::Create();

      var Is_Arr_Node := Kind_Node::Create(Query_Id => Q_Kind);
      Is_Arr_Node.Add_Successor(A_Arr, Value => #basic_array);
      Nested_Case_Node.Add_Successor(FSA2.Add_Node(Is_Arr_Node));

      var Is_Poly_Node := Bool_Node::Create(Query_Id => Q_Poly);
      Is_Poly_Node.Add_Successor(A_Poly, Value => #true);
      var Is_Norm_Node := Kind_Node::Create(Query_Id => Q_Kind);
      Is_Norm_Node.Add_Successor
        (FSA2.Add_Node(Is_Poly_Node), Value => #normal);
      Is_Norm_Node.Add_Successor(A_Norm, Value => #normal);
      Nested_Case_Node.Add_Successor(FSA2.Add_Node(Is_Norm_Node));

      Nested_Case_Node.Add_Successor(A_Simp);

      Is_Bad_Node.Add_Successor
        (FSA2.Add_Node(Nested_Case_Node), Value => #false);

      Is_Null_Node.Add_Successor(FSA2.Add_Node(Is_Bad_Node), Value => #false);
      FSA2.Add_Root_Successor(Is_Null_Node);

      //  Include an error action to detect incompleteness
      FSA2.Add_Root_Successor(FSA::Action_Node::Create(A_Error_Id));

      Println("Second FSA");
      Dump_FSA(FSA2, Check_Actions => #true);

      Disambiguate_FSA(FSA2);

      Println("Disambiguated Second FSA");
      Dump_FSA(FSA2);

      Println("Winnow and Check Second FSA");
      Winnow_And_Check_Actions(FSA2, Error_Action => A_Error_Id);

      Println("Winnowed Second FSA");
      Dump_FSA(FSA2, Check_Actions => #true);

      //       case Obj_Base,Type_Of_Obj is
      //         when (Is_Large_Null),<> =>
      //           Prt("null");
      //         when (not Is_Large_Null, Is_Bad_Address),<> =>
      //           Prt("bad");
      //         when (not Is_Large_Null, not Is_Bad_Address),<> then
      //           when <>,(Kind => basic_array) => ARR;
      //           when <>,(Kind => normal,Is_Polymorphic) => POLY;
      //           when <>,(Kind => normal) => NORM;
      //           when others => SIMP;
      //         end when;
      //       end case;
      /////////////////////////
   end func Second_FSA;

   func Third_FSA() is
      Println("\n--------------\n  Third FSA  \n--------------\n");
      var FSA3 := FSA::Create();

      type Bool_Node is FSA::Countable_Node
        <Boolean, Univ_Set => #false .. #true>;

      type Kind_Enum is Enum<[#univ_string, #basic_array, #normal]>;
      type Kind_Node is FSA::Countable_Node
        <Kind_Enum, Univ_Set => #univ_string .. #normal>;

      const Q_Null := FSA3.Add_Query_Id("Obj_Base.Is_Large_Null");
      const Q_Bad := FSA3.Add_Query_Id("Obj_Base.Is_Bad_Address");
      const Q_Kind := FSA3.Add_Query_Id("Type_Of_Obj.Kind");
      const Q_Poly := FSA3.Add_Query_Id("Type_Of_Obj.Is_Polymorphic");

      const A_Null := FSA3.Add_Action_Node("Prt(null)");
      const A_Bad := FSA3.Add_Action_Node("Prt(bad)");
      const A_Arr := FSA3.Add_Action_Node("ARR");
      const A_Poly := FSA3.Add_Action_Node("POLY");
      const A_Norm := FSA3.Add_Action_Node("NORM");
      const A_Simp := FSA3.Add_Action_Node("SIMP");

      const A_Error_Id := FSA3.Add_Action_Id("ERROR");

      var Is_Null_Node := Bool_Node::Create(Query_Id => Q_Null);
      Is_Null_Node.Add_Successor(A_Null, Value => #true);

      var Is_Bad_Node := Bool_Node::Create(Query_Id => Q_Bad);
      Is_Bad_Node.Add_Successor(A_Bad, Value => #true);

      var Nested_Case_Node := FSA::Branching_Node::Create_Others_Branch();
      
      var Is_Arr_Node := Kind_Node::Create(Query_Id => Q_Kind);
      Is_Arr_Node.Add_Successor(A_Arr, Value => #basic_array);

      var Is_Poly_Node := Bool_Node::Create(Query_Id => Q_Poly);
      Is_Poly_Node.Add_Successor(A_Poly, Value => #true);
      var Is_Norm_Node := Kind_Node::Create(Query_Id => Q_Kind);
      Is_Norm_Node.Add_Successor
        (FSA3.Add_Node(Is_Poly_Node), Value => #normal);
      Is_Norm_Node.Add_Successor(A_Norm, Value => #normal);

      Nested_Case_Node.Add_Successor(FSA3.Add_Node(Is_Arr_Node));
      Nested_Case_Node.Add_Successor(FSA3.Add_Node(Is_Norm_Node));
      Nested_Case_Node.Add_Successor(A_Simp);

      FSA3.Add_Root_Successor(Is_Null_Node);
      FSA3.Add_Root_Successor(Is_Bad_Node);
      FSA3.Add_Root_Successor(Nested_Case_Node);

      //  Include an error action to detect incompleteness
      FSA3.Add_Root_Successor(FSA::Action_Node::Create(A_Error_Id));

      Println("Third FSA");
      Dump_FSA(FSA3, Check_Actions => #true);

      Disambiguate_FSA(FSA3);

      Println("Disambiguated Third FSA");
      Dump_FSA(FSA3);

      Println("Winnow and Check Third FSA");
      Winnow_And_Check_Actions(FSA3, Error_Action => A_Error_Id);

      Println("Winnowed Third FSA");
      Dump_FSA(FSA3, Check_Actions => #true);

      //       case Obj_Base,Type_Of_Obj is
      //         when (Is_Large_Null),<> =>
      //           Prt("null");
      //         when (Is_Bad_Address),<> =>
      //           Prt("bad");
      //         when others =>
      //           when <>,(Kind => basic_array) => ARR;
      //           when <>,(Kind => normal,Is_Polymorphic) => POLY;
      //           when <>,(Kind => normal) => NORM;
      //           when others => SIMP;
      //         end when;
      //       end case;
   end func Third_FSA;

   First_FSA();
   Second_FSA();
   Third_FSA();

end func Test_FSA;
