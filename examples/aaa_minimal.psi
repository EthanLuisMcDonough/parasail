// ParaSail Prototype Standard Library

// Copyright (C) 2011-2014, AdaCore, New York, NY
// This program is provided "as is" with no warranty.
// Report errors at http://groups.google.com/group/parasail-programming-language

abstract interface Any<> is
end interface Any;

abstract interface Assignable<> is
end interface Assignable;

interface Boolean<> is
    op "from_univ"(Lit : Univ_Enumeration) 
      {Lit in [#false | #true]}
      -> Boolean is import(#bool_from_univ);

    op "to_univ"(Val : Boolean) -> Univ_Enumeration 
      is import(#bool_to_univ);

    op "=?"(Left, Right : Boolean) -> Ordering
      is import("=?");
	// NOTE: #true > #false

    op "not"(Boolean) -> Boolean is import("not");
    op "and"(Left, Right : Boolean) -> Boolean is import("and");
    op "or"(Left, Right : Boolean) -> Boolean is import("or");
    op "xor"(Left, Right : Boolean) -> Boolean is import("xor");

    op "and="(var Left : Boolean; Right : Boolean);
    op "or="(var Left : Boolean; Right : Boolean);
    op "xor="(var Left : Boolean; Right : Boolean);

    func Hash(Val : Boolean) -> Univ_Integer
      is import(#identity);

    // For Imageable
    func To_String(Val : Boolean) -> Univ_String;
    func From_String(Str : Univ_String) -> optional Boolean;

end interface Boolean;

interface Set<Element_Type is Hashable<>> is
  // A hashed-set module
    op "[]"() -> Set;

    func Singleton(Elem : Element_Type) -> Set;

    op "|"(Left, Right : Element_Type) -> Set;
    op "|"(Left : Set; Right : Element_Type) -> Set;
    op "|"(Left : Element_Type; Right : Set) -> Set;
    op "|"(Left : Set; Right : Set) -> Set;

    op "|="(var Left : Set; Right : Set);

    op "|="(var Left : Set; Right : Element_Type);
	// Add element to Set.

    op "<|="(var Left : Set; var Right : optional Element_Type);
	// Move element into Set.

    op "<|="(var Left : Set; var Right : Set);
	// Move all elements of Right into Left, leaving Right empty.

    op "in"(Left : Element_Type; Right : Set) -> Boolean<>;

    op "=?"(Left, Right : Set) -> Ordering;
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise

    op "or"(Left, Right : Set) -> Set is "|"; // Union
    op "or="(var Left : Set; Right : Set) is "|=";

    op "+"(Left, Right : Set) -> Set is "|";  // Union
    op "+="(var Left : Set; Right : Set) is "|=";
    op "+="(var Left : Set; Right : Element_Type) is "|=";  // aka Include

    op "and"(Left, Right : Set) -> Set;
	// Intersection
    op "and="(var Left : Set; Right : Set);

    op "xor"(Left, Right : Set) -> Set;
	// Symmetric difference
    op "xor="(var Left : Set; Right : Set);

    op "-"(Left, Right : Set) -> Set;
	// Set difference

    op "-="(var Left : Set; Right : Set);
	// Compute Set difference

    op "-="(var S : Set; Elem : Element_Type);  // aka Exclude
	// Remove one element, if present

    func Count(S : Set) -> Univ_Integer;

    func Is_Empty(S : Set) -> Boolean<>;

    func Remove_Any(var S : Set) -> optional Element_Type;
      // Remove and return an arbitrary element of the Set S

    func Dump_Statistics(S : Set);
      // A debugging routine to show bucket sizes of Set

end interface Set;

interface Univ_Enumeration<> is
    op "=?"(Left, Right : Univ_Enumeration) -> Ordering 
      is import(#unordered_compare);
    func Print(Val : Univ_Enumeration) 
      is import(#print_univ_enum);

    func To_String(Val : Univ_Enumeration) -> Univ_String
      is import(#identity);

    func From_String(Str : Univ_String) -> optional Univ_Enumeration
      is import(#identity);

    func Hash(Val : Univ_Enumeration) -> Univ_Integer
      is import(#identity);

    op "in"(Left : Univ_Enumeration; Right : Set<Univ_Enumeration>) 
      -> Boolean<>
      is in Set<Univ_Enumeration>;

end interface Univ_Enumeration;

abstract interface Optional<> is
    op "null"() -> Optional;
    op "is null"(Optional) -> Boolean;
end interface Optional;

interface Ordering<> is
    op "from_univ"(Lit : Univ_Enumeration) 
      {Lit in [#less | #equal | #greater | #unordered]}
      -> Ordering is import(#ordering_from_univ);

    op "to_univ"(Val : Ordering) -> Univ_Enumeration 
      is import(#ordering_to_univ);

    op "to_bool"(Ord : Ordering; Mask : Univ_Integer) -> Boolean 
      is import(#ordering_to_bool);

    op "=?"(Left, Right : Ordering) -> Ordering is import("=?");

    func Hash(Val : Ordering) -> Univ_Integer
      is import(#identity);

    // For Imageable
    func To_String(Val : Ordering) -> Univ_String;
    func From_String(Str : Univ_String) -> optional Ordering;

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Ordering) -> Ordering 
      is import("+");
    op "+"(Left : Ordering; Right : Univ_Integer) -> Ordering 
      is import("+");
    op "-"(Left, Right : Ordering) -> Univ_Integer 
      is import("-");
    op "-"(Left : Ordering; Right : Univ_Integer) -> Ordering 
      is import("-");

    // TBD: These should be properties some day (e.g. Ordering#first).
    func First()->Ordering;
    func Last()->Ordering;

    op ".."(Left, Right : Ordering) -> Countable_Set<Ordering>;
    op "<.."(Left, Right : Ordering) -> Countable_Set<Ordering>;
    op "..<"(Left, Right : Ordering) -> Countable_Set<Ordering>;
    op "<..<"(Left, Right : Ordering) -> Countable_Set<Ordering>;
    op "|"(Left, Right : Ordering) -> Countable_Set<Ordering>;
end interface Ordering;

class Ordering is
    type Ordering_Set is Countable_Set<Ordering>;

  exports
    func First()->Ordering is
	return #less;
    end func First;

    func Last()->Ordering is
	return #unordered;
    end func Last;

    func To_String(Val : Ordering) -> Univ_String is
	case Val of
	  [#less] =>
	    return "#less";
	  [#equal] =>
	    return "#equal";
	  [#greater] =>
	    return "#greater";
	  [#unordered] =>
	    return "#unordered";
	end case;
    end func To_String;

    func From_String(Str : Univ_String) -> optional Ordering is
	case Str of
	  ["#less"] =>
	    return #less;
	  ["#equal"] =>
	    return #equal;
	  ["#greater"] =>
	    return #greater;
	  ["#unordered"] =>
	    return #unordered;
	  [..] =>
	    return null;
	end case;
    end func From_String;

    // NOTE: For implementation reasons, we put these here rather than defining
    //       them in the interface using "is in Countable_Set<Ordering>"
    op ".."(Left, Right : Ordering) -> Countable_Set<Ordering> is
	return Ordering_Set::".."(Left, Right);
    end op "..";

    op "<.."(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"<.."(Left, Right);
    end op "<..";

    op "..<"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"..<"(Left, Right);
    end op "..<";
    op "<..<"(Left, Right : Ordering) -> Countable_Set<Ordering> is
        return Ordering_Set::"<..<"(Left, Right);
    end op "<..<";

    op "|"(Left, Right : Ordering) -> Countable_Set<Ordering> is
	return Ordering_Set::"|"(Left, Right);
    end op "|";
end class Ordering;

abstract interface Comparable<> implements Assignable<> is
    op "=?"(Left, Right : Comparable) -> Ordering;
end interface Comparable;

abstract interface Ordered<> implements Comparable<> is
  // The "=?" operator on Ordered types never returns #unordered
  // They also provide a Min and Max operator.
    type Full_Ordering is Ordering;
      // {Full_Ordering in #less | #equal | #greater};

    op "=?"(Left, Right : Ordered) -> Full_Ordering;

    func Min(Left, Right : Ordered) -> Ordered;
    func Max(Left, Right : Ordered) -> Ordered;
end interface Ordered;

abstract interface Hashable<> implements Comparable<> is
    // Types which aren't ordered nevertheless are often
    // hashable, which makes it possible to create an efficient
    // set or map using them as the index type.
    op "=?"(Left, Right : Hashable) -> Ordering;
    func Hash(Val : Hashable) -> Univ_Integer;
end interface Hashable;

interface Countable_Set<Element_Type is Countable<>> is
    op "[]"() -> Countable_Set;

    func Singleton(Elem : Element_Type) -> Countable_Set;

    op ".."(Left, Right : Element_Type) -> Countable_Set;
    op "<.."(Left, Right : Element_Type) -> Countable_Set;
    op "..<"(Left, Right : Element_Type) -> Countable_Set;
    op "<..<"(Left, Right : Element_Type) -> Countable_Set;

    op "|"(Left, Right : Element_Type) -> Countable_Set;
    op "|"(Left : Countable_Set; Right : Element_Type) -> Countable_Set;
    op "|"(Left : Element_Type; Right : Countable_Set) -> Countable_Set;
    op "|"(Left : Countable_Set; Right : Countable_Set) -> Countable_Set;

    op "|="(var Left : Countable_Set; Right : Element_Type);
    op "|="(var Left : Countable_Set; Right : Countable_Set);

    op "<|="(var Left : Countable_Set; var Right : optional Element_Type);
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Countable_Set; var Right : Countable_Set);
	// Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Countable_Set) -> Countable_Set;
      // Set difference
    op "-="(var S : Countable_Set; Elem : Element_Type);
      // Remove the given element from the set, if present
    op "-="(var Left : Countable_Set; Right : Countable_Set);
      // Remove all elements of Right from Left, if present

    op "or"(Left : Countable_Set; Right : Countable_Set) 
      -> Countable_Set is "|";  // union
    op "or="(var Left : Countable_Set; Right : Countable_Set) is "|=";

    op "+"(Left : Countable_Set; Right : Countable_Set) 
      -> Countable_Set is "|";  // Union
    op "+="(var Left : Countable_Set; Right : Countable_Set) is "|=";
    op "+="(var Left : Countable_Set; Right : Element_Type) is "|=";
   
    op "and"(Left, Right : Countable_Set) -> Countable_Set;
	// Intersection
    op "and="(var Left : Countable_Set; Right : Countable_Set);

    op "xor"(Left, Right : Countable_Set) -> Countable_Set;
	// Symmetric difference
    op "xor="(var Left : Countable_Set; Right : Countable_Set);

    op "in"(Left : Element_Type; Right : Countable_Set) -> Boolean;

    op "=?"(Left, Right : Countable_Set) -> Ordering;
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise

    func Count(S : Countable_Set) -> Univ_Integer;

    func Is_Empty(S : Countable_Set) -> Boolean;

    func First(S : Countable_Set) -> optional Element_Type;
    func Last(S : Countable_Set) -> optional Element_Type;

    func Remove_First(var S : Countable_Set) -> optional Element_Type;
	// Remove first element of set (lowest value)

    func Remove_Last(var S : Countable_Set) -> optional Element_Type;
	// Remove last element of set (highest value)

    func Remove_Any(var S : Countable_Set) -> optional Element_Type;
	// Remove an arbitrary element of set

end interface Countable_Set;

abstract interface Countable<> implements Ordered<> is
    op "+"(Left : Countable; Right : Univ_Integer) -> Countable;
    op "+"(Left : Univ_Integer; Right : Countable) -> Countable;

    op "-"(Left : Countable; Right : Univ_Integer) -> Countable;
    op "-"(Left, Right : Countable) -> Univ_Integer;

    op "=?"(Left, Right : Countable) -> Ordered::Full_Ordering;

    func First() -> Countable;

    func Last() -> Countable;

    func Hash(Val : Countable) -> Univ_Integer;

    op ".."(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>;
    op "<.."(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>;
    op "..<"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>;
    op "<..<"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>;
    op "|"(Left, Right : Countable) -> Countable_Set<Countable>
      is in Countable_Set<Countable>;
end interface Countable;
    
interface Univ_Integer<> is
    op "+"(Right : Univ_Integer) -> Univ_Integer
      is import(#identity);

    op "-"(Right : Univ_Integer) -> Univ_Integer
      is import(#negate);

    op "abs"(Right : Univ_Integer) -> Univ_Integer
      is import("abs");

    op "+"(Left, Right : Univ_Integer) -> Result : Univ_Integer 
      is import("+");

    op "-"(Left, Right : Univ_Integer) -> Result : Univ_Integer
      is import("-");

    op "*"(Left, Right : Univ_Integer) -> Result : Univ_Integer 
      is import("*");

    op "/"(Left, Right : Univ_Integer) -> Result : Univ_Integer
      is import("/");

    op "**"(Left, Right : Univ_Integer) -> Univ_Integer
      is import("**");

    op "mod"(Left, Right : Univ_Integer) -> Univ_Integer
      is import("mod");

    op "rem"(Left, Right : Univ_Integer) -> Univ_Integer
      is import("rem");


    op "+="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("+=");

    op "-="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("-=");

    op "*="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("*=");

    op "/="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("/=");

    op "**="(var Left : Univ_Integer; Right : Univ_Integer) 
      is import("**=");


    op "=?"(Left, Right : Univ_Integer) -> Ordering
      is import("=?");

    op ">>"(Univ_Integer; Univ_Integer) -> Univ_Integer is import(">>");

    op "<<"(Univ_Integer; Univ_Integer) -> Univ_Integer is import("<<");

    func Min(Left, Right : Univ_Integer) -> Univ_Integer
      is import(#min);
    func Max(Left, Right : Univ_Integer) -> Univ_Integer
      is import(#max);

    func Hash(Val : Univ_Integer) -> Univ_Integer
      is import(#identity);

    func Print(X : Univ_Integer) is import(#print_int);

    func To_String(Val : Univ_Integer) -> Univ_String
      is import(#to_string_int);

    func From_String(Str : Univ_String) -> optional Univ_Integer
      is import(#from_string_int);

    func First() -> Univ_Integer is
      import(#univ_integer_first);

    func Last() -> Univ_Integer is
      import(#univ_integer_last);

    op ".."(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>;
    op "<.."(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>;
    op "..<"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>;
    op "<..<"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>;
    op "|"(Left, Right : Univ_Integer) -> Countable_Set<Univ_Integer>
      is in Countable_Set<Univ_Integer>;
end interface Univ_Integer;

interface Countable_Range<Bound_Type is Countable<>> is
    // Simple contiguous Countable_Range of integers (i.e. an interval)
    const First : Bound_Type;
    const Last : Bound_Type;
    op ".."(Left, Right : Bound_Type) -> Countable_Range;
    op "<.."(Left, Right : Bound_Type) -> Countable_Range;
    op "..<"(Left, Right : Bound_Type) -> Countable_Range;
    op "<..<"(Left, Right : Bound_Type) -> Countable_Range;
    op "in"(Val : Bound_Type; Int : Countable_Range) -> Boolean;
    func Length(R : Countable_Range) -> Univ_Integer;
    op "[..]"() -> Countable_Range;
    op "[]"() -> Countable_Range;
    func Singleton(Bound : Bound_Type) -> Countable_Range;

    func Remove_First(var S : Countable_Range) -> optional Bound_Type;
    func Remove_Last(var S : Countable_Range) -> optional Bound_Type;
    func Remove_Any(var S : Countable_Range) -> optional Bound_Type;
end interface Countable_Range;

class Countable_Range is
  exports
    op ".."(Left, Right : Bound_Type) -> Countable_Range is
	return (First => Left, Last => Right);
    end op "..";

    op "<.."(Left, Right : Bound_Type) -> Countable_Range is
	return (First => Left+1, Last => Right);
    end op "<..";

    op "..<"(Left, Right : Bound_Type) -> Countable_Range is
	return (First => Left, Last => Right-1);
    end op "..<";

    op "<..<"(Left, Right : Bound_Type) -> Countable_Range is
	return (First => Left+1, Last => Right-1);
    end op "<..<";

    op "in"(Val : Bound_Type; Int : Countable_Range) -> Boolean is
	return Val >= Int.First and then Val <= Int.Last;
    end op "in";

    func Length(R : Countable_Range) -> Univ_Integer is
	return R.Last - R.First + 1;
    end func Length;

    op "[]"() -> Countable_Range is
	return Bound_Type::First()+1 .. Bound_Type::First();
    end op "[]";

    op "[..]"() -> Countable_Range is
        return Bound_Type::First() .. Bound_Type::Last();
    end op "[..]";

    func Singleton(Bound : Bound_Type) -> Countable_Range is
	return Bound .. Bound;
    end func Singleton;

    func Remove_First(var S : Countable_Range) 
      -> Result : optional Bound_Type is
	if S.First <= S.Last then
	    Result := S.First;
	    S := (First => S.First+1, Last => S.Last);
	else
	    Result := null;
	end if;
    end func Remove_First;
	
    func Remove_Last(var S : Countable_Range) 
      -> Result : optional Bound_Type is
	if S.First <= S.Last then
	    Result := S.Last;
	    S := (First => S.First, Last => S.Last-1);
	else
	    Result := null;
	end if;
    end func Remove_Last;

    func Remove_Any(var S : Countable_Range) 
      -> Result : optional Bound_Type is
	if S.First <= S.Last then
	    if (S.Last - S.First) mod 2 == 0 then
		return Remove_First(S);
	    else
		return Remove_Last(S);
	    end if;
	else
	    return null;
	end if;
    end func Remove_Any;

end class Countable_Range;

interface Univ_Character<> is
    func Print(C : Univ_Character) is import(#print_char);

    op "+"(Left : Univ_Character; Right : Univ_Integer) -> Univ_Character
      is import("+");
    op "+"(Left : Univ_Integer; Right : Univ_Character) -> Univ_Character
      is import("+");

    op "-"(Left : Univ_Character; Right : Univ_Integer) -> Univ_Character
      is import("-");
    op "-"(Left, Right : Univ_Character) -> Univ_Integer
      is import("-");

    op "*"(Left : Univ_Integer; Right : Univ_Character) -> Univ_String;
	// Produce specified number of "Right" chars in a row
    op "*"(Left : Univ_Character; Right : Univ_Integer) -> Univ_String;
	// Produce specified number of "Left" chars in a row

    op "=?"(Left, Right : Univ_Character) -> Ordering
      is import("=?");

    func To_String(Val : Univ_Character) -> Univ_String
      is import(#to_string_char);

    func From_String(Str : Univ_String) -> optional Univ_Character
      is import(#from_string_char);

    func Hash(Val : Univ_Character) -> Univ_Integer
      is import(#identity);

    func First() -> Univ_Character;

    func Last() -> Univ_Character;

    op ".."(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>;
    op "<.."(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>;
    op "..<"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>;
    op "<..<"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>;
    op "|"(Left, Right : Univ_Character) -> Countable_Set<Univ_Character>
      is in Countable_Set<Univ_Character>;
end interface Univ_Character;
    
class Univ_Character is
  exports
    op "*"(Left : Univ_Integer; Right : Univ_Character) -> Univ_String is
	// Produce specified number of "Right" chars in a row
	return Left * To_String(Right);  // Just pass the buck to the string op
    end op "*";

    op "*"(Left : Univ_Character; Right : Univ_Integer) -> Univ_String is
	// Produce specified number of "Left" chars in a row
	return Right * To_String(Left);  // Just pass the buck to the string op
    end op "*";

    func First() -> Univ_Character is
	return '\0';
    end func First;

    func Last() -> Univ_Character is
	return '\0' + 2**31-1;
    end func Last;
end class Univ_Character;

abstract interface Imageable<> is
    func To_String(Val : Imageable) -> Univ_String<>;

    func From_String(Str : Univ_String<>) -> optional Imageable;
end interface Imageable;

interface Univ_String<> is
    func Print(Univ_String) is import(#print_string);
    func Println(Univ_String) is import(#println_string);
    func Readln() -> optional Univ_String is import(#read_string);

    op "*"(Left : Univ_Integer; Right : Univ_String) -> Univ_String;
	// Produce specified number of "Right" strings in a row
    op "*"(Left : Univ_String; Right : Univ_Integer) -> Univ_String;
	// Produce specified number of "Left" strings in a row

    op "|"(Left, Right : Univ_String) -> Univ_String 
      is import(#concat_string);

    op "=?"(Left, Right : Univ_String) -> Ordering
      is import(#string_compare);

    op "|="(var Left : Univ_String; Right : Univ_String)
      is import(#assign_concat_string);

    op "indexing"(Str : Univ_String; Index : Univ_Integer<>) -> Univ_Character
      is import(#string_indexing);
	// a "read-only" element, indexed 1..Length(Str)

    op "slicing"(Str : Univ_String; 
      Index_Set : Countable_Range<Univ_Integer>) 
      -> Univ_String is import(#string_slicing);
	// a "read-only" slice

    func Length(Str : Univ_String) -> Univ_Integer
      is import(#string_length);

    func Hash(Val : Univ_String) -> Univ_Integer
      is import(#identity);

    op "|"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      -> Univ_String;

    op "|"(Left : Left_Type is Imageable<>; Right : Univ_String)
      -> Univ_String;

    op "|="(var Left : Univ_String; Right : Right_Type is Imageable<>);

end interface Univ_String;
    
class Univ_String is
  exports
    op "*"(Left : Univ_Integer; Right : Univ_String) -> Univ_String is
	// Produce specified number of "Right" strings in a row
	if Left <= 0 then
	    return "";
	elsif Left == 1 then
	    return Right;
	else
	    // Recurse to produce half-length, and then combine
	    const Partial : Univ_String := (Left/2) * Right;
	    if Left mod 2 == 1 then
		return Partial | Partial | Right;
	    else
		return Partial | Partial;
	    end if;
	end if;
    end op "*";

    op "*"(Left : Univ_String; Right : Univ_Integer) -> Univ_String is
	// Produce specified number of "Left" strings in a row
	return Right * Left;  // Just pass the buck to other "*"
    end op "*";

    op "|"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      -> Univ_String is
	return Left | Right_Type::To_String(Right);
    end op "|";

    op "|"(Left : Left_Type is Imageable<>; Right : Univ_String)
      -> Univ_String is
	return Left_Type::To_String(Left) | Right;
    end op "|";

    op "|="(var Left : Univ_String; Right : Right_Type is Imageable<>) is
	Left |= Right_Type::To_String(Right);
    end op "|=";
end class Univ_String;

interface Random<> is
    func Start(Seed : Univ_Integer := 1) -> Random;
      // Start a new random number sequence with a standard multiplier/modulus

    func Start(Seed : Univ_Integer;
       Mult, Mod : Univ_Integer) -> Random;
      // Start a new random number sequence with given multiplier and modulus

    func Next(var Seq : Random) -> Univ_Integer;
      // Get next value in random number sequence
end interface Random;

class Random is
    var Last_Value : Univ_Integer;
    const Mult : Univ_Integer;
    const Mod : Univ_Integer;
    const Debugging : Boolean := #false;
  exports
    func Start(Seed : Univ_Integer) -> Random is
      // Start a new random number sequence with a standard multiplier/modulus
	return (Last_Value => Seed,
	  Mult => 7**5, Mod => 2**31 - 1);
    end func Start;

    func Start(Seed : Univ_Integer;
      Mult, Mod : Univ_Integer) -> Random is
      // Start a new random number sequence with given multiplier and modulus
	return (Last_Value => Seed, Mult => Mult, Mod => Mod);
    end func Start;

    func Next(var Seq : Random) -> Univ_Integer is
      // Get next value in random number sequence
	Seq.Last_Value := Seq.Last_Value * Seq.Mult mod Seq.Mod;
	return Seq.Last_Value;
    end func Next;
end class Random;

abstract interface Sequence<Element_Type is Assignable<>> is
    func Remove_First(var S : Sequence) -> optional Element_Type;
      // Returns null when sequence is empty
end interface Sequence;

interface Direction<> is
    // This is passed to the "to_sequence" operator to generate
    // appropriate direction of sequence
    op "from_univ"(Lit : Univ_Enumeration)
      {Lit in #unordered | #forward | #reverse | #concurrent} -> Direction 
      is import(#direction_from_univ);

    op "to_univ"(Val : Direction) -> Univ_Enumeration 
      is import(#direction_to_univ);

    op "=?"(Left, Right : Direction) -> Ordering
      is import("=?");
end interface Direction;

interface Integer<Range : Countable_Range<Univ_Integer> := [..]> is
    op "from_univ"(Lit : Univ_Integer) -> Integer 
      is import(#integer_from_univ);

    op "to_univ"(Val : Integer) -> Univ_Integer 
      is import(#integer_to_univ);

    op "+"(Right : Integer) -> Integer
      is import(#identity);

    op "-"(Right : Integer) -> Integer
      is import(#negate);

    op "abs"(Right : Integer) -> Integer
      is import("abs");

    op "+"(Left, Right : Integer) -> Result : Integer 
      is import("+");

    op "-"(Left, Right : Integer) -> Result : Integer
      is import("-");

    op "*"(Left, Right : Integer) -> Result : Integer 
      is import("*");

    op "/"(Left, Right : Integer) -> Result : Integer
      is import("/");

    op "mod"(Left, Right : Integer) -> Integer
      is import("mod");

    op "rem"(Left, Right : Integer) -> Integer
      is import("rem");

    op "**"(Left, Right : Integer) -> Result : Integer
      is import("**");

    op "+="(var Left : Integer; Right : Integer) 
      is import("+=");

    op "-="(var Left : Integer; Right : Integer) 
      is import("-=");

    op "*="(var Left : Integer; Right : Integer) 
      is import("*=");

    op "/="(var Left : Integer; Right : Integer) 
      is import("/=");

    op "**="(var Left : Integer; Right : Integer) 
      is import("**=");

    op "=?"(Left, Right : Integer) -> Ordering
      is import("=?");

    op ">>"(Integer; Integer) -> Integer is import(">>");

    op "<<"(Integer; Integer) -> Integer is import("<<");

    func Min(Left, Right : Integer) -> Integer
      is import(#min);
    func Max(Left, Right : Integer) -> Integer
      is import(#max);

    func Hash(Val : Integer) -> Univ_Integer
      is import(#identity);

    func Print(X : Integer) is import(#print_int);

    func To_String(Val : Integer) -> Univ_String
      is import(#to_string_int);

    func From_String(Str : Univ_String) -> optional Integer
      is import(#from_string_int);

    func First() -> Integer;

    func Last() -> Integer;

    op "[..]"()->Countable_Range<Integer> is in Countable_Range<Integer>;

    op ".."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>;
    op "<.."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>;
    op "..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>;
    op "<..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>;
    op "|"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>;
  implements
  for Countable
    // These operations are needed so Integer satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an integer to an int-literal).

    op "+"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("+");

    op "+"(Left : Univ_Integer; Right : Integer) -> Result : Integer 
      is import("+");

    op "-"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("-");

    op "-"(Left, Right : Integer) -> Result : Univ_Integer
      is import("-");

end interface Integer;

class Integer is
    const Content : Univ_Integer;  -- So this ends up as a wrapper
  exports
    func First() -> Integer is
	return Range.First;
    end func First;

    func Last() -> Integer is
	return Range.Last;
    end func Last;

end class Integer;
    
class Boolean is
  exports
    op "and="(var Left : Boolean; Right : Boolean) is
	Left := Left and Right;
    end op "and=";

    op "or="(var Left : Boolean; Right : Boolean) is
	Left := Left or Right;
    end op "or=";

    op "xor="(var Left : Boolean; Right : Boolean) is
	Left := Left xor Right;
    end op "xor=";

    func To_String(Val : Boolean) -> Univ_String is
	if Val then
	    return "#true";
	else
	    return "#false";
	end if;
    end func To_String;

    func From_String(Str : Univ_String) -> optional Boolean is
	if Str == "#true" then
	    return #true;
	elsif Str == "#false" then
	    return #false;
	else
	    return null;
	end if;
    end func From_String;

end class Boolean;

interface Basic_List<List_Elem is Assignable<>> is
    var Elem : List_Elem;
    var Next : optional Basic_List;

    op "|"(Left : List_Elem; Right : List_Elem) -> Basic_List;
    op "|"(Left : List_Elem; Right : Basic_List) -> Basic_List;
    op "|"(Left : Basic_List; Right : Basic_List) -> Basic_List;
    op "|"(Left : Basic_List; Right : List_Elem) -> Basic_List;

    op "|="(var Left : Basic_List; Right : Basic_List);
    op "|="(var Left : Basic_List; Right : List_Elem);

    func Remove_First(var L : Basic_List) -> optional List_Elem;
    func Remove_Last(var L : Basic_List) -> optional List_Elem;
    func Remove_Any(var L : Basic_List) -> optional List_Elem;
end interface Basic_List;

class Basic_List is
  exports
    op "|"(Left : List_Elem; Right : List_Elem) -> Basic_List is
        return (Elem => Left, Next => (Elem => Right, Next => null));
    end op "|";

    op "|"(Left : List_Elem; Right : Basic_List) -> Basic_List is
        return (Elem => Left, Next => Right);
    end op "|";

    op "|"(Left : Basic_List; Right : Basic_List) -> Basic_List is
        if Left is null then
            // Left is null, so just return Right
            return Right;
        else
            // Recurse with tail of left Basic_list
            return (Elem => Left.Elem, Next => Left.Next | Right);
        end if;
    end op "|";

    op "|"(Left : Basic_List; Right : List_Elem) -> Basic_List is
        return Left | (Elem => Right, Next => null);
    end op "|";

    op "|="(var Left : Basic_List; Right : Basic_List) is
        if Left is null then
            Left := Right;
        else
            // Recurse with tail of Basic_list
            Left.Next |= Right;
        end if;
    end op "|=";

    op "|="(var Left : Basic_List; Right : List_Elem) is
        // Just pass the buck
        Left |= (Elem => Right, Next => null);
    end op "|=";

    func Remove_First(var L : Basic_List) 
      -> Result : optional List_Elem is
        if L is null then
            return null;
        else
            Result := L.Elem;
            L <== L.Next;
              // carve off L.Next and set L to that
        end if;
    end func Remove_First;

    func Remove_Last(var L : Basic_List) 
      -> Result : optional List_Elem is
        if L is null then
            return null;
        elsif L.Next is null then
            Result := L.Elem;
            L := null;
        else
            // Recurse to remove last element
            return Remove_Last(L.Next);
        end if;
    end func Remove_Last;

    func Remove_Any(var L : Basic_List) 
      -> Result : optional List_Elem is
        // Easiest to remove first element
        return Remove_First(L);
    end func Remove_Any;

end class Basic_List;


interface Closed_Interval<Bound_Type is Comparable<>> is
    // This provides a simple "closed" interval X..Y
    // If a type is countable, then half-open or fully open intervals
    // can be converted into the equivalent closed interval.
    var Low : Bound_Type;
    var High : Bound_Type;
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean;
    op "=?"(Left, Right : Closed_Interval) -> Ordering;
end interface Closed_Interval;

class Closed_Interval is
  exports
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean is
        return Left >= Right.Low and then Left <= Right.High;
    end op "in";

    op "=?"(Left, Right : Closed_Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.

        if Left.High < Right.Low then
            return #less;
        elsif Left.Low > Right.High then
            return #greater;
        elsif Left.Low == Right.Low and then
          Left.High == Right.High then
            return #equal;
        else
            return #unordered;
        end if;
    end op "=?";

end class Closed_Interval;

interface Interval<Bound_Type is Comparable<>> is
    // This supports closed, half-open, and open intervals.
    // This is appropriate for uncountable types where you
    // can't normalize all intervals into closed intervals.
    var Low : Bound_Type;
    var Low_Is_Open : Boolean;
    var High : Bound_Type;
    var High_Is_Open : Boolean;

    func Singleton(Val : Bound_Type) -> Interval;
      // Return interval consisting of a single value

    func Is_Empty(IV : optional Interval) -> Boolean;
      // Return True if interval is null or it represents
      // no values

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean;

    op "=?"(Left, Right : Interval) -> Ordering;
      // "#greater" means Left is strictly greater than Right
      // "#less" means Left is strictly less than Right
      // "#equal" means Left and Right are the same interval
      // "#unordered" means anything else

    op "and"(Left, Right : Interval) -> optional Interval;
      // Return intersection of the two intervals

    op "and="(var Left : optional Interval; Right : Interval);
      // Intersect Right into Left

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean;
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> optional Interval;
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)};
      // Subtract Right interval from Left

    func Overlaps(Left, Right : optional Interval) -> Boolean;
      // Return True if intervals overlap

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval;
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval is "or";

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)};
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is "or=";

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)};
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.

end interface Interval;

class Interval is
  exports
    func Singleton(Val : Bound_Type) -> Interval is
      // Return interval consisting of a single value
	return (Low => Val, Low_Is_Open => #false,
	  High => Val, High_Is_Open => #false);
    end func Singleton;

    func Is_Empty(IV : optional Interval) -> Boolean is
      // Return True if interval is null or it represents
      // no values
	return IV is null or else
	  IV.Low > IV.High or else
	  (IV.Low == IV.High and then (IV.Low_Is_Open or IV.High_Is_Open));
    end func Is_Empty;

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean is
        case Left =? Right.Low of
          [#less] => return #false;
          [#equal] => return not Right.Low_Is_Open;
          [#greater] =>
            case Left =? Right.High of
              [#less] => return #true;
              [#equal] => return not Right.High_Is_Open;
              [#greater] => return #false;
            end case;
        end case;
    end op "in";

    op "=?"(Left, Right : Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.
        // Return #unordered if any of the comparisons return #unordered.

        // First check for perfect equality
        if Left.Low == Right.Low and then
          Left.High == Right.High and then
          Left.Low_Is_Open == Right.Low_Is_Open and then
          Left.High_Is_Open == Right.High_Is_Open then
            // NOTE: We are considering X..Y-1 != X..<Y since
            //       we don't require countable elements.
            return #equal;
        end if;

        case Left.High =? Right.Low of
          [#unordered] =>
            return #unordered;
          [#less] =>
            return #less;
          [#equal] =>
            if Left.High_Is_Open or else Right.Low_Is_Open then
                // No overlap
                return #less;
            else
                // We have already ruled out #equal
                return #unordered;
            end if;
          [#greater] =>
            // Not clearly less, see whether clearly greater.
            case Left.Low =? Right.High of
              [#unordered] =>
                return #unordered;
              [#less] =>
                // We have already ruled out #equal
                return #unordered;
              [#equal] =>
                if Left.Low_Is_Open or else Right.High_Is_Open then
                    // No overlap
                    return #greater;
                else
                    // We have already ruled out #equal
                    return #unordered;
                end if;
              [#greater] =>
                return #greater;
            end case;
        end case;
    end op "=?";

    op "and"(Left, Right : Interval) -> optional Interval is
      // Return intersection of the two intervals
	var New_Low : Bound_Type;
	var New_High : Bound_Type;
        var New_Low_Is_Open : Boolean;
	var New_High_Is_Open : Boolean;
	
	case Left.Low =? Right.Low of
	  [#less] => 
	    New_Low := Right.Low;
	    New_Low_Is_Open := Right.Low_Is_Open;
	  [#greater] => 
	    New_Low := Left.Low;
	    New_Low_Is_Open := Left.Low_Is_Open;
	  [#equal] => 
	    New_Low := Left.Low;
	    New_Low_Is_Open := Left.Low_Is_Open or Right.Low_Is_Open;
	  [#unordered] => 
	    return null;
	end case;

	case Left.High =? Right.High of
	  [#less] => 
	    New_High := Left.High;
	    New_High_Is_Open := Left.High_Is_Open;
	  [#greater] => 
	    New_High := Right.High;
	    New_High_Is_Open := Right.High_Is_Open;
	  [#equal] => 
	    New_High := Left.High;
	    New_High_Is_Open := Left.High_Is_Open or Right.High_Is_Open;
	  [#unordered] => 
	    return null;
	end case;

	return (Low => New_Low, Low_Is_Open => New_Low_Is_Open,
	  High => New_High, High_Is_Open => New_High_Is_Open);
    end op "and";

    op "and="(var Left : optional Interval; Right : Interval) is
      // Intersect Right into Left
	if Left not null then
	    Left := Left and Right;
	end if;
    end op "and=";

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean is
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.
	if Right is null or else Left is null then
	    return #false;
	end if;
	return (Left.Low > Right.Low or else 
	  (Left.Low == Right.Low and then Left.Low_Is_Open > Right.Low_Is_Open))
	  and then
	    (Left.High < Right.High or else
	     (Left.High == Right.High and then 
	      Left.High_Is_Open > Right.High_Is_Open));
    end func Is_Strictly_Within;

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> Result : optional Interval is
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.
	var New_Low : Bound_Type;
	var New_High : Bound_Type;
        var New_Low_Is_Open : Boolean;
	var New_High_Is_Open : Boolean;
	
	case Left.Low =? Right.Low of
	  [#less] => 
	    // Return left part of Left
	    Result := (Low => Left.Low, Low_Is_Open => Left.Low_Is_Open,
	      High => Right.Low, High_Is_Open => not Right.Low_Is_Open);
	  [#greater] => 
	    // Return right part of Left
	    Result := (Low => Right.High, Low_Is_Open => not Right.High_Is_Open,
	      High => Left.High, High_Is_Open => Left.High_Is_Open);
	  [#equal] => 
	    if Left.Low_Is_Open >= Right.Low_Is_Open then
		// Return right part of Left
		Result := (Low => Right.High, 
		  Low_Is_Open => not Right.High_Is_Open,
		  High => Left.High, 
		  High_Is_Open => Left.High_Is_Open);
	    else
		-- Only one element is left
		return (Left.Low, #false, Left.Low, #false);
	    end if;
	  [#unordered] => 
	    return null;
	end case;

	if Result.Low > Result.High then
	    -- Empty interval
	    return null;
	elsif Result.Low == Result.High and then
	  (Result.Low_Is_Open or Result.High_Is_Open) then
	    -- Empty interval
	    return null;
	else
	    return Result;
	end if;
    end op "-";

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)} is
      // Subtract Right interval from Left
	if Left not null then
	    Left := Left - Right;
	end if;
    end op "-=";

    func Overlaps(Left, Right : optional Interval) -> Boolean is
	if Left is null or else Right is null then
	    return #false;
	else
	    case Left =? Right of
	      [#equal | #unordered] => return #true;
	      [#less | #greater] => return #false;
	    end case;
	end if;
    end func Overlaps;

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} 
      -> Result : Interval is
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
	
	Result := Left;
	Result or= Right;
    end op "or";

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
	var Right_Copy for Left := Right;
	Left <|= Right_Copy;
    end op "or=";

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)} is
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.
	if Left is null then
	    Left <== Right;
	elsif Right not null then
	    var Right_Copy <== Right;
		// Make copy and null out Right, so
		// we don't end up with Right partially nulled out
	    
	    case Left.Low =? Right_Copy.Low of
	      [#less] => 
		// No change to Left.Low
		null;
	      [#greater] => 
		Left.Low <== Right_Copy.Low;
		Left.Low_Is_Open := Right_Copy.Low_Is_Open;
	      [#equal] => 
		Left.Low_Is_Open and= Right_Copy.Low_Is_Open;
	    end case;

	    case Left.High =? Right_Copy.High of
	      [#less] => 
		Left.High <== Right_Copy.High;
		Left.High_Is_Open := Right_Copy.High_Is_Open;
	      [#greater] => 
		// No change to Left.High
		null;
	      [#equal] => 
		Left.High_Is_Open and= Right_Copy.High_Is_Open;
	    end case;
	end if;
    end op "<|=";

end class Interval;

interface AA_Tree<Element is Comparable<>> is

    // This module implements a balanced "AA" tree, originally
    // described by Arne Andersson in the "Proceedings of the Workshop
    // on Algorithms and Data Structures," pp 60-71, Springer Verlag, 1993.
    // The following algorithm and descriptions were taken from the
    // WikiPedia article on AA_Tree: 
    //       http://en.wikipedia.org/wiki/AA_tree
    // Note that various additional checks for a null tree have been added.

    // Only two operations are needed for maintaining balance in an AA tree.
    // These operations are called skew and split. Skew is a right rotation
    // when an insertion or deletion creates a left horizontal link. Split
    // is a conditional left rotation when an insertion or deletion creates two
    // horizontal right links, which once again corresponds to two
    // consecutive red links in red-black trees.

    op "[]"() -> optional AA_Tree;
        // Create an empty tree

    func Insert(var T : optional AA_Tree; X : Element);
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

    func Delete(var T : optional AA_Tree; X : Element);
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

    op "in"(X : Element; T : optional AA_Tree) -> Boolean;

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element;
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.

    op "|="(var T : optional AA_Tree; X : Element) is Insert;

    op "<|="(var T : optional AA_Tree; var X : optional Element);
	// Move X into AA_Tree, leaving X null.

    func First(T : optional AA_Tree) -> optional Element;
      // Return first (smallest) element in tree

    func Last(T : optional AA_Tree) -> optional Element;
      // Return last (greatest) element in tree

    func Remove_First(var T : optional AA_Tree) -> optional Element;
      // Remove first (smallest) element in tree

    func Remove_Last(var T : optional AA_Tree) -> optional Element;
      // Remove last (greatest) element in tree

    func Remove_Any(var T : optional AA_Tree) -> optional Element;
      // Remove some element from tree

    func Count(T : optional AA_Tree) -> Univ_Integer;
      // Return a count of the nodes in the tree

    func Is_Empty(T : optional AA_Tree) -> Boolean;
      // Return True if the tree is empty

end interface AA_Tree;

class AA_Tree is
    var Value : Element;
    var Level : Univ_Integer := 0;
    var Left : optional AA_Tree;
    var Right : optional AA_Tree;

    func Node(var Value : optional Element; Level : Univ_Integer; 
      Left, Right : optional AA_Tree) -> AA_Tree is
        // Create a new tree; move Value into it.
        return (Value <== Value, Level => Level, Left => Left, Right => Right);
    end func Node;

    func Is_Leaf(T : optional AA_Tree) -> Boolean is
        return T not null and then
          T.Left is null and then T.Right is null;
    end func Is_Leaf;

    func Leftmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for L => T loop
            if L not null and then L.Left not null then
                // Continue with Left until we reach null
                continue loop with L.Left;
            else
                // Found left-most
                return L;
            end if;
        end loop;
    end func Leftmost;

    func Successor(T : optional AA_Tree) -> optional Element is
        // Return element in tree greater than but closest to T.Value
        if T.Right not null then
            return Leftmost(T.Right).Value;
        else
            return null;
        end if;
    end func Successor;

    func Rightmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for R => T loop
            if R not null and then R.Right not null then
                // Keep following down Right side
                continue loop with R.Right;
            else
                // Found right-most
                return R;
            end if;
        end loop;
    end func Rightmost;

    func Predecessor(T : optional AA_Tree) -> optional Element is
        // Return element in tree less than but closest to T.Value
        if T.Left not null then
            return Rightmost(T.Left).Value;
        else
            return null;
        end if;
    end func Predecessor;

    func Skew(var T : optional AA_Tree) is
      // input: T, a node representing an AA tree that needs to be rebalanced.
      // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Left not null and then
          T.Left.Level == T.Level then
            // The current T.Left becomes new root

            // Exchange value of T.Left with root
            T.Value <=> T.Left.Value;
           
            // Move old root and T.Left.Right over to right side of tree
            T.Left.Right <=> T.Right;
            T.Left.Left <=> T.Right;
            T.Left <=> T.Right;
        end if;
    end func Skew;

    func Split(var T : optional AA_Tree) is
        // input: T, a node representing an AA tree that needs to be rebalanced.
        // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Right not null and then
          T.Right.Right not null and then
          T.Level == T.Right.Right.Level then
            // T.Right becomes the new root
            // Exchange value and level between root and T.Right
            T.Value <=> T.Right.Value;
            T.Level <=> T.Right.Level;

            // Move old root and T.Right.Left to left side of tree
            T.Left <=> T.Right.Right;
            T.Right.Left <=> T.Right.Right;
            T.Left <=> T.Right;

            // Increment level
            T.Level += 1;
        end if;
    end func Split;

    func Decrease_Level(var T : optional AA_Tree) is
        // input: T, a tree for which we want to remove links that skip levels.
        // output: T with its level decreased.

        if T is null then
            return;
        end if;
           
        var Should_Be : Univ_Integer := 1;

        if T.Left not null then
            Should_Be := T.Left.Level + 1;
        end if;

        if T.Right not null then
            Should_Be := Min(Should_Be, T.Right.Level + 1);
        end if;
            
        if Should_Be < T.Level then
            T.Level := Should_Be;
            if T.Right not null and then
              Should_Be < T.Right.Level then
                T.Right.Level := Should_Be;
            end if;
        end if;
    end func Decrease_Level;

  exports

    op "[]"() -> optional AA_Tree is
        // Create an empty tree
        return null;
    end op "[]";

    // Insertion begins with the normal binary tree search and insertion
    // procedure. Then, as the call stack unwinds (assuming a recursive
    // implementation of the search), it's easy to check the validity of the
    // tree and perform any rotations as necessary. If a horizontal left link
    // arises, a skew will be performed, and if two horizontal right links
    // arise, a split will be performed, possibly incrementing the level of the
    // new root node of the current subtree. Note, in the code as given above,
    // the increment of T.Level. This makes it necessary to continue checking
    // the validity of the tree as the modifications bubble up from the leaves.
    
    op "<|="(var T : optional AA_Tree; var X : optional Element) is
	// Move X into AA_Tree, leaving X null.
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

        // Do the normal binary tree insertion procedure. 
        // Set the result of the recursive call to the correct 
        // child in case a new node was created or the
        // root of the subtree changes.

        if T is null then
            // Create a new leaf node with X.
            T := Node(X, 1, null, null);
            return;
        end if;

        case X =? T.Value of
          [#less] =>
            T.Left <|= X;
          [#greater] =>
            T.Right <|= X;
          [#equal | #unordered] =>
            // Note that the case of X == T.Value is unspecified. 
            // As given, an insert will have no effect. 
            // The implementor may desire different behavior.
	    X := null;
            return;
        end case;

        // Perform skew and then split. 
        // The conditionals that determine whether or
        // not a rotation will occur or not are inside 
        // of the procedures, as given above.

        Skew(T);
        Split(T);
    end op "<|=";

    func Insert(var T : optional AA_Tree; X : Element) is
	// Just pass the buck to the "<|=" operation
	var X_Copy for T := X;
	T <|= X_Copy;
    end func Insert;

    // As in most balanced binary trees, the deletion of an internal node can
    // be turned into the deletion of a leaf node by swapping the internal node
    // with either its closest predecessor or successor, depending on which are
    // in the tree or on the implementor's whims. Retrieving a predecessor is
    // simply a matter of following one left link and then all of the remaining
    // right links. Similarly, the successor can be found by going right once
    // and left until a null pointer is found. Because of the AA property of
    // all nodes of level greater than one having two children, the successor
    // or predecessor node will be in level 1, making their removal trivial.
    // 
    // To re-balance a tree, there are a few approaches. The one described by
    // Andersson in his original paper is the simplest, and it is described
    // here, although actual implementations may opt for a more optimized
    // approach. After a removal, the first step to maintaining tree validity
    // is to lower the level of any nodes whose children are two levels below
    // them, or who are missing children. Then, the entire level must be skewed
    // and split. This approach was favored, because when laid down
    // conceptually, it has three easily understood separate steps:
    // 
    //     Decrease the level, if appropriate.
    //     Skew the level.
    //     Split the level.
    // 
    // However, we have to skew and split the entire level this time instead of
    // just a node, complicating our code.

    func Delete(var T : optional AA_Tree; X : Element) is
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

        if T is null then
            // Not in tree -- should we complain?
            return;
        end if;

        case X =? T.Value of
          [#less] =>
            Delete(T.Left, X);
          [#greater] =>
            Delete(T.Right, X);
          [#equal] =>
            // If we're a leaf, easy, otherwise reduce to leaf case. 
            if Is_Leaf(T) then
                T := null;
            elsif T.Left is null then
                // Get successor value and delete it from right tree,
                // and set root to have that value
                const Succ := Successor(T);
                Delete(T.Right, Succ);
                T.Value := Succ;
            else
                // Get predecessor value and delete it from left tree,
                // and set root to have that value
                const Pred := Predecessor(T);
                Delete(T.Left, Pred);
                T.Value := Pred;
            end if;
          [#unordered] =>
            // Not in tree; should we complain?
            return;  
        end case;

        // Rebalance the tree. Decrease the level of all nodes in this level if
        // necessary, and then skew and split all nodes in the new level.

        if T is null then
            return;
        end if;

        Decrease_Level(T);
        Skew(T);
        Skew(T.Right);
        if T.Right not null then
            Skew(T.Right.Right);
        end if;
        Split(T);
        Split(T.Right);
    end func Delete;

    op "in"(X : Element; T : optional AA_Tree) -> Result : Boolean is
        for P => T while P not null loop
            case X =? P.Value of
              [#less] =>
                continue loop with P.Left;
              [#greater] =>
                continue loop with P.Right;
              [#equal] =>
                return #true;
              [#unordered] =>
                return #false;
            end case;
        end loop;
        return #false;  // Not found
    end op "in";

    func First(T : optional AA_Tree) -> optional Element is
      // Return first (smallest) element in tree
        if T is null then
            return null;
        else 
            return Leftmost(T).Value;
        end if;
    end func First;

    func Last(T : optional AA_Tree) -> optional Element is
      // Return last (greatest) element in tree
        if T is null then
            return null;
        else
            return Rightmost(T).Value;
        end if;
    end func Last;


    func Remove_First(var T : optional AA_Tree) -> Result : optional Element is
      // Remove first (smallest) element in tree
        Result := First(T);
        if Result not null then
            Delete(T, Result);
        end if;
    end func Remove_First;

    func Remove_Last(var T : optional AA_Tree) -> Result : optional Element is
      // Remove last (greatest) element in tree
        Result := Last(T);
        if Result not null then
            Delete(T, Result);
        end if;
    end func Remove_Last;

    func Remove_Any(var T : optional AA_Tree) -> Result : optional Element is
      // Remove some element from tree
        if T is null then
            return null;
        end if;
        Result := T.Value;
        if Result not null then
            Delete(T, Result);
        end if;
    end func Remove_Any;

    func Is_Empty(T : optional AA_Tree) -> Boolean is
      // Return True if the tree is empty
        return T is null;
    end func Is_Empty;

    func Count(T : optional AA_Tree) -> Univ_Integer is
      // Return a count of the nodes in the tree
        if T is null then
            return 0;
        else
            return Count(T.Left) + Count(T.Right) + 1;
        end if;
    end func Count;

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element is
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.
        if T is null or else T.Value is null then
            return null;
        else
            case X =? T.Value of
              [#less] =>
                return Overlapping(T.Left, X);
              [#greater] =>
                return Overlapping(T.Right, X);
              [#equal | #unordered] =>
                // Close enough
                return T.Value;
            end case;
        end if;
    end func Overlapping;

end class AA_Tree;

abstract interface Keyed<Key_Type is Hashable<>> is
    func Key_Of(ref const KV : Keyed) -> ref const Key_Type;
    func Has_Value(KV : Keyed) -> Boolean;
	// Return #true if Keyed object has a non-null value
    func Key_Only(Key : Key_Type) -> Keyed;
	// Return a Keyed object given a key, having no associated value
end interface Keyed;

interface Key_Value<Key_Type is Assignable<>; Value_Type is Assignable<>> 
  implements Keyed<Key_Type> is
  // This supports the use of [Key => Value] as a way to
  // add a single element to an existing indexable container of some sort.
    var Key : optional Key_Type;
    var Value : optional Value_Type;
    op "[]"() -> Key_Value;
    op "var_indexing"(ref var KV : Key_Value; Index : Key_Type) 
      -> ref var Value_Type;
    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type;
    func Has_Value(KV : Key_Value) -> Boolean;
	// Return #true if Key_Value object has a non-null value
    func Key_Only(Key : Key_Type) -> Key_Value;
	// Return a Key_Value object given a key, having no associated value
end interface Key_Value;

class Key_Value is
  exports
    op "[]"() -> Key_Value is
	return (Key => null, Value => null);
    end op "[]";

    op "var_indexing"(ref var KV : Key_Value; Index : Key_Type) 
      -> ref var Value_Type is
	KV.Key := Index;
	return KV.Value;
    end op "var_indexing";

    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type is
	return KV.Key;
    end func Key_Of;

    func Has_Value(KV : Key_Value) -> Boolean is
	// Return #true if Key_Value object has a non-null value
	return KV.Value not null;
    end func Has_Value;

    func Key_Only(Key : Key_Type) -> Key_Value is
	// Return a Key_Value object given a key, having no associated value
	return [Key => null];
    end func Key_Only;
end class Key_Value;

interface Basic_Map<KV_Type is Keyed<>> is
  // A basic hashed-map module

    op "[]"() -> Basic_Map;

    op "|="(var Left : Basic_Map; Right : KV_Type);
	// Add Key=>Value to Basic_Map, replacing pre-existing Basic_Mapping
	// for Key, if any.

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type);
	// Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
	// for Key, if any, leaving Right null.

    op "+="(var Left : Basic_Map; Right : KV_Type) is "|=";
	// A synonym for adding a key=>value KV_Type

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean;
	// Return True if given key has a Basic_Mapping in the Basic_Map

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type);  // aka Exclude
	// Remove Basic_Mapping for Right, if present

    op "index_set"(M : Basic_Map) -> Set<KV_Type::Key_Type>;
	// Return set of keys with Basic_Mappings

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type;
	// Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type;
	// Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Basic_Map) -> optional KV_Type;
	// Remove one Basic_Mapping from the Basic_Map.  
	// Return null if Basic_Map is empty

    func Count(M : Basic_Map) -> Univ_Integer;
	// Number of Basic_Mappings in the table

    func Is_Empty(M : Basic_Map) -> Boolean;
	// Return True if map has no mappings

    func Dump_Statistics(M : Basic_Map);
      // A debugging routine to show bucket sizes of Basic_Map

end interface Basic_Map;

class Basic_Map is
  // A basic hashed-map module

  // A Basic_Map is represented as a hash table, where each bucket is 
  // a linked list of key/value KV_Types.
  // When key/value KV_Types are deleted from the Basic_Map they end 
  // up as "null"s in the list.  
  // We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface Hash_Bucket<> is
      // a simple linked-list is used as a hash bucket
	var Elem : optional KV_Type;
	var Tail : optional Hash_Bucket;
    end interface Hash_Bucket;

    var Count : Univ_Integer;
    var Table : optional Basic_Array<optional Hash_Bucket<>>;
    const Initial_Table_Size := 4;
    const Debugging : Boolean := #false;
    
    func Empty(Table_Size : Univ_Integer) -> Basic_Map is
	// Create an empty Basic_Map with the given table size
        return (Count => 0, Table => Create(Table_Size, null));
    end func Empty;

    func Move_One(var To : Basic_Map; var Elem : KV_Type) is
	// Move Element into table, without expanding table.
	// Elem is set to null as a result.
	const Index := Hash(Key_Of(Elem)) mod Length(To.Table) + 1;
	ref Bucket => To.Table[Index];

	if Bucket is null then
	    // Bucket is now empty, so create bucket
	    // with Elem as its only element.
	    Bucket := (Elem <== Elem, Tail => null);
	else
	    // See whether Elem already in bucket
	    var Has_Empty_Slot : Boolean := #false;
	    for B => Bucket then B.Tail while B not null loop
		if B.Elem is null then
		    // Remember there is an empty slot
		    Has_Empty_Slot := #true;
		elsif Key_Of(Elem) == Key_Of(B.Elem) then
		    // Already there; replace it in case Value is different.
		    B.Elem <== Elem;
		    return;
		end if;
	    end loop;

	    if Has_Empty_Slot then
		// Fill in the empty slot
		for B => Bucket then B.Tail while B not null loop
		    if B.Elem is null then
			// Use the empty slot
			B.Elem <== Elem;
			exit loop;
		    end if;
		end loop;
	    else
		// Make old bucket the new tail of the new bucket.
		Bucket := (Elem <== Elem, Tail <== Bucket);
	    end if;
	end if;

	To.Count += 1;
    end func Move_One;

    func Add_One(var To : Basic_Map; Elem : KV_Type) is
	// Add Element to table, without expanding it
	var Elem_Copy for To := Elem;

	// Just pass the buck to "Move_One"
	Move_One(To, Elem_Copy);
    end func Add_One;

    func Expand_Table(var Expanding : Basic_Map) is
	// Expand table of given Basic_Map.
	var Old_Basic_Map <== Expanding;
	Expanding := Empty(2*Length(Old_Basic_Map.Table));
	// Move elements into new table
	loop
	    var Elem for Expanding := Remove_Any(Old_Basic_Map);
		// "for Expanding" means to allocate Elem in
		// region associated with Expanding.
	    if Elem is null then
		exit loop;
	    end if;
	    Move_One(Expanding, Elem);
	end loop;
    end func Expand_Table;

  exports
    op "[]"() -> Basic_Map is
        return (Count => 0, Table => null);
    end op "[]";

    op "|="(var Left : Basic_Map; Right : KV_Type) is
	if not Has_Value(Right) then
	    // Putting in Key => null is equivalent to deleting Key
	    Left -= Key_Of(Right);
	    return;
	end if;

	if Left.Table is null then
	    Left := Empty(Initial_Table_Size);
	elsif Left.Count >= 2*Length(Left.Table) then
	    // Expand table if averaging 2 or more per hash bucket
	    Expand_Table(Left);
	end if;
        Add_One(Left, Right);
    end op "|=";

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type) is
	// Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
	// for Key, if any, leaving Right null.
	if not Has_Value(Right) then
	    // Putting in Key => null is equivalent to deleting Key
	    Left -= Key_Of(Right);
	    Right := null;
	    return;
	end if;

	if Left.Table is null then
	    Left := Empty(Initial_Table_Size);
	elsif Left.Count >= 2*Length(Left.Table) then
	    // Expand table if averaging 2 or more per hash bucket
	    Expand_Table(Left);
	end if;
        Move_One(Left, Right);
    end op "<|=";

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean is
	if Right.Count == 0 then
	    // Empty Basic_Map
	    return #false;
	end if;
	const Index := Hash(Left) mod Length(Right.Table) + 1;
	ref Bucket => Right.Table[Index];
	if Bucket is null then
	    // Hash bucket is empty
	    return #false;
	end if;
	// Scan for Elem in hash bucket
	for B => Bucket then B.Tail while B not null loop 
	    if B.Elem not null and then
	      Has_Value(B.Elem) and then
	      Key_Of(B.Elem) == Left then
		// Found it
		return #true;
	    end if;
	end loop;
	// Not in Basic_Map
	return #false;
    end op "in";

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type) is
      // Remove the given key from the Basic_Map, if present
	if M.Count == 0 then
	    // Empty Basic_Map
	    return;
	end if;

	const Index := Hash(Key) mod Length(M.Table) + 1;
	ref Bucket => M.Table[Index];
	if Bucket is null then
	    // Hash bucket is empty
	    return;
	end if;

	// Scan for Key in bucket
	for B => Bucket then B.Tail while B not null loop
	    if B.Elem not null and then
	      Key_Of(B.Elem) == Key then
		// Found it.  Map it to null, and decrement Basic_Map count.
		B.Elem := null;
		M.Count -= 1;
		return;
	    end if;
	end loop;
	// Not found
    end op "-=";
   
    op "index_set"(M : Basic_Map) -> Result : Set<KV_Type::Key_Type> is
	// Return set of keys with non-null Basic_Mappings
	Result := [];
	for each Bucket of M.Table loop
	    for B => Bucket then B.Tail while B not null loop
		if B.Elem not null and then
		  Has_Value(B.Elem) not null then
		    Result |= Key_Of(B.Elem);
		end if;
	    end loop;
	end loop;
    end op "index_set";

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type is
	// Used for references to M[Key]; requires the Key to be in M.
	{M not null; M.Count > 0}
	const Index := Hash(Key) mod Length(M.Table) + 1;
	// Scan for Key in bucket
	for B => M.Table[Index] then B.Tail while B not null loop
	    if B.Elem not null and then
	      Key_Of(B.Elem) == Key then
		// Found it.  Return reference to element of KV_Type
		{Has_Value(B.Elem)}
		return B.Elem;
	    end if;
	end loop;
	{#false}
    end op "indexing";

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type is
	// Used for assignments to M[Key]; Key is added to M if not present
	if M.Table not null then
	    const Index := Hash(Key) mod Length(M.Table) + 1;
	    // Scan for Key in bucket
	    for B => M.Table[Index] then B.Tail while B not null loop
		if B.Elem not null and then
		  Key_Of(B.Elem) == Key then
		    // Found it.  Return reference to element of KV_Type
		    return B.Elem;
		end if;
	    end loop;
	end if;

	// Not in table.  Add it, and then return reference
	if M.Table is null then
	    M := Empty(Initial_Table_Size);
	elsif M.Count >= 2*Length(M.Table) then
	    // Expand table if averaging 2 or more per hash bucket
	    Expand_Table(M);
	end if;

	// Add [Key => null] to front of appropriate bucket.
	const Index := Hash(Key) mod Length(M.Table) + 1;
	ref Bucket => M.Table[Index];
	Bucket := (Elem => Key_Only(Key), Tail <== Bucket);
	M.Count += 1;

	// Return ref to new element
	return Bucket.Elem;
    end op "var_indexing";

    func Count(M : Basic_Map) -> Univ_Integer is
	return M.Count;
    end func Count;

    func Is_Empty(M : Basic_Map) -> Boolean is
	// Return True if map has no mappings
	return M.Count == 0;
    end func Is_Empty;

    func Remove_Any(var M : Basic_Map) -> Result : optional KV_Type is
	if M.Count == 0 then
	    // Basic_Map is empty
	    return null;
	else
	    // Find a non-empty bucket and pull out an item.
	    for each Bucket of M.Table loop
		if Bucket not null then
		    for B => Bucket then B.Tail while B not null loop 
			if B.Elem not null then
			    // Found an item, remove from Bucket and return
			    Result <== B.Elem;
			    M.Count -= 1;
			    return;
			end if;
		    end loop;
		    // This bucket is completely empty, so might
		    // as well empty it out.
		    Bucket := null;
		end if;
		// Go on to the next bucket, this one's empty
	    end loop;
	    // Should never get here
	    return null;
	end if;
    end func Remove_Any;

    func Dump_Statistics(M : Basic_Map) is
	null;
    end func Dump_Statistics;

end class Basic_Map;

class Set is
  // A hashed-set module

  // A Set is represented as a hash table, where each bucket is a linked list.
  // When elements are deleted from the Set they end up a "null"s in the
  // list.  We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface KV_Wrapper<> implements Keyed<Element_Type> is
      // Create a wrapper for a key that implements the Keyed interface
	var Key : Element_Type;
	func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type;
	func Has_Value(KV : KV_Wrapper) -> Boolean;
	    // Return #true if KV_Wrapper object has a non-null value
	func Key_Only(Key : Element_Type) -> KV_Wrapper;
	    // Return a KV_Wrapper object given a key, 
	    // having no associated value
    end interface KV_Wrapper;

    class KV_Wrapper is
      // Create a wrapper for a key that implements the Keyed interface
      exports
	func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type is
	    return KV.Key;
	end func Key_Of;

	func Has_Value(KV : KV_Wrapper) -> Boolean is
	    // Return #true if KV_Wrapper object has a non-null value
	    return #true;
	end func Has_Value;

	func Key_Only(Key : Element_Type) -> KV_Wrapper is
	    // Return a KV_Wrapper object given a key, 
	    // having no associated value.
	    // NOTE: This is not really meaningful for sets, since there
	    //       isn't a value.
	    return (Key => Key);
	end func Key_Only;
    end class KV_Wrapper;
	
    var Data : Basic_Map<KV_Wrapper<>>;
	// Set is represented as a map from keys to nothing.

  exports
    op "[]"() -> Set is
        return (Data => []);
    end op "[]";

    func Singleton(Elem : Element_Type) -> Result : Set is
	Result := [];
	Result.Data |= (Key => Elem);
    end func Singleton;

    op "|"(Left, Right : Element_Type) -> Result : Set is
	Result := [];
	Result.Data |= (Key => Left);
	Result.Data |= (Key => Right);
    end op "|";

    op "|"(Left : Set; Right : Element_Type) -> Result : Set is
	Result := Left;
	Result |= Right;
    end op "|";

    op "|"(Left : Element_Type; Right : Set) -> Result : Set is
	Result := Right;
	Result |= Left;
    end op "|";

    op "|"(Left : Set; Right : Set) -> Result : Set is
	// Union, iterate over smaller Set
	if Count(Left.Data) <= Count(Right.Data) then
	    Result := Right;
	    Result |= Left;
	else
	    Result := Left;
	    Result |= Right;
	end if;
    end op "|";

    op "|="(var Left : Set; Right : Set) is
        if Count(Left.Data) == 0 then
            Left := Right;
        else
	    for Elem in Right loop
		Left |= Elem;
	    end loop;
	end if;
    end op "|=";

    op "|="(var Left : Set; Right : Element_Type) is
	Left.Data |= (Key => Right);
    end op "|=";

    op "<|="(var Left : Set; var Right : optional Element_Type) is
	// Move Right into Set Left
	var KV : KV_Wrapper := (Key <== Right);
	Left.Data <|= KV;
    end op "<|=";

    op "<|="(var Left : Set; var Right : Set) is
	// Move all elements of Right into Left, leaving Right empty.
	loop
	    // Extract element from Right, in region for Left
	    var Elem for Left := Remove_Any(Right);
	    if Elem is null then
		// All done
		return;  
	    end if;
	    // Move element into Left
	    Left <|= Elem;
	end loop;
    end op "<|=";

    op "in"(Left : Element_Type; Right : Set) -> Boolean is
	return Left in Right.Data;
    end op "in";

    op "=?"(Left, Right : Set) -> Ordering is
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise
        var Overlaps := 0;
        var Missing := 0;
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1;
            else
                Overlaps += 1;
            end if;
        end loop;

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right.Data) then
                return #unordered;
            else
                // Left is a superset
                return #greater;
            end if;
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right.Data) then
                // Left is a proper subset of Right
                return #less;
            else
                return #equal;
            end if;
        end if;
    end op "=?";

    op "and"(Left, Right : Set) -> Result : Set is
	// Intersection, iterate over smaller Set
	if Count(Left.Data) < Count(Right.Data) then
	    // Left is smaller
	    Result := [];
	    for Elem in Left loop
		if Elem in Right then
		    Result |= Elem;
		end if;
	    end loop;
	else
	    // Left is bigger
	    Result := Left;
	    for Elem in Right loop
		if Elem in Left then
		    Result |= Elem;
		end if;
	    end loop;
	end if;
    end op "and";

    op "and="(var Left : Set; Right : Set) is
	// Intersection, iterate over smaller Set
	if Count(Left.Data) <= Count(Right.Data) then
	    // Left is smaller
	    for Elem in Left loop
		if Elem not in Right then
		    Left -= Elem;
		end if;
	    end loop;
	else
	    // Left is bigger
	    var Result for Left : Set := [];
	    for Elem in Right loop
		if Elem in Left then
		    Result |= Elem;
		end if;
	    end loop;
	    Left <== Result;
	end if;
    end op "and=";

    op "xor"(Left, Right : Set) -> Result : Set is
	// Symmetric difference
	// Want elements that are only in one of the two inputs
	if Count(Left.Data) < Count(Right.Data) then
	    // Swap order to shorten iteration
	    Result := Right;
	    Result xor= Left;
	else
	    Result := Left;
	    Result xor= Right;
	end if;
    end op "xor";
    
    op "xor="(var Left : Set; Right : Set) is
	// Want elements that are only in one of the two inputs
	for Elem in Right loop
	    if Elem in Left then
		Left -= Elem;
	    else
		Left += Elem;
	    end if;
	end loop;
    end op "xor=";

    op "-"(Left, Right : Set) -> Result : Set is
	// Set difference, iterate over smaller Set
	if Count(Left.Data) < Count(Right.Data) then
	    // Left is smaller, build up 
	    Result := [];
	    for Elem in Left loop
		if Elem not in Right then
		    Result |= Elem;
		end if;
	    end loop;
	else
	    // Left is bigger, tear down
	    Result := Left;
	    Result -= Right;
	end if;
    end op "-";

    op "-="(var Left : Set; Right : Set) is
	// Compute Set difference
	for Elem in Right loop
	    Left -= Elem;
	end loop;
    end op "-=";

    op "-="(var S : Set; Elem : Element_Type) is
      // Remove the given element from the Set, if present
	S.Data -= Elem;
    end op "-=";
   
    func Count(S : Set) -> Univ_Integer is
	return Count(S.Data);
    end func Count;

    func Is_Empty(S : Set) -> Boolean is
	return Is_Empty(S.Data);
    end func Is_Empty;

    func Remove_Any(var S : Set) -> Result : optional Element_Type is
	var Result_Wrapper for Result := Remove_Any(S.Data);
	if Result_Wrapper is null then
	    return null;
	else
	    Result <== Result_Wrapper.Key;
	end if;
    end func Remove_Any;

    func Dump_Statistics(S : Set) is
      // A debugging routine to show bucket sizes of Set
	Dump_Statistics(S.Data);
    end func Dump_Statistics;

end class Set;

class Countable_Set is

    type Element_Interval is Closed_Interval<Element_Type>;

    var Items : optional AA_Tree<Element_Interval>;

  exports
    op "[]"() -> Countable_Set is
        return (Items => []);
    end op "[]";

    func Singleton(Elem : Element_Type) -> Result : Countable_Set is
	Result := [];
	Result.Items |= (Low => Elem, High => Elem);
    end func Singleton;

    op ".."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := [];
        if Left <= Right then
            Result.Items |= (Low => Left, High => Right);
        end if;
    end op "..";
    
    op "<.."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := [];
        if Left < Right then
            Result.Items |= (Low => Left+1, High => Right);
        end if;
    end op "<..";
    
    op "<..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := [];
        if Left < Right-1 then
            Result.Items |= (Low => Left+1, High => Right-1);
        end if;
    end op "<..<";
    
    op "..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := [];
        if Left < Right then
            Result.Items |= (Low => Left, High => Right-1);
        end if;
    end op "..<";
    
    op "|"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := [];
        if Left >= Right-1 and then Left <= Right + 1 then
            // Can combine elements into a single interval
            if Left <= Right then
                Result.Items |= (Low => Left, High => Right);
            else
                Result.Items |= (Low => Right, High => Left);
            end if;
        else
            // Make each element its own interval
            Result.Items |= (Low => Left, High => Left);
            Result.Items |= (Low => Right, High => Right);
        end if;
    end op "|";

    op "|"(Left : Countable_Set; Right : Element_Type) 
      -> Result : Countable_Set is
        Result := Left;
        Result |= Right;
    end op "|";

    op "|"(Left : Element_Type; Right : Countable_Set) -> Countable_Set is
        return Right | Left;
    end op "|";

    op "|"(Left : Countable_Set; Right : Countable_Set) 
      -> Result : Countable_Set is
        Result := Left;
        Result |= Right;
    end op "|";

    op "|="(var Left : Countable_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := (Low => Right, High => Right);
        const Left_IV := Overlapping(Left.Items, Right_IV);
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV;
        end if;
    end op "|=";

    op "<|="(var Left : Countable_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
	// NOTE: No copy minimization done for countable types.
	Left |= Right;
	Right := null;
    end op "<|=";

    op "<|="(var Left : Countable_Set; var Right : Countable_Set) is
	// Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items;
        else
            // Iterate through the tree
	    loop
		// Extract interval from Right
		var Right_IV for Left := Remove_Any(Right.Items);

		if Right_IV is null then
		    return;  // All done
		end if;

                // See whether it overlaps with an existing interval
                // in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV);
                while Left_IV not null loop
                    if Left_IV.Low <= Right_IV.Low and then
                      Left_IV.High >= Right_IV.High then
                        // Right_IV is subsumed; nothing to add in
                        Right_IV := null;
                        exit loop;
                    else
                        // Need to delete Left_IV and incorporate
                        // into Right_IV
                        Delete(Left.Items, Left_IV);
                        if Left_IV.Low < Right_IV.Low then
                            Right_IV.Low := Left_IV.Low;
                        end if;
                        if Left_IV.High > Right_IV.High then
                            Right_IV.High := Left_IV.High;
                        end if;

                        // Now see if there is anything still overlapping
                        Left_IV := Overlapping(Left.Items, Right_IV);
                    end if;
                end loop;

                if Right_IV not null then
                    // Add Right_IV
                    Left.Items <|= Right_IV;
                end if;

            end loop;
        end if;
    end op "<|=";

    op "|="(var Left : Countable_Set; Right : Countable_Set) is
	// Pass the buck to the "<|=" operation
	var Right_Copy for Left := Right;
	Left <|= Right_Copy;
    end op "|=";

    op "-"(Left, Right : Countable_Set) -> Result : Countable_Set is
      // Set difference
	Result := Left;
	Result -= Right;
    end op "-";

    op "-="(var S : Countable_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
	const IV := Overlapping(S.Items, (Low => Elem, High => Elem));
	  // Get interval, if any, which overlaps given element

	if IV not null then
	    // Delete interval and put back after removing Elem
	    Delete(S.Items, IV);
	    if IV.High > IV.Low then
		// We need to put something back
		if IV.Low == Elem then
		    S.Items |= (Low => IV.Low + 1, High => IV.High);
		elsif IV.High == Elem then
		    S.Items |= (Low => IV.Low, High => IV.High-1);
		else
		    // Elem is in the middle, put back intervals
		    // on either side.
		    S.Items |= (Low => IV.Low, High => Elem-1);
		    S.Items |= (Low => Elem+1, High => IV.High);
		end if;
	    end if;
	end if;

    end op "-=";

    op "-="(var Left : Countable_Set; Right : Countable_Set) is
      // Remove all elements of Right from Left, if present
	for Elem in Right loop
	    Left -= Elem;
	end loop;
    end op "-=";

    op "and"(Left, Right : Countable_Set) -> Result : Countable_Set is
	// Intersection
	Result := [];
	for Elem in Right loop
	    if Elem in Left then
		Result += Elem;
	    end if;
	end loop;
    end op "and";

    op "and="(var Left : Countable_Set; Right : Countable_Set) is
	// Intersection
	for Elem in Left loop
	    if Elem not in Right then
		Left -= Elem;
	    end if;
	end loop;
    end op "and=";

    op "xor"(Left, Right : Countable_Set) -> Result : Countable_Set is
	// Symmetric difference
	Result := Left;
	Result xor= Right;
    end op "xor";

    op "xor="(var Left : Countable_Set; Right : Countable_Set) is
	// Symmetric difference
	// Want elements that are only in one of the two inputs
	for Elem in Right loop
	    if Elem in Left then
		Left -= Elem;
	    else
		Left += Elem;
	    end if;
	end loop;
    end op "xor=";

    op "in"(Left : Element_Type; Right : Countable_Set) -> Boolean is
        return Overlapping(Right.Items, (Low => Left, High => Left)) not null;
    end op "in";

    op "=?"(Left, Right : Countable_Set) -> Ordering is
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise
        var Overlaps := 0;
        var Missing := 0;
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1;
            else
                Overlaps += 1;
            end if;
        end loop;

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered;
            else
                // Left is a superset
                return #greater;
            end if;
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                // Left is a proper subset of Right
                return #less;
            else
                return #equal;
            end if;
        end if;
    end op "=?";

    func Count(S : Countable_Set) -> Result : Univ_Integer is
        // Return count of items in set

        Result := 0;

        // Copy items and then iterate through them to build up count
        var Items := S.Items;
        var Next_IV := Remove_Any(Items);
        while Next_IV not null loop
            Result += Next_IV.High - Next_IV.Low + 1;
            Next_IV := Remove_Any(Items);
        end loop;
    end func Count;

    func Is_Empty(S : Countable_Set) -> Boolean is
	return Is_Empty(S.Items);
    end func Is_Empty;

    func First(S : Countable_Set) -> optional Element_Type is
        const First_IV := First(S.Items);
        if First_IV is null then
            return null;
        else
            return First_IV.Low;
        end if;
    end func First;

    func Last(S : Countable_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items);
        if Last_IV is null then
            return null;
        else
            return Last_IV.High;
        end if;
    end func Last;

    func Remove_First(var S : Countable_Set) 
      -> Result : optional Element_Type is
        // Return first element of set

        // Get first interval in tree
        var First_IV := Remove_First(S.Items);
        if First_IV is null then
            // Tree is empty
            return null;
        end if;

        // See whether interval has more than one value in it
        if First_IV.High > First_IV.Low then
            // Need to put back the remainder
            S.Items |= (Low => First_IV.Low+1, High => First_IV.High);
        end if;

        // Return first item
        return First_IV.Low;
    end func Remove_First;

    func Remove_Last(var S : Countable_Set) -> Result : optional Element_Type is
        // Remove last element of set

        // Get Last interval in tree
        var Last_IV := Remove_Last(S.Items);
        if Last_IV is null then
            // Tree is empty
            return null;
        end if;

        // See whether interval has more than one value in it
        if Last_IV.High > Last_IV.Low then
            // Need to put back the remainder
            S.Items |= (Low => Last_IV.Low, High => Last_IV.High-1);
        end if;

        // Return Last item
        return Last_IV.High;
    end func Remove_Last;

    func Remove_Any(var S : Countable_Set) -> optional Element_Type is
        // Remove any element of set

        // Get any interval in tree
        var Any_IV := Remove_Any(S.Items);
        if Any_IV is null then
            // Tree is empty
            return null;
        end if;

        // See whether interval has more than one value in it
        if Any_IV.High > Any_IV.Low then
            // Need to remove one to return and put back the remainder
            if (Any_IV.High - Any_IV.Low) mod 2 == 0 then
                // Return high bound when high-low is even
                // NOTE: We do this to avoid having algorithms become
                //       dependent on always getting values in ascending 
                //       or descending order.
                S.Items |= (Low => Any_IV.Low, High => Any_IV.High-1);
                return Any_IV.High;
            else
                // Return low bound when high-low is odd
                S.Items |= (Low => Any_IV.Low+1, High => Any_IV.High);
                return Any_IV.Low;
            end if;
        else
            // Return only item in interval
            return Any_IV.Low;
        end if;

    end func Remove_Any;

end class Countable_Set;

interface Ordered_Set<Element_Type is Comparable<>> is
  // A set abstraction that supports efficiently storing potentially
  // large ranges of values
    op "[]"() -> Ordered_Set;

    func Singleton(Elem : Element_Type) -> Ordered_Set;
	// Return a set consisting of a single element

    op ".."(Left, Right : Element_Type) -> Ordered_Set;
	// Closed interval of values
    op "<.."(Left, Right : Element_Type) -> Ordered_Set;
	// Open-Closed interval of values
    op "..<"(Left, Right : Element_Type) -> Ordered_Set;
	// Closed-Open interval of values
    op "<..<"(Left, Right : Element_Type) -> Ordered_Set;
	// Open interval of values

    op "|"(Left, Right : Element_Type) -> Ordered_Set;
    op "|"(Left : Ordered_Set; Right : Element_Type) -> Ordered_Set;
    op "|"(Left : Element_Type; Right : Ordered_Set) -> Ordered_Set;
    op "|"(Left : Ordered_Set; Right : Ordered_Set) -> Ordered_Set;

    op "|="(var Left : Ordered_Set; Right : Element_Type);
    op "|="(var Left : Ordered_Set; Right : Ordered_Set);

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type);
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set);
	// Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Ordered_Set) -> Ordered_Set;
      // Set difference
    op "-="(var S : Ordered_Set; Elem : Element_Type);
      // Remove the given element from the set, if present
    op "-="(var Left : Ordered_Set; Right : Ordered_Set);
      // Remove all elements of Right from Left, if present

    op "or"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|";  // union
    op "or="(var Left : Ordered_Set; Right : Ordered_Set) is "|=";

    op "+"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|";  // Union
    op "+="(var Left : Ordered_Set; Right : Ordered_Set) is "|=";
    op "+="(var Left : Ordered_Set; Right : Element_Type) is "|=";
   
    op "and"(Left, Right : Ordered_Set) -> Ordered_Set;
	// Intersection
    op "and="(var Left : Ordered_Set; Right : Ordered_Set);

    op "xor"(Left, Right : Ordered_Set) -> Ordered_Set;
	// Symmetric difference
    op "xor="(var Left : Ordered_Set; Right : Ordered_Set);

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean;

    op "=?"(Left, Right : Ordered_Set) -> Ordering;
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise

    func Is_Empty(S : Ordered_Set) -> Boolean;

    func Lower_Bound(S : Ordered_Set) -> optional Element_Type;
	// Lower bound of set
    func Lower_Bound_Is_Open(S : Ordered_Set) -> Boolean;
	// Whether lower bound is "open" or "closed"

    func Upper_Bound(S : Ordered_Set) -> optional Element_Type;
	// Upper bound of set
    func Upper_Bound_Is_Open(S : Ordered_Set) -> Boolean;
	// Whether upper bound is "open" or "closed"

    func Remove_First(var S : Ordered_Set) -> optional Interval<Element_Type>;
	// Remove first interval of set (lowest low bound)

    func Remove_Last(var S : Ordered_Set) -> optional Interval<Element_Type>;
	// Remove last interval of set (highest high bound)

    func Remove_Any(var S : Ordered_Set) -> optional Interval<Element_Type>;
	// Remove an arbitrary interval of set

end interface Ordered_Set;

class Ordered_Set is

    type Element_Interval is Interval<Element_Type>;

    var Items : optional AA_Tree<Element_Interval>;

    func Remove_Interval(var S : Ordered_Set; Remove_IV : Element_Interval) is
      // Remove the given interval from the set, if present
	if Remove_IV.Low > Remove_IV.High then
	    // Nothing to remove
	    return;
	end if;

	  // Find an interval within the AA_Tree that overlaps
	for Remaining_IV := Remove_IV while Remaining_IV not null loop
	    // Get overlap, if any
	    var IV := Overlapping(S.Items, Remaining_IV);

	    if IV is null then
		// No overlap, nothing left to remove
		exit loop;
	    end if;
	
	    // Found an overlapping interval; delete it and add back what's left
	    Delete(S.Items, IV);
	    if Is_Strictly_Within(Remaining_IV, IV) then
		// Add back left and right remnants;
		// Remaining_IV is fully subsumed.
		S.Items |= (Low => IV.Low, Low_Is_Open => IV.Low_Is_Open, 
		  High => Remaining_IV.Low, 
		  High_Is_Open => not Remaining_IV.Low_Is_Open);
		S.Items |= (Low => Remaining_IV.High, 
		  Low_Is_Open => not Remaining_IV.High_Is_Open,
		  High => IV.High, 
		  High_Is_Open => IV.High_Is_Open);
		// we are all done now
		exit loop;
	    end if;

	    // May be something left
	    const Overlap := IV and Remaining_IV;
	    IV -= Overlap;

	    if not Is_Empty(IV) then
		// Worth putting the interval back
		S.Items |= IV;
	    end if;

	    continue loop with Remaining_IV - Overlap;

	end loop;

    end func Remove_Interval;

    func Is_Subset(Left, Right : Ordered_Set) -> Boolean is
	// Return True if Left is a subset of Right
	for Left_IV in Left loop
	    for Remaining_IV := Left_IV while not Is_Empty(Remaining_IV) loop
		const Right_IV := Overlapping(Right.Items, Remaining_IV);
		if Right_IV is null then
		    // Found some values that are not in Right
		    return #false;
		end if;

		// Loop around with what is left
		continue loop with Remaining_IV - Right_IV;
	    end loop;
	end loop;
	// Everything in Left was found in Right
	return #true;
    end func Is_Subset;

  exports
    op "[]"() -> Ordered_Set is
        return (Items => []);
    end op "[]";

    func Singleton(Elem : Element_Type) -> Result : Ordered_Set is
	// Return a set consisting of a single element
	Result := [];
	Result.Items |= Singleton(Elem);
    end func Singleton;

    op ".."(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := [];
        if Left <= Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false, 
	      High => Right, High_Is_Open => #false);
        end if;
    end op "..";
    
    op "<.."(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := [];
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
	      High => Right, High_Is_Open => #false);
        end if;
    end op "<..";
    
    op "<..<"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := [];
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
	      High => Right, High_Is_Open => #true);
        end if;
    end op "<..<";
    
    op "..<"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := [];
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false,
	      High => Right, High_Is_Open => #true);
        end if;
    end op "..<";
    
    op "|"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := [];
	Result |= Left;
	if Left != Right then
	    Result |= Right;
        end if;
    end op "|";

    op "|"(Left : Ordered_Set; Right : Element_Type) 
      -> Result : Ordered_Set is
        Result := Left;
        Result |= Right;
    end op "|";

    op "|"(Left : Element_Type; Right : Ordered_Set) -> Ordered_Set is
        return Right | Left;
    end op "|";

    op "|"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Result : Ordered_Set is
        Result := Left;
        Result |= Right;
    end op "|";

    op "|="(var Left : Ordered_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := Singleton(Right);
        const Left_IV := Overlapping(Left.Items, Right_IV);
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV;
        end if;
    end op "|=";

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
	// TBD: No copy minimization done at the moment
	Left |= Right;
	Right := null;
    end op "<|=";

    op "|="(var Left : Ordered_Set; Right : Ordered_Set) is
        if Count(Left.Items) == 0 then
            Left := Right;
        else
            // Make a copy of the Right set
            var Right_Copy for Left := Right;

	    // Merge all of its intervals into Left
	    Left <|= Right_Copy;
	end if;
    end op "|=";

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set) is
	// Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items;
        else
            // Iterate through the tree
	    loop
		// Extract interval from Right
		var Right_IV for Left := Remove_Any(Right.Items);
		if Right_IV is null then
		    return;
		end if;

                // See whether it overlaps with an existing interval
                // in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV);
                while Left_IV not null loop
		    // Incorporate left interval into Right_IV
		    Right_IV |= Left_IV;

		    if Right_IV == Left_IV then
			// Right_IV fully subsumed by existing interval
			Right_IV := null;
			exit loop;
		    end if;

		    // Need to delete Left_IV 
		    Delete(Left.Items, Left_IV);

		    // Now see if there is anything still overlapping
		    Left_IV := Overlapping(Left.Items, Right_IV);
                end loop;

                if not Is_Empty(Right_IV) then
                    // Add Right_IV
                    Left.Items <|= Right_IV;
                end if;

            end loop;
        end if;
    end op "<|=";

    op "-"(Left, Right : Ordered_Set) -> Result : Ordered_Set is
      // Set difference
	Result := Left;
	Result -= Right;
    end op "-";

    op "-="(var S : Ordered_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
	Remove_Interval(S, Singleton(Elem));
    end op "-=";

    op "-="(var Left : Ordered_Set; Right : Ordered_Set) is
      // Remove all intervals of Right from Left, if present
	for IV in Right loop
	    Remove_Interval(Left, IV);
	end loop;
    end op "-=";

    op "and"(Left, Right : Ordered_Set) -> Result : Ordered_Set is
	// Intersection

	// Add elements that are in both Right and Left into result
	Result := [];
	for Right_IV in Right loop
	    for Remaining_IV := Right_IV while Remaining_IV not null loop
		var Left_IV := Overlapping(Left.Items, Remaining_IV);

		if Left_IV is null then
		    exit loop;
		end if;

		// Compute overlap, add into result, and then loop
		// around after removing it from Remaining_IV
		const Overlap := Remaining_IV and Left_IV;

		Result.Items |= Overlap;

		continue loop with Remaining_IV - Overlap;
	    end loop;
	end loop;
    end op "and";

    op "and="(var Left : Ordered_Set; Right : Ordered_Set) is
	// Intersection
	Left := Left and Right;
    end op "and=";

    op "xor"(Left, Right : Ordered_Set) -> Ordered_Set is
	// Symmetric difference

	return (Left - Right) or (Right - Left);
    end op "xor";

    op "xor="(var Left : Ordered_Set; Right : Ordered_Set) is
	// Symmetric difference
	// Want elements that are only in one of the two inputs
	const Only_In_Right := Right - Left;
	Left -= Right;
	Left += Only_In_Right;
    end op "xor=";

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean is
        return Overlapping(Right.Items, Singleton(Left)) not null;
    end op "in";

    op "=?"(Left, Right : Ordered_Set) -> Ordering is
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise
	if Is_Subset(Left, Right) then
	    if Is_Subset(Right, Left) then
		return #equal;
	    else
		return #less;
	    end if;
	elsif Is_Subset(Right, Left) then
	    return #greater;
	else
	    return #unordered;
	end if;
    end op "=?";

    func Is_Empty(S : Ordered_Set) -> Boolean is
        // Return count of items in set
	return Count(S.Items) == 0;
    end func Is_Empty;

    func Lower_Bound(S : Ordered_Set) -> optional Element_Type is
        const First_IV := First(S.Items);
        if First_IV is null then
            return null;
        else
            return First_IV.Low;
        end if;
    end func Lower_Bound;

    func Lower_Bound_Is_Open(S : Ordered_Set) -> Boolean is
        const First_IV := First(S.Items);
        if First_IV is null then
            return #true;  // TBD: or null?
        else
            return First_IV.Low_Is_Open;
        end if;
    end func Lower_Bound_Is_Open;

    func Upper_Bound(S : Ordered_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items);
        if Last_IV is null then
            return null;
        else
            return Last_IV.High;
        end if;
    end func Upper_Bound;

    func Upper_Bound_Is_Open(S : Ordered_Set) -> Boolean is
        const Last_IV := Last(S.Items);
        if Last_IV is null then
            return #true;  // TBD: or null?
        else
            return Last_IV.High_Is_Open;
        end if;
    end func Upper_Bound_Is_Open;

    func Remove_First(var S : Ordered_Set) 
      -> optional Interval<Element_Type> is
	// Remove first interval of set (lowest low bound)
	return Remove_First(S.Items);
    end func Remove_First;

    func Remove_Last(var S : Ordered_Set) 
      -> optional Interval<Element_Type> is
	// Remove last interval of set (highest high bound)
	return Remove_Last(S.Items);
    end func Remove_Last;

    func Remove_Any(var S : Ordered_Set) 
      -> optional Interval<Element_Type> is
	// Remove an arbitrary interval of set
	return Remove_Any(S.Items);
    end func Remove_Any;

end class Ordered_Set;

interface Univ_Real<> is
    op "+"(Right : Univ_Real) -> Univ_Real
      is import(#identity);

    op "-"(Right : Univ_Real) -> Univ_Real
      is import(#real_negate);

    op "abs"(Right : Univ_Real) -> Univ_Real
      is import(#real_abs);

    op "+"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_add);

    op "-"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_subtract);

    op "*"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_multiply);

    op "/"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_divide);

    op "**"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_exp);

    op "+="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_add);

    op "-="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_subtract);

    op "*="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_multiply);

    op "/="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_divide);

    op "**="(var Left : Univ_Real; Right : Univ_Integer) 
      is import(#real_assign_exp);


    op "=?"(Left, Right : Univ_Real) -> Ordering
      is import(#real_compare);

    func Min(Left, Right : Univ_Real) -> Univ_Real
      is import(#real_min);
    func Max(Left, Right : Univ_Real) -> Univ_Real
      is import(#real_max);

    func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Univ_Real;

    func Hash(Val : Univ_Real) -> Univ_Integer
      is import(#identity);

    func Print(X : Univ_Real) is import(#print_real);

    func To_String(Val : Univ_Real) -> Univ_String
      is import(#to_string_real);

    func From_String(Str : Univ_String) -> optional Univ_Real
      is import(#from_string_real);

    func Round_To_Int(Real : Univ_Real) -> Univ_Integer
      is import(#round_to_int);

    func Int_To_Real(Int : Univ_Integer) -> Univ_Real
      is import(#int_to_real);

    op "in"(Left : Univ_Real; Right : Ordered_Set<Univ_Real>) -> Boolean
      is in Ordered_Set<Univ_Real>;

end interface Univ_Real;

class Univ_Real is
  exports
    func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Result : Univ_Real is
	{Val >= 0.0}
	Result := Val / 2.0;
	while Result > 0.0 and then Result * Result / Val 
	  not in 0.9999999999999 .. 1.00000000000001 loop
	    Result := (Val / Result + Result)/2.0;
	end loop;
    end func Sqrt;

end class Univ_Real;
    
abstract interface Indexable
  <Elem_Type is Assignable<>; Index_Type is Countable<>> is
    // An indexable container
    op "indexing"(ref A : Indexable; Index : Index_Type) -> ref Elem_Type;
    op "var_indexing"(ref var A : Indexable; Index : Index_Type)
      -> ref var Elem_Type;
    func Length(A : Indexable) -> Univ_Integer;
    op "index_set"(A : Indexable) -> Countable_Set<Index_Type>;
end interface Indexable;

interface Basic_Array<Element_Type is Assignable<>> is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
    func Create(Length : Univ_Integer<>; Val : Element_Type) -> Basic_Array 
      is import(#basic_array_create);
    op "indexing"(ref V : Basic_Array; Index : Univ_Integer<>) -> 
      ref Element_Type is import(#basic_array_indexing);
    op "var_indexing"(ref var V : Basic_Array; Index : Univ_Integer<>) -> 
      ref var Element_Type is import(#basic_array_indexing);
    func Length(V : Basic_Array) -> Univ_Integer<>
      is import(#basic_array_length);
    op "|"(Left, Right : Basic_Array) -> Basic_Array;
    op "index_set"(A : Basic_Array) -> Countable_Set<Univ_Integer>;
end interface Basic_Array;

class Basic_Array is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
  exports
    op "|"(Left, Right : Basic_Array) -> Result : Basic_Array is
        const Left_Len := Length(Left);

        if Left_Len == 0 then
            return Right;
        end if;

        Result := Create(Left_Len + Length(Right), null);

        // Copy the Left elements
        for I in 1..Left_Len concurrent loop
            Result[I] := Left[I];
        end loop;

        // Copy the Right elements
        
        for J in 1..Length(Right) concurrent loop
            Result[Left_Len + J] := Right[J];
        end loop;
    end op "|";
            
    op "index_set"(A : Basic_Array) -> Countable_Set<Univ_Integer> is
	return 1..Length(A);
    end op "index_set";
end class Basic_Array;

interface Vector<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Extendable vector, indexed by Univ_Integer, 1..Length
    op "[]"() -> Vector;
    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type;
    op "var_indexing"(ref var V : Vector; Index : Univ_Integer) -> 
      ref var optional Element_Type;
        // Used for adding elements to a vector
    op "index_set"(V : Vector) -> Countable_Set<Univ_Integer>;
    op "|="(var V : Vector; Elem : Element_Type);
    op "<|="(var V : Vector; var Elem : optional Element_Type);
    op "|"(Left, Right : Vector) -> Vector;
    func Length(V : Vector) -> Univ_Integer;
end interface Vector;
    
class Vector is
  // Extendable vector, indexed by Univ_Integer, 1..Length
    const Initial_Size := 4;
    var Count : Univ_Integer := 0;
    var Data : optional Basic_Array<optional Element_Type>;

    func Expand_By_One(var V : Vector) is
        // Expand size by one
        if V.Data is null then
            V.Data := Create(Initial_Size, null);
        elsif V.Count == Length(V.Data) then
            // Double the size
            var Old_Data <== V.Data;
            V.Data := Create(2*V.Count, null);
            for I in 1..V.Count loop
                V.Data[I] <== Old_Data[I];
            end loop;
            Old_Data := null;
        end if;
        V.Count += 1;
    end func Expand_By_One;
        
  exports
    op "[]"() -> Vector is
        return (Count => 0, Data => null);
    end op "[]";

    func Length(V : Vector) -> Univ_Integer is
        return V.Count;
    end func Length;

    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type is
        {Index in 1..V.Count}  // Index out of bounds
        return V.Data[Index];
    end op "indexing";

    op "var_indexing"(ref var V : Vector; Index : Univ_Integer) -> 
      ref var optional Element_Type is
        // Used for adding elements to a vector
        // Add "null"s to end of Vector until big enough
        // TBD: Expand all at once to right size
        for I in V.Count+1 .. Index loop
            V |= null;
        end loop;

        return V.Data[Index];
    end op "var_indexing";

    op "index_set"(V : Vector) -> Countable_Set<Univ_Integer> is
        return 1..Length(V);
    end op "index_set";

    op "<|="(var V : Vector; var Elem : optional Element_Type) is
        Expand_By_One(V);
        V.Data[V.Count] <== Elem;
    end op "<|=";

    op "|="(var V : Vector; Elem : Element_Type) is
        Expand_By_One(V);
        V.Data[V.Count] := Elem;
    end op "|=";
    
    op "|"(Left, Right : Vector) -> Result : Vector is
        // Copy left into result, and then add in the Right elements
        if Left.Count == 0 then
            // Left is null vector; result is determined by Right
            Result := Right;
        else
            // Start with Left
            Result := Left;
            // Assign all elements of Right into tail of Result.
            // TBD: Would be more efficient to grow vector once and then
            //      copy in the contents of Result.
            for I in 1..Length(Right) forward loop
                Result |= Right[I];
            end loop;
        end if;
    end op "|";

end class Vector;

interface Slice<Array_Type is Indexable<>> is
  // A sliceable array.
    const First : Array_Type::Index_Type;
    const Last : Array_Type::Index_Type;

    func Length(S : Slice) -> Univ_Integer;
        // Return length of slice (i.e. Last - First + 1)

    op "slicing"(ref A : Array_Type) -> ref Slice;
        // Convert an array into a slice covering 1..Length(A)

    op "slicing"(ref A : Array_Type; 
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice;
        // Slice of an array

    op "slicing"(ref S : Slice; 
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice;
        // Slice of a slice

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type;
        // Index into a slice

    op "index_set"(S : Slice) -> Countable_Set<Array_Type::Index_Type>;
end interface Slice;

class Slice is
    ref Arr : Array_Type;
  exports
    func Length(S : Slice) -> Univ_Integer is
        // Return length of slice (i.e. Last - First + 1)
        return S.Last - S.First + 1;
    end func Length;

    op "slicing"(ref A : Array_Type) -> ref Slice is
        // Convert an array into a slice covering whole array
        const A_Bounds := "index_set"(A);
        return (First => First(A_Bounds), Last => Last(A_Bounds), Arr => A);
    end op "slicing";

    op "slicing"(ref A : Array_Type; 
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of an array
        const A_Bounds := "index_set"(A);
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= First(A_Bounds) and then 
            Bounds.Last <= Last(A_Bounds))} //slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => A);
    end op "slicing";

    op "slicing"(ref S : Slice; 
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of a slice
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= S.First and then Bounds.Last <= S.Last)}
          // slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => S.Arr);
    end op "slicing";

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type is
        // Index into a slice
        {Index >= S.First and then Index <= S.Last}
          // array index out of bounds
        return S.Arr[Index];
    end op "indexing";
    
    op "index_set"(S : Slice) -> Countable_Set<Array_Type::Index_Type> is
        return S.First .. S.Last;
    end op "index_set";
end class Slice;

interface Enum<Literals : Vector<Univ_Enumeration>> is
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit == Univ)}
      -> Enum;
    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)};

    op "=?"(Left, Right : Enum) -> Ordering
      is import("=?");

    // Functions for Imageable
    func To_String(Val : Enum) -> Univ_String;
    func From_String(Str : Univ_String) -> optional Enum;

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Enum) -> Enum 
      is import("+");
    op "+"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("+");
    op "-"(Left, Right : Enum) -> Univ_Integer 
      is import("-");
    op "-"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("-");

    // TBD: These should be properties some day (e.g. Color#first).
    func First()->Enum;
    func Last()->Enum;
    func Range()->Countable_Range<Enum> is "[..]" in Countable_Range<Enum>;

    op "[..]"() -> Countable_Range<Enum> is in Countable_Range<Enum>;

    func Hash(Val : Enum) -> Univ_Integer
      is import(#identity);

    op ".."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>;
    op "<.."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>;
    op "..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>;
    op "<..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>;
    op "|"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>;
end interface Enum;

class Enum is
    const Value : Univ_Integer;
  exports
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit == Univ)}
      -> Enum is
        for I in 1..Length(Literals) loop
            if Literals[I] == Univ then
                return (Value => I-1);
            end if;
        end loop;
	{#false}
    end op "from_univ";

    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)} is
	if Val is null then
	    return null;
	else
	    return Literals[Val.Value+1];
	end if;
    end op "to_univ";

    // Functions for Imageable
    func To_String(Val : Enum) -> Univ_String is
	return Univ_Enumeration::To_String([[Val]]);
    end func To_String;

    func From_String(Str : Univ_String) -> optional Enum is
	return Univ_Enumeration::From_String(Str);
    end func From_String;

    func First()->Enum is
        return (Value => 0);
    end func First;

    func Last()->Enum is
        return (Value => Length(Literals)-1);
    end func Last;

end class Enum;

interface Map<Key_Type is Hashable<>; Value_Type is Assignable<>> is
  // A hashed-map module
    type Pair is Key_Value<Key_Type, Value_Type>;

    op "[]"() -> Map;

    op "|="(var Left : Map; Right : Pair);
	// Add Key=>Value to Map, replacing pre-existing mapping
	// for Key, if any.

    op "<|="(var Left : Map; var Right : optional Pair);
	// Move Key/Value pair into map, leaving Right null

    op "<|="(var Left : Map; var Right : Map);
	// Move key/value pairs from Right into Left, leaving Right empty,
	// replacing any pre-existing entries with the same key.

    op "+="(var Left : Map; Right : Pair) is "|=";
	// A synonym for adding a key=>value pair

    op "in"(Left : Key_Type; Right : Map) -> Boolean;
	// Return True if given key has a mapping in the Map

    op "-="(var M : Map; Key : Key_Type);  // aka Exclude
	// Remove mapping for Right, if present

    op "index_set"(M : Map) -> Set<Key_Type>;
	// Return set of keys with mappings

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type;
	// Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type;
	// Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Map) -> optional Pair;
	// Remove one mapping from the Map.  Return null if Map is empty

    func Count(M : Map) -> Univ_Integer;
	// Number of mappings in the table

    func Is_Empty(M : Map) -> Boolean;
	// Return True if no mappings in the table

    func Dump_Statistics(M : Map);
      // A debugging routine to show bucket sizes of Map

end interface Map;

class Map is
  // A hashed-map module

    var Data : Basic_Map<Key_Value<Key_Type, Value_Type>>;

  exports
    op "[]"() -> Map is
        return (Data => []);
    end op "[]";

    op "|="(var Left : Map; Right : Pair) is
	// Add Key=>Value to Map, replacing pre-existing mapping
	// for Key, if any.
	Left.Data |= Right;
    end op "|=";

    op "<|="(var Left : Map; var Right : optional Pair) is
	// Move Key/Value pair into map, leaving Right null
	Left.Data <|= Right;
    end op "<|=";

    op "<|="(var Left : Map; var Right : Map) is
	// Move key/value pairs from Right into Left, leaving Right empty,
	// replacing any pre-existing entries with the same key.
	loop
	    var Right_Elem for Left := Remove_Any(Right);
	    if Right_Elem is null then
		return;  // All done
	    end if;

	    Left.Data <|= Right_Elem;
	end loop;
    end op "<|=";

    op "in"(Left : Key_Type; Right : Map) -> Boolean is
	return Left in Right.Data;
    end op "in";

    op "-="(var M : Map; Key : Key_Type) is
      // Remove the given key from the Map, if present
	M.Data -= Key;
    end op "-=";
   
    op "index_set"(M : Map) -> Result : Set<Key_Type> is
	// Return set of keys with non-null mappings
	return "index_set"(M.Data);
    end op "index_set";

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type is
	// Used for references to M[Key]; requires the Key to be in M.
	return M.Data[Key].Value;
    end op "indexing";

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type is
	// Used for assignments to M[Key]; Key is added to M if not present
	return "var_indexing"(M.Data, Key).Value;
    end op "var_indexing";

    func Count(M : Map) -> Univ_Integer is
	return Count(M.Data);
    end func Count;

    func Is_Empty(M : Map) -> Boolean is
	// Return True if no mappings in the table
	return Is_Empty(M.Data);
    end func Is_Empty;

    func Remove_Any(var M : Map) -> Result : optional Pair is
	return Remove_Any(M.Data);
    end func Remove_Any;

    func Dump_Statistics(M : Map) is
      // A debugging routine to show bucket sizes of Map
	Dump_Statistics(M.Data);
    end func Dump_Statistics;

end class Map;

interface Float<Digits : Univ_Integer := 15> is
  // A floating point type that provides at least the
  // given number of digits of precision.

    op "from_univ"(Univ : Univ_Real) -> Float
      is import(#identity);

    op "to_univ"(Val : Float) -> Univ_Real
      is import(#identity);

    op "+"(Right : Float) -> Float
      is import(#identity);

    op "-"(Right : Float) -> Float
      is import(#real_negate);

    op "abs"(Right : Float) -> Float
      is import(#real_abs);

    op "+"(Left, Right : Float) -> Result : Float 
      is import(#real_add);

    op "-"(Left, Right : Float) -> Result : Float
      is import(#real_subtract);

    op "*"(Left, Right : Float) -> Result : Float 
      is import(#real_multiply);

    op "/"(Left, Right : Float) -> Result : Float
      is import(#real_divide);

    op "**"(Left : Float; Right : Univ_Integer) -> Float
      is import(#real_exp);

    op "+="(var Left : Float; Right : Float) 
      is import(#real_assign_add);

    op "-="(var Left : Float; Right : Float) 
      is import(#real_assign_subtract);

    op "*="(var Left : Float; Right : Float) 
      is import(#real_assign_multiply);

    op "/="(var Left : Float; Right : Float) 
      is import(#real_assign_divide);

    op "**="(var Left : Float; Right : Univ_Integer) 
      is import(#real_assign_exp);


    op "=?"(Left, Right : Float) -> Ordering
      is import(#real_compare);

    func Min(Left, Right : Float) -> Float
      is import(#real_min);
    func Max(Left, Right : Float) -> Float
      is import(#real_max);

    func Hash(Val : Float) -> Univ_Integer
      is import(#identity);

    func Round_To_Int(Val : Float) -> Univ_Integer
      is import(#round_to_int);

    func Print(X : Float) is import(#print_real);

    func To_String(Val : Float) -> Univ_String
      is import(#to_string_real);

    func From_String(Str : Univ_String) -> optional Float
      is import(#from_string_real);

    op "in"(Left : Float; Right : Ordered_Set<Float>) -> Boolean
      is in Ordered_Set<Float>;
	// "in" defined in Ordered_Set

end interface Float;

class Float is
    const Value : Univ_Real;
  exports
end class Float;
    
interface Fixed<Delta : Univ_Real> is
  // Fixed point types, represented as an integer
  // multiple of the given Delta
    op "from_univ"(Univ : Univ_Real) -> Fixed;
    op "to_univ"(Val : Fixed) -> Univ_Real;

    op "+"(Right : Fixed) -> Fixed
      is import(#identity);

    op "-"(Right : Fixed) -> Fixed
      is import(#negate);

    op "abs"(Right : Fixed) -> Fixed
      is import("abs");

    op "+"(Left, Right : Fixed) -> Fixed
      is import("+");
    op "-"(Left, Right : Fixed) -> Fixed
      is import("-");
    op "*"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_mul);
    op "*"(Left : Univ_Real; Right : Fixed) -> Fixed
      is import(#real_fixed_mul);
    op "*"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("*");
    op "*"(Left : Univ_Integer; Right : Fixed) -> Fixed
      is import("*");
    op "/"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_div);
    op "/"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("/");

    op "+="(var Left : Fixed; Right : Fixed) 
      is import("+=");

    op "-="(var Left : Fixed; Right : Fixed) 
      is import("-=");

    op "*="(var Left : Fixed; Right : Fixed) 
      is import("*=");

    op "/="(var Left : Fixed; Right : Univ_Integer) 
      is import("/=");

    op "/="(var Left : Fixed; Right : Univ_Real);

    op "=?"(Left, Right : Fixed) -> Ordering
      is import("=?");

    func Min(Left, Right : Fixed) -> Fixed
      is import(#min);
    func Max(Left, Right : Fixed) -> Fixed
      is import(#max);

    func Hash(Val : Fixed) -> Univ_Integer
      is import(#identity);

    func Round_To_Int(Val : Fixed) -> Univ_Integer;

    func Print(X : Fixed);

    func To_String(Val : Fixed) -> Univ_String;

    func From_String(Str : Univ_String) -> optional Fixed;

    op "in"(Left : Fixed; Right : Ordered_Set<Fixed>) 
      -> Boolean is in Ordered_Set<Fixed>;
    
end interface Fixed;

class Fixed is
    const Value : Univ_Integer;

  exports
    op "from_univ"(Univ : Univ_Real) -> Fixed is
	return (Value => Univ_Real::Round_To_Int(Univ/Delta));
    end op "from_univ";

    op "to_univ"(Val : optional Fixed) -> optional Univ_Real is
	if Val is null then
	    return null;
	else
	    return Delta * Int_To_Real(Val.Value);
	end if;
    end op "to_univ";

    op "/="(var Left : Fixed; Right : Univ_Real) is
	Left := Left / Right;
    end op "/=";

    func Print(X : Fixed) is
	var Val : Univ_Real := [[X]];
	Print(Val);
    end func Print;

    func To_String(Val : Fixed) -> Univ_String is
	return Univ_Real::To_String([[Val]]);
    end func To_String;

    func From_String(Str : Univ_String) -> optional Fixed is
	return Univ_Real::From_String(Str);
    end func From_String;

    func Round_To_Int(Val : Fixed) -> Univ_Integer is
	return Univ_Real::Round_To_Int([[Val]]);
    end func Round_To_Int;

end class Fixed;

interface Array<Elem_Type is Assignable<>; Indexed_By is Countable<>> is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    func Create(Bounds : Countable_Range<Indexed_By>; Initial_Value : Elem_Type)
      -> Array;

    func Length(Arr : Array) -> Univ_Integer;
    func Bounds(Arr : Array) -> Countable_Range<Indexed_By>;

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type;
    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type;
    op "<|="(var Left : Array; var Right : optional Elem_Type);
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) -> Array;
    op "[]"() -> Array;
end interface Array;

class Array is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    type Elem_Array is Basic_Array<Elem_Type>;
    var Data : Elem_Array;
    const Bounds : Countable_Range<Indexed_By>;
  exports

    func Create(Bounds : Countable_Range<Indexed_By>; Initial_Value : Elem_Type)
      -> Array is
	return (Data => Create(Length(Bounds), Initial_Value),
	  Bounds => Bounds);
    end func Create;

    func Length(Arr : Array) -> Univ_Integer is
	return Length(Arr.Data);
    end func Length;

    func Bounds(Arr : Array) -> Countable_Range<Indexed_By> is
	return Arr.Bounds;
    end func Bounds;

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type is
	return Arr.Data[ Index - Arr.Bounds.First + 1 ];
    end op "indexing";

    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type is
	if Length(Arr) == 0 then
	    -- Create a one-element array
	    Arr := (Data => Create(1, null),
	      Bounds => Index .. Index);
	elsif Index < Arr.Bounds.First then
	    // Extend below
	    Arr := (Data => 
	      Elem_Array::Create(Arr.Bounds.First - Index, null) | Arr.Data,
	      Bounds => Index .. Arr.Bounds.Last);
	elsif Index > Arr.Bounds.Last then
	    // Extend above
	    Arr := (Data => 
	      Arr.Data | Elem_Array::Create(Index - Arr.Bounds.Last, null),
	      Bounds => Arr.Bounds.First .. Index);
	end if;
	return Arr.Data[ Index - Arr.Bounds.First + 1 ];
    end op "var_indexing";

    op "<|="(var Left : Array; var Right : optional Elem_Type) is
	// Add Right onto Array
	if Length(Left) == 0 then
	    Left := (Data => Create(1, null),
	      Bounds => Indexed_By::First() .. Indexed_By::First());
	    Left[Indexed_By::First()] <== Right;
	else
	    Left[Left.Bounds.Last + 1] <== Right;
	end if;
    end op "<|=";
    
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      -> Result : Array is
	Result := Left;
	Result[Right.Key] := Right.Value;
    end op "|";

    op "[]"() -> Result : Array is
	return (Data => Create(0, null),
	  Bounds => Indexed_By::First()+1 .. Indexed_By::First());
	    // Bounds not meaningful when empty
    end op "[]";

end class Array;

interface Time<> is
  // Time in nanoseconds since Jan 1, 1970

    type Time_Interval is new Fixed<Delta => 1.0E-9>;

    const Second : Time_Interval := 1.0;
    const Millisecond : Time_Interval := 1.0/1000;
    const Microsecond : Time_Interval := 1.0/10**6;
    const Nanosecond : Time_Interval := 1.0/10**9;

    const Minute : Time_Interval := 60.0;
    const Hour : Time_Interval := 60 * Minute;
    const Day : Time_Interval := 24 * Hour;

    type Month_Enum is Enum< 
       [#Jan, #Feb, #Mar, #Apr, #May, #Jun,
        #Jul, #Aug, #Sep, #Oct, #Nov, #Dec] >;

    func Create(Year : Univ_Integer; Month : Month_Enum; 
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time;

    func Zero() -> Time;

    op "+"(Left : Time; Right : Time_Interval) -> Time
      is import("+");
    op "+"(Left : Time_Interval; Right : Time) -> Time
      is import("+");
    op "-"(Left : Time; Right : Time_Interval) -> Time
      is import("-");
    op "-"(Left, Right : Time) -> Time_Interval
      is import("-");

    op "=?"(Left, Right : Time) -> Ordering
      is import("=?");
end interface Time;

class Time is
    const Since_1970 : Time_Interval;

    type Year_Kind is Enum< [#normal, #leap] >;

    const Month_Base : Array<Array<Univ_Integer, Indexed_By => Year_Kind>,
      Indexed_By => Month_Enum> := 
	[#Jan => [0, 0], #Feb => [31, 31], #Mar => [59, 60], #Apr => [90, 91],
         #May => [120, 121], #Jun => [151, 152], #Jul => [181, 182],
         #Aug => [212, 213], #Sep => [243, 244], #Oct => [273, 274],
         #Nov => [304, 305], #Dec => [334, 335]];

    func Kind_Of_Year(Year : Univ_Integer) -> Year_Kind is
	if Year mod 4 == 0 and then
	  (Year mod 100 != 0 or else Year mod 400 == 0) then
	    // Every 100 years leap year is omitted, 
	    // except for multiples of 400 which *are* leap years.
	    return #leap;
	else
	    return #normal;
	end if;
    end func Kind_Of_Year;

    func Leaps_Before(Year : Univ_Integer) -> Univ_Integer is
	// Number of leap years before this year, starting from 1970
	if Year < 2101 then
	    return (Year-1969)/4;
	else
	    // Every 100 years leap year is omitted, 
	    // except for multiples of 400 which *are* leap years.
	    return (Year-1969)/4 - (Year-2001)/100;
	end if;
    end func Leaps_Before;

  exports
    func Create(Year : Univ_Integer; Month : Month_Enum; 
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time is
	// Determine number of nanos since Jan 1, 1970
	const Kind := Kind_Of_Year(1970);
	const Base := Month_Base[Month][Kind];

	return (Since_1970 => 
	  (Year-1970) * (365*Day) + 
	  (Leaps_Before(Year) + Base + Day_Of_Month)*Day +
	  Time_Of_Day - Time_Zone);
    end func Create;

    func Zero() -> Time is
	return (Since_1970 => 0.0);
    end func Zero;

end class Time;

concurrent interface Clock<> is
    // A module that provides access to a wall clock and
    // to other timers, and an ability to delay the caller
    // for a given amount of time, or until a specified time
    // in the future.
    
    func Create() -> Clock;
	// Create a clock, which corresponds to the current wall clock time

    func Create(Now : Time) -> Clock;
	// Create a clock, where Now() returns the given time when created

    func Now(locked C : Clock) -> Time;
	// Return current reading of clock

    queued func Delay(C : Clock; Until : Time);
	// Wait until the given clock reads >= Until

    queued func Delay(C : Clock; For : Time::Time_Interval);
	// Wait until the given clock reads "Now(C) + For"

    func Set(locked var C : Clock; To : Time);
	// Update clock so it reads the given time
end interface Clock;

concurrent class Clock is

    var Timer_Delta : Time::Time_Interval;  
	// Amount to be subtracted from Current Time
	// to produce value of timer

    func Current_Time(locked C : Clock) -> Time 
      is import(#clock_current_time);
	// NOTE: Clock parameter is ignored; returns wall clock

    func Wait_For_Delay(queued C : Clock; Until : Time) is 
      import(#clock_delay);
	// Wait until the wall clock reads >= Until
	// NOTE: Clock parameter is ignored

  exports
    func Create() -> Clock is
	// Create a clock, which corresponds to the current wall clock time
	// Println("Create Clock with Delta 0.0");
	return (Timer_Delta => 0.0);
    end func Create;

    func Create(Now : Time) -> Result : Clock is
	// Create a clock, where Now() returns the given time when created
	const Delta := Current_Time(Create()) - Now;
	// Println("Create Clock with Delta = " | Delta);
	return (Timer_Delta => Current_Time(Create()) - Now);
    end func Create;

    func Now(locked C : Clock) -> Result : Time is
	// Return current reading of clock
	Result := Current_Time(C) - C.Timer_Delta;
	// Println("Now returning " | Result-Zero());
    end func Now;

    queued func Delay(C : Clock; Until : Time) is
	// Wait until the given clock reads >= Until
	Wait_For_Delay(C, Until + C.Timer_Delta);
    end func Delay;

    queued func Delay(C : Clock; For : Time::Time_Interval) is
	// Wait until the given clock reads "Now(C) + For"
	// NOTE: Timer_Delta is irrelevant for this one
	// Println("Wait for delay of " | For);
	const Time_Now := Current_Time(C);
	const Until := Time_Now + For;
	// Println("Time_Now + " | For | " - Time_Now = " | Until - Time_Now);
	Wait_For_Delay(C, Until);
    end func Delay;

    func Set(locked var C : Clock; To : Time) is
	// Update clock so it reads the given time
	C.Timer_Delta := Current_Time(C) - To;
    end func Set;

end class Clock;

concurrent interface Atomic<Content_Type is Comparable<>> is
    func Create(Initial_Val : Content_Type) -> Atomic;
      // Create an atomic object with given initial value

    func Set_Value(locked var A : Atomic; Val : Content_Type);
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually

    func Value(locked A : Atomic) -> Content_Type;
      // Return the current value
      // TBD: Use atomic hardware instructions eventually

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Content_Type;
      // Set Value(A) to New_Val; Return the prior value.

    func Compare_And_Swap(locked var A : Atomic; 
      Expected_Val, New_Val : Content_Type) -> Content_Type;
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.
end interface Atomic;

concurrent class Atomic is
    var Value : Content_Type;
  exports
    func Create(Initial_Val : Content_Type) -> Atomic is
      // Create an atomic object with given initial value
	return (Value => Initial_Val);
    end func Create;

    func Set_Value(locked var A : Atomic; Val : Content_Type) is
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually
	A.Value := Val;
    end func Set_Value;

    func Value(locked A : Atomic) -> Content_Type is
      // Return the current value
      // TBD: Use atomic hardware instructions eventually
	return A.Value;
    end func Value;

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Result : Content_Type is
      // Set Value(A) to New_Val; Return the prior value.
	Result := A.Value;
	A.Value := New_Val;
    end func Test_And_Set;

    func Compare_And_Swap(locked var A : Atomic; 
      Expected_Val, New_Val : Content_Type) -> Result : Content_Type is
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.
	Result := A.Value;
	if Result == Expected_Val then
	    A.Value := New_Val;
	end if;
    end func Compare_And_Swap;
end class Atomic;

interface Modular<Modulus : Univ_Integer> is
  // This is an unsigned type whose arithmetic is "modulo" the modulus
    op "from_univ"(Lit : Univ_Integer) -> Modular 
      is import(#integer_from_univ);

    op "to_univ"(Val : Modular) -> Univ_Integer 
      is import(#integer_to_univ);

    op "+"(Right : Modular) -> Modular
      is import(#identity);

    op "-"(Right : Modular) -> Modular;

    op "abs"(Right : Modular) -> Modular
      is import(#identity);

    op "+"(Left, Right : Modular) -> Result : Modular;

    op "-"(Left, Right : Modular) -> Result : Modular;

    op "*"(Left, Right : Modular) -> Result : Modular;

    op "/"(Left, Right : Modular) -> Result : Modular
      is import("/");

    op "mod"(Left, Right : Modular) -> Modular
      is import("mod");

    op "rem"(Left, Right : Modular) -> Modular
      is import("rem");

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular;

    op "+="(var Left : Modular; Right : Modular);

    op "-="(var Left : Modular; Right : Modular);

    op "*="(var Left : Modular; Right : Modular);

    op "/="(var Left : Modular; Right : Modular) 
      is import("/=");

    op "**="(var Left : Modular; Right : Univ_Integer);

    op "=?"(Left, Right : Modular) -> Ordering
      is import("=?");

    op ">>"(Modular; Modular) -> Modular is import(">>");

    op "<<"(Modular; Modular) -> Modular is import("<<");

    op "and"(Left, Right : Modular) -> Modular is import(#bit_and);
    op "or"(Left, Right : Modular) -> Modular;
    op "xor"(Left, Right : Modular) -> Modular;
    op "not"(M : Modular) -> Modular;

    func Min(Left, Right : Modular) -> Modular
      is import(#min);
    func Max(Left, Right : Modular) -> Modular
      is import(#max);

    func Hash(Val : Modular) -> Univ_Integer
      is import(#identity);

    func Print(X : Modular) is import(#print_int);

    func To_String(Val : Modular) -> Univ_String
      is import(#to_string_int);

    func From_String(Str : Univ_String) -> optional Modular;

    func First() -> Modular;

    func Last() -> Modular;

    op "[..]"()->Countable_Range<Modular> is in Countable_Range<Modular>;

    op ".."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>;
    op "<.."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>;
    op "..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>;
    op "<..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>;
    op "|"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>;
  implements
  for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular;

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular;

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular;

    op "-"(Left, Right : Modular) -> Result : Univ_Integer;

end interface Modular;

class Modular is
    const Content : Univ_Integer;  -- So this ends up as a wrapper

    func Bit_Or(Left, Right : Univ_Integer) -> Univ_Integer 
      is import(#bit_or);

    func Bit_Xor(Left, Right : Univ_Integer) -> Univ_Integer 
      is import(#bit_xor);
  exports
    op "-"(Right : Modular) -> Modular is
	return (Content => Modulus - Right.Content);
    end op "-";

    op "+"(Left, Right : Modular) -> Result : Modular is
	return (Content => (Left.Content + Right.Content) mod Modulus);
    end op "+";

    op "-"(Left, Right : Modular) -> Result : Modular is
	return (Content => (Left.Content - Right.Content) mod Modulus);
    end op "-";

    op "*"(Left, Right : Modular) -> Result : Modular is
	return (Content => (Left.Content * Right.Content) mod Modulus);
    end op "*";

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
	return (Content => (Left.Content ** Right) mod Modulus);
    end op "**";

    op "+="(var Left : Modular; Right : Modular) is
	Left := (Content => (Left.Content + Right.Content) mod Modulus);
    end op "+=";

    op "-="(var Left : Modular; Right : Modular) is
	Left := (Content => (Left.Content - Right.Content) mod Modulus);
    end op "-=";

    op "*="(var Left : Modular; Right : Modular) is
	Left := (Content => (Left.Content * Right.Content) mod Modulus);
    end op "*=";

    op "**="(var Left : Modular; Right : Univ_Integer) is
	Left := (Content => (Left.Content ** Right) mod Modulus);
    end op "**=";

    func From_String(Str : Univ_String) -> optional Modular is
	const Val : Univ_Integer := From_String(Str);
	if Val is null or else Val in 0..<Modulus then
	    return (Content => Val);
	else
	    return null;
	end if;
    end func From_String;

    op "or"(Left, Right : Modular) -> Modular is
	return (Content => Bit_Or(Left.Content, Right.Content) mod Modulus);
    end op "or";

    op "xor"(Left, Right : Modular) -> Modular is
	return (Content => Bit_Xor(Left.Content, Right.Content) mod Modulus);
    end op "xor";

    op "not"(M : Modular) -> Modular is
	return (Content => Modulus - 1 - M.Content);
    end op "not";

    func First() -> Modular is
	return (Content => 0);
    end func First;

    func Last() -> Modular is
	return (Content => Modulus-1);
    end func Last;

  // implements
  // for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
	return (Content => (Left.Content + Right) mod Modulus);
    end op "+";

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular is
	return (Content => (Left + Right.Content) mod Modulus);
    end op "+";

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
	return (Content => (Left.Content - Right) mod Modulus);
    end op "-";

    op "-"(Left, Right : Modular) -> Result : Univ_Integer is
	return (Left.Content - Right.Content) mod Modulus;
    end op "-";
end class Modular;
    
