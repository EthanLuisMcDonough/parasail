//  Streaming in ParaSail is a three layer cake:
//    Byte Stream is the lowest layer
//    Value Stream is the middle layer
//    Object Stream is the top layer
//
//  This is a JSON-specific Value stream layer.  See byte_stream.psl for
//  an overview of the purpose of each layer.
//
//  See value_stream.psl for the general interface for a Value
//  stream, and an implementation of a binary value stream.

interface PSL::Core::JSON_Value<> is
   //  A ParaSail object that can be used to represent a single
   //  JSON value, or the content of a complete JSON file
   //  (which is defined to be a single JSON value).
   type JSON_Value_Kind is Enum
     <[#Object_Value,
       #Array_Value,
       #String_Value,
       #Number_Value,
       #Boolean_Value,
       #Null_Value]>;

   func Create (Kind : JSON_Value_Kind) -> JSON_Value+;
   //  Create a JSON Value of the given kind

   abstract func Kind (Value : JSON_Value) -> JSON_Value_Kind;

end interface PSL::Core::JSON_Value;

interface PSL::Core::JSON_Object_Value<> extends JSON_Value is
   //  A JSON_Object_Value can be used to represent a "JSON Object"
   //  which in ParaSail parlance is a Map with Keys that are Strings,
   //  and Values that are JSON Values.
   var Value : Ordered_Map<Univ_String, JSON_Value+> := [];

   func Create (Value : Ordered_Map <Univ_String, JSON_Value+> := [])
     -> JSON_Object_Value is ((Value => Value));

   func Kind (Value : JSON_Object_Value) -> JSON_Value_Kind
     is (#Object_Value);
end interface PSL::Core::JSON_Object_Value;

interface PSL::Core::JSON_Array_Value<> extends JSON_Value is
   //  A JSON_Array_Value can be used to represent a "JSON Array"
   //  which in ParaSail parlance is a Vector of JSON Values.
   var Value : Vector<JSON_Value+> := [];

   func Create (Value : Vector <JSON_Value+> := [])
     -> JSON_Array_Value is ((Value => Value));

   func Kind (Value : JSON_Array_Value) -> JSON_Value_Kind
     is (#Array_Value);
end interface PSL::Core::JSON_Array_Value;

interface PSL::Core::JSON_String_Value<> extends JSON_Value is
   //  A JSON_String_Value can be used to represent a "JSON String"
   //  which is equivalent to the ParaSail Univ_String.
   const Value : Univ_String;

   func Create (Value : Univ_String := "")
     -> JSON_String_Value is ((Value => Value));

   func Kind (Value : JSON_String_Value) -> JSON_Value_Kind
     is (#String_Value);
end interface PSL::Core::JSON_String_Value;

interface PSL::Core::JSON_Number_Value<> extends JSON_Value is
   //  A JSON_Number_Value can be used to represent a "JSON Number"
   //  which is equivalent to the ParaSail big-number Rational.
   const Value : Rational;

   func Is_Integer (Number : JSON_Number_Value) -> Boolean
     is (Number.Value.Den() == 1);

   func Create (Value : Rational := 0.0)
     -> JSON_Number_Value is ((Value => Value));

   func Create (Value : Univ_Integer)
     -> JSON_Number_Value is ((Value => Int_To_Rational (Value)));

   func Kind (Value : JSON_Number_Value) -> JSON_Value_Kind
     is (#Number_Value);
end interface PSL::Core::JSON_Number_Value;

interface PSL::Core::JSON_Boolean_Value<> extends JSON_Value is
   //  A JSON_Boolean_Value can be used to represent a "JSON Boolean"
   //  which is equivalent to the ParaSail type Boolean.
   const Value : Boolean;

   func Create (Value : Boolean := #false)
     -> JSON_Boolean_Value is ((Value => Value));

   func Kind (Value : JSON_Boolean_Value) -> JSON_Value_Kind
     is (#Boolean_Value);
end interface PSL::Core::JSON_Boolean_Value;

interface PSL::Core::JSON_Null_Value<> extends JSON_Value is
   //  A JSON_Null_Value can be used to represent a "JSON null"
   //  which is a type that has only one value, namely "null".
   //  It is usually combined with other JSON types as one
   //  alternative to indicate a lack of data.
   type Unit is Enum<[#Null_Value]>;
   const Value : Unit;

   func Create ()
     -> JSON_Null_Value is (JSON_Null_Value::(Value => #Null_Value))

   func Kind (Value : JSON_Null_Value) -> JSON_Value_Kind
     is (#Null_Value);
end interface PSL::Core::JSON_Null_Value;

class PSL::Core::JSON_Value is

 exports

   func Create (Kind : JSON_Value_Kind) -> JSON_Value+ is
   //  Create a JSON Value of the given kind
      case Kind of
       [#Object_Value] =>
         return JSON_Object_Value::Create();
       [#Array_Value] =>
         return JSON_Array_Value::Create();
       [#String_Value] =>
         return JSON_String_Value::Create();
       [#Number_Value] =>
         return JSON_Number_Value::Create();
       [#Boolean_Value] =>
         return JSON_Boolean_Value::Create();
       [#Null_Value] =>
         return JSON_Null_Value::Create();
      end case;
   end func Create;
end class PSL::Core::JSON_Value;

interface PSL::Core::JSON_Output_Value_Stream<>
  extends PSL::Core::Output_Value_Stream<> is
   //  This kind of value stream is used for output of ParaSail values
   //  in JSON format, given a byte stream of some sort.

   func Create(ref var Output_Byte_Stream+) -> JSON_Output_Value_Stream;

   func Is_Self_Describing (JSON_Output_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Output_Value_Stream) -> Boolean;

   func Write_Int (var JSON_Output_Value_Stream; Val : Univ_Integer;
      Low, High : Univ_Integer) {Val in Low .. High};
   func Write_Optional_Int
     (var JSON_Output_Value_Stream; Val : optional Univ_Integer;
      Low, High : Univ_Integer);

   func Write_Float (var JSON_Output_Value_Stream; Val : Univ_Float;
      Digits : Univ_Integer);
   func Write_Optional_Float
     (var JSON_Output_Value_Stream; Val : optional Univ_Float;
      Digits : Univ_Integer);

   func Write_Rational (var JSON_Output_Value_Stream; Val : Rational;
      Digits : Univ_Integer);
   func Write_Optional_Rational
     (var JSON_Output_Value_Stream; Val : optional Rational;
      Digits : Univ_Integer);

   func Write_String (var JSON_Output_Value_Stream; Val : Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
      {Min_Len >= 0 and then |Val| in Min_Len .. Max_Len};
   func Write_Optional_String
     (var JSON_Output_Value_Stream; Val : optional Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer);

   func Write_Begin_Seq (var JSON_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer);
   func Write_Begin_Optional_Seq (var JSON_Output_Value_Stream;
      Min_Len, Max_Len : Univ_Integer; Actual_Len : optional Univ_Integer);

   func Write_End_Seq (var JSON_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer);

   func Write_Begin_Map (var JSON_Output_Value_Stream);
   func Write_Begin_Optional_Map (var JSON_Output_Value_Stream;
      Is_Null : Boolean);

   func Write_End_Map (var JSON_Output_Value_Stream);

   func Write_Begin_Poly
     (var JSON_Output_Value_Stream; Type_Name : Univ_String);
   func Write_Begin_Optional_Poly (var JSON_Output_Value_Stream;
      Type_Name : optional Univ_String);
   func Write_End_Poly (var JSON_Output_Value_Stream);

   func Write_Begin_Obj (var JSON_Output_Value_Stream);
   func Write_Begin_Optional_Obj (var JSON_Output_Value_Stream;
      Is_Null : Boolean);
   func Write_End_Obj (var JSON_Output_Value_Stream);

   func Write_JSON_Value (var JSON_Output_Value_Stream; Value : JSON_Value+);
   //  Write a JSON value to the stream

end interface PSL::Core::JSON_Output_Value_Stream;

class PSL::Core::JSON_Output_Value_Stream is
   ref var Byte_Str : Output_Byte_Stream+;
   var End_Reached : Boolean := #false;
   type JSON_Output_State is Enum
     <[#Initial, #Expecting_First_Seq_Elem, #Expecting_Seq_Elem,
       #Expecting_First_Map_Key, #Expecting_Map_Key, #Expecting_Map_Value]>;
   var State_Stack : Stack<JSON_Output_State> := [#Initial];
   var Indent := 0;
   const Indent_Inc := 2;  --  Indent by 2 each level of nesting

   const Debug : Boolean := #false;

   func Write_UTF8 (var OVS : JSON_Output_Value_Stream; Str : Univ_String) is
      //  Convert Univ_String to UTF8 and then write to OVS.
      //  Set OVS.End_Reached as appropriate.
      const End_Reached := UTF::Output::Encode_Str (OVS.Byte_Str, Str);

      if End_Reached then
         if Debug then
            Println("End Reached while UTF-8 encoding `(Str)");
         end if;
         OVS.End_Reached := #true;
      end if;
   end func Write_UTF8;

   func Start_Item (var OVS : JSON_Output_Value_Stream) is
      //  Emit extra JSON syntax according to current state
      case OVS.State_Stack.Top() of
       [#Initial] =>
         //  Should probably only start an object in this state.
         Write_UTF8 (OVS, "\n");

       [#Expecting_First_Seq_Elem] =>
         //  We have seen a Begin_Seq and have emitted a '['
         //  Start a new line at the appropriate indent.
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

         //  Switch into a state where we should emit a comma before the
         //  emitting the newline.
         OVS.State_Stack.Top() := #Expecting_Seq_Elem;

       [#Expecting_Seq_Elem] =>
         //  We have emitted at least one element of a sequence.
         //  Emit a comma and then start a new line at the correct indent.
         Write_UTF8 (OVS, ",\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

       [#Expecting_First_Map_Key] =>
         //  We have seen a Begin_Map and have emitted a '{'
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

         //  Switch into a state where we should emit a colon before the
         //  value
         OVS.State_Stack.Top() := #Expecting_Map_Value;

       [#Expecting_Map_Key] =>
         //  We have seen a map value, so this must be a key;
         //  emit a ',' a newline, and an indent
         Write_UTF8 (OVS, ",\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');

         //  Switch back into Expecting_Map_Value,
         //  since we are expecting a value
         OVS.State_Stack.Top() := #Expecting_Map_Value;

       [#Expecting_Map_Value] =>
         //  We have seen a map key, emit a ':' and a space
         Write_UTF8 (OVS, ": ");

         //  Switch into a state where we should emit a comma and a newline
         //  before the next key/value pair.
         OVS.State_Stack.Top() := #Expecting_Map_Key;

      end case;
   end func Start_Item;

   func Write_Begin_JSON_Array (var OVS: JSON_Output_Value_Stream) is
      OVS.Indent += Indent_Inc;
      Push (OVS.State_Stack, #Expecting_First_Seq_Elem);

      Write_UTF8 (OVS, "[");
   end func Write_Begin_JSON_Array;

   func Write_End_JSON_Array (var OVS: JSON_Output_Value_Stream) is
      OVS.Indent -= Indent_Inc;

      //  Pop the state stack
      const Old_State : JSON_Output_State := OVS.State_Stack.Pop();

      case Old_State of
       [#Expecting_First_Seq_Elem] =>
         //  We have seen a Begin_JSON_Array and have emitted a '['
         //  This must be an empty array.
         Write_UTF8 (OVS, "]");

       [#Expecting_Seq_Elem] =>
         //  We have emitted at least one element of a sequence.
         //  Start a new line and write the closing ']' with indent.
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');
         Write_UTF8 (OVS, "]");

       [#Initial |
        #Expecting_First_Map_Key |
        #Expecting_Map_Key |
        #Expecting_Map_Value] =>
         //  Not expected!
         if Debug then
            Println ("Expected state of #Expecting_First_Seq_Elem or " |
                     "#Expecting_Seq_Elem, found `(Old_State)");
         end if;

         {#false}
      end case;
   end func Write_End_JSON_Array;

   func Escape_Chars_In_Str (Str : Univ_String) -> Univ_String is
   //  Prefix any special characters that appear in Str so they are acceptable
   //  as a JSON string.
      var Escaped_Part : Vector<Univ_Character> := [];
      var Unescaped := 0;

      for I in 1 .. |Str| forward loop
         const C := Str[I];
         const Code := C - UTF::Nul_Ch;

         case (Code) of
          [0 .. 0x20 | 0x102000 .. (UTF::Last_Ch - UTF::Nul_Ch)] =>
            //  Figure out the letter to use with '\'
            var Letter : optional Univ_Character := null;

            case C of
             ['\b'] => Letter := 'b';
             ['\f'] => Letter := 'f';
             ['\n'] => Letter := 'n';
             ['\r'] => Letter := 'r';
             ['\t'] => Letter := 't';
             [..]   => Letter := 'u';
            end case;

            Escaped_Part |= '\\';
            Escaped_Part |= Letter;
            if Letter == 'u' then
               //  4 hex-digit unicode
               for Divisor := 16**3 then Divisor / 16 while Divisor > 0 loop
                  const Digit := (Code / Divisor) mod 16;

                  //  Append the correct hex digit
                  if Digit < 10 then
                     Escaped_Part |= Digit + '0';
                  else
                     Escaped_Part |= (Digit - 10) + 'A';
                  end if;
               end loop;
            end if;

          ['"' - UTF::Nul_Ch | '\\' - UTF::Nul_Ch] =>
             //  A simple escape
             Escaped_Part |= '\\';
             Escaped_Part |= C;

          [..] =>
            //  No escape
            if |Escaped_Part| > 0 then
               Escaped_Part |= C;
            else
               //  Have not seen a character needing an escape
               Unescaped := I;
            end if;
         end case;
      end loop;
      if |Escaped_Part| == 0 then
         //  Nothing needed escaping
         return Str;
      else
         //  Combine unescaped part with escaped part
         return Str[1 .. Unescaped] | From_Vector (Escaped_Part);
      end if;
   end func Escape_Chars_In_Str;

 exports

   func Create(ref var Output_Byte_Stream+) -> JSON_Output_Value_Stream is
     ((Byte_Str => Output_Byte_Stream));

   func Is_Self_Describing (JSON_Output_Value_Stream) -> Boolean is
     (#true);
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Output_Value_Stream) -> Boolean is
     (JSON_Output_Value_Stream.End_Reached);

   func Write_Int (var OVS: JSON_Output_Value_Stream; Val : Univ_Integer;
      Low, High : Univ_Integer) is

      {Val not null}
      Write_Optional_Int (OVS, Val, Low, High);
   end func Write_Int;

   func Write_Optional_Int
     (var OVS : JSON_Output_Value_Stream; Val : optional Univ_Integer;
      Low, High : Univ_Integer) is

      Start_Item (OVS);

      if Debug then
         Println
           ("JSON Write_(Optional_)Int, Low = `(Low), High = `(High)" |
            ", Val = `(Val)");
      end if;

      const Str := (if Val is null then "null" else To_String (Val));
      Write_UTF8 (OVS, Str);
   end func Write_Optional_Int;

   func Write_Float (var OVS: JSON_Output_Value_Stream; Val : Univ_Float;
      Digits : Univ_Integer) is
      //  Just pass the buck to the optional one
      Write_Optional_Float (OVS, Val, Digits);
   end func Write_Float;

   func Write_Optional_Float
     (var OVS : JSON_Output_Value_Stream; Val : optional Univ_Float;
      Digits : Univ_Integer) is

      Start_Item(OVS);

      if Debug then
         Println
           ("JSON Write_Optional_Float, Digits = `(Digits)" |
            ", Val = `(Val)");
      end if;

      const Str := (if Val is null then "null" else To_String (Val));
      Write_UTF8 (OVS, Str);
   end func Write_Optional_Float;

   func Write_Rational (var OVS : JSON_Output_Value_Stream; Val : Rational;
      Digits : Univ_Integer) is
      Write_Optional_Rational (OVS, Val, Digits);
   end func Write_Rational;

   func Write_Optional_Rational
     (var OVS : JSON_Output_Value_Stream; Val : optional Rational;
      Digits : Univ_Integer) is

      Start_Item(OVS);

      if Debug then
         Println
           ("JSON Write_Optional_Rational, Digits = `(Digits)" |
            ", Val = `(Val)");
      end if;

      const Str := (if Val is null then "null" else To_String (Val));
      Write_UTF8 (OVS, Str);
   end func Write_Optional_Rational;

   func Write_String (var OVS : JSON_Output_Value_Stream; Val : Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer) is
      //  Use UTF-8
      
      {Val not null}
      //  Pass the buck
      Write_Optional_String (OVS, Val, Max_Char, Min_Len, Max_Len);
   end func Write_String;

   func Write_Optional_String
     (var OVS : JSON_Output_Value_Stream; Val : optional Univ_String;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer) is
      //  Write a string surrounded by double quotes, or just the word null.

      Start_Item (OVS);

      const Str :=
        (if Val is null then "null"
         else '"' | Escape_Chars_In_Str (Val) | '"');

      Write_UTF8 (OVS, Str);
   end func Write_Optional_String;

   func Write_Begin_Seq (var OVS : JSON_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer) is

      {Actual_Len not null}
      //  Just pass the buck to the "optional" version
      Write_Begin_Optional_Seq (OVS, Min_Len, Max_Len, Actual_Len);
   end func Write_Begin_Seq;
    
   func Write_Begin_Optional_Seq (var OVS : JSON_Output_Value_Stream;
      Min_Len, Max_Len : Univ_Integer; Actual_Len : optional Univ_Integer) is

      Start_Item (OVS);

      if Actual_Len is null then
         Write_UTF8 (OVS, "null");
      else
         Write_Begin_JSON_Array (OVS);
      end if;
   end func Write_Begin_Optional_Seq;

   func Write_End_Seq (var OVS : JSON_Output_Value_Stream;
      Min_Len, Max_Len, Actual_Len : Univ_Integer) is
      //  Emit "]" optionally preceded by a newline
      //  Pop the state stack and reduce the indent

      Write_End_JSON_Array (OVS);
   end func Write_End_Seq;

   func Write_Begin_Map (var OVS : JSON_Output_Value_Stream) is
      //  Just pass the buck to the "optional" version
      Write_Begin_Optional_Map (OVS, Is_Null => #false);
   end func Write_Begin_Map;

   func Write_Begin_Optional_Map (var OVS : JSON_Output_Value_Stream;
      Is_Null : Boolean) is

      Start_Item (OVS);

      if Is_Null then
         Write_UTF8 (OVS, "null");
      else
         OVS.Indent += Indent_Inc;
         Push (OVS.State_Stack, #Expecting_First_Map_Key);

         Write_UTF8 (OVS, "{");
      end if;
   end func Write_Begin_Optional_Map;

   func Write_End_Map (var OVS : JSON_Output_Value_Stream) is
      //  Emit "}" optionally preceded by a newline
      //  Pop the state stack and reduce the indent

      OVS.Indent -= Indent_Inc;

      //  Pop the state stack
      const Old_State : JSON_Output_State := OVS.State_Stack.Pop();

      case Old_State of
       [#Expecting_First_Map_Key] =>
         //  We have seen a Begin_Map and have emitted a '{'
         //  This must be an empty object.
         Write_UTF8 (OVS, "}");

       [#Expecting_Map_Key] =>
         //  We have emitted at least one key/value pair.
         //  Start a new line and write the closing '}' with indent.
         Write_UTF8 (OVS, "\n");
         Write_UTF8 (OVS, OVS.Indent * ' ');
         Write_UTF8 (OVS, "}");

       [#Initial |
        #Expecting_First_Seq_Elem |
        #Expecting_Seq_Elem |
        #Expecting_Map_Value] =>
         //  Not expected!
         if Debug then
            Println ("Expected state of #Expecting_First_Map_Key or " |
                     "#Expecting_Map_Key, found `(Old_State)");
         end if;

         {#false}
      end case;
   end func Write_End_Map;

   func Write_Begin_Poly
     (var JSON_Output_Value_Stream; Type_Name : Univ_String)
      is (null); -- TBD
   func Write_Begin_Optional_Poly (var JSON_Output_Value_Stream;
      Type_Name : optional Univ_String) is (null); -- TBD
   func Write_End_Poly (var JSON_Output_Value_Stream) is (null); -- TBD

   func Write_Begin_Obj (var OVS : JSON_Output_Value_Stream) is
      //  Just pass the buck to the "optional" version
      Write_Begin_Optional_Obj (OVS, Is_Null => #false);
   end func Write_Begin_Obj;

   func Write_Begin_Optional_Obj (var OVS : JSON_Output_Value_Stream;
      Is_Null : Boolean) is
      //  Treat an "object" as a sequence of components
      //  Preferred would be a set of key/value pairs

      Start_Item (OVS);

      if Is_Null then
         Write_UTF8 (OVS, "null");
      else
         Write_Begin_JSON_Array (OVS);
      end if;
   end func Write_Begin_Optional_Obj;

   func Write_End_Obj (var OVS : JSON_Output_Value_Stream) is
      //  Emit "]" optionally preceded by a newline
      //  Pop the state stack and reduce the indent

      Write_End_JSON_Array (OVS);
   end func Write_End_Obj;

   func Write_JSON_Value
     (var OVS : JSON_Output_Value_Stream; Value : JSON_Value+) is
   //  Write a JSON value to the stream
      {Value not null}
      case Value of
       [Obj : JSON_Object_Value] =>
         Write_Begin_Map (OVS);
         for each [Key => Val] of Obj.Value forward loop
            Write_String (OVS, Key, Univ_Character::Last(),
              Min_Len => 0, Max_Len => |Key|);
            Write_JSON_Value (OVS, Val);
         end loop;
         Write_End_Map (OVS);

       [Arr : JSON_Array_Value] =>
         Write_Begin_Seq (OVS,
           Min_Len => 0, Max_Len => |Arr.Value|, Actual_Len => |Arr.Value|);
         for each Elem of Arr.Value forward loop
            Write_JSON_Value (OVS, Elem);
         end loop;
         Write_End_Seq (OVS,
           Min_Len => 0, Max_Len => |Arr.Value|, Actual_Len => |Arr.Value|);

       [Str : JSON_String_Value] =>
         Write_String (OVS, Str.Value, Univ_Character::Last(),
           Min_Len => 0, Max_Len => |Str.Value|);

       [Num : JSON_Number_Value] =>
         Write_Rational (OVS, Num.Value, Digits => 1000);

       [Bool : JSON_Boolean_Value] =>
         Start_Item (OVS);
         Write_UTF8 (OVS, (if Bool.Value then "true" else "false"));

       [JSON_Null : JSON_Null_Value] =>
         Start_Item (OVS);
         Write_UTF8 (OVS, "null");
      end case;

   end func Write_JSON_Value;

end class PSL::Core::JSON_Output_Value_Stream;

interface PSL::Core::JSON_Input_Value_Stream<>
  extends PSL::Core::Input_Value_Stream<> is
   //  This kind of value stream is used for reading a ParaSail value
   //  from a byte stream in JSON format.

   func Create(ref var Input_Byte_Stream+) -> JSON_Input_Value_Stream;

   func Is_Self_Describing (JSON_Input_Value_Stream) -> Boolean;
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Input_Value_Stream) -> Boolean;

   func Read_Int (var IVS : JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> Val : Univ_Integer
      {Val in Low .. High};

   func Read_Optional_Int
     (var JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> optional Univ_Integer;

   func Read_Float (var JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> Univ_Float;
   func Read_Optional_Float
     (var JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> optional Univ_Float;

   func Read_Rational (var JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> Rational;
   func Read_Optional_Rational
     (var JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> optional Rational;

   func Read_String (var JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> Univ_String;
   func Read_Optional_String
     (var JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> optional Univ_String;

   func Read_Begin_Seq (var JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : Univ_Integer;
   func Read_Begin_Optional_Seq (var JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer;

   func More_Seq_Elements (var JSON_Input_Value_Stream) -> Boolean;
   //  Return #true if there are more sequence elements, and
   //  absorb the comma separator (except for first elemnt which
   //  isn't preceded by one.

   func Read_End_Seq (var JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer;
   //  Absorb end-of-seq indicator and return actual length of sequence.
   //  Return -1 if length not known.
   //  Return null if end-of-seq indicator is missing.

   func Read_Begin_Map (var JSON_Input_Value_Stream);
   func Read_Begin_Optional_Map (var JSON_Input_Value_Stream)
     -> Is_Null : Boolean;

   func More_Map_Elements (var JSON_Input_Value_Stream) -> Boolean;
   //  Return #true if there are more map elements, and
   //  absorb the comma separator (except for first element which
   //  isn't preceded by one).

   func Read_Key_Value_Separator (var JSON_Input_Value_Stream);
   //  Skip over the ':' in a Key/Value pair of a map

   func Read_End_Map (var JSON_Input_Value_Stream) -> Syntax_OK : Boolean;
   //  Absorb end-of-map indicator.
   //  Return #false if end-of-map indicator is missing.

   func Read_Begin_Poly (var JSON_Input_Value_Stream)
     -> Type_Name : Univ_String;
   func Read_Begin_Optional_Poly (var JSON_Input_Value_Stream)
     -> Type_Name : optional Univ_String;
   func Read_End_Poly (var JSON_Input_Value_Stream);

   func Read_Begin_Obj (var JSON_Input_Value_Stream);
   func Read_Begin_Optional_Obj (var JSON_Input_Value_Stream)
     -> Is_Null : Boolean;

   func Read_End_Obj (var JSON_Input_Value_Stream);

   func Read_JSON_Value
     (var IVS : JSON_Input_Value_Stream)
     -> optional JSON_Value+;
   //  Read one JSON value from the JSON-formatted byte stream.
   //  Return null if not good JSON syntax.

   func JSON_Syntax_Error
     (IVS : JSON_Input_Value_Stream; Err : Univ_String := "JSON syntax error");
   //  Give an error message, and indicate line and character
end interface PSL::Core::JSON_Input_Value_Stream;

class PSL::Core::JSON_Input_Value_Stream is
   ref var Byte_Str : Input_Byte_Stream+;
   var Peek_Char : optional Univ_Character := null;
   var End_Reached : Boolean := #false;
   var Source_Line : Integer<0 .. 100_000> := 1;
   var Source_Char : Integer<0 .. 10_000> := 1;

   const Debug : Boolean := #false;

   func Next (var IVS : JSON_Input_Value_Stream) is
      //  Get next decoded character from byte stream
      //  Keep track of line and char within line
      IVS.Peek_Char := UTF::Input::Decode_Char (IVS.Byte_Str);

      if IVS.Peek_Char is null then
         //  Reached end of file
         null;
      elsif IVS.Peek_Char == '\n' then
         IVS.Source_Line += 1;
         IVS.Source_Char := 0;
      else
         IVS.Source_Char += 1;
      end if;
   end func Next;

   func Scan_JSON_Token
     (var IVS : JSON_Input_Value_Stream; Ignore_Comma : Boolean := #false)
     -> optional Univ_String is
      //  Read in one token from input stream, decoding it into a Univ_String
      //  Ignore white space.
      //  IVS.Peek_Char provides a one-character peek-ahead when non-null.
      //  Return null at end of stream

      ref Peek => IVS.Peek_Char;

      func Decode_Hex_Digit (X : optional Univ_Character)
        -> optional Univ_Integer is
         //  Return value in range 0..15 or null, based on hex digit
         if X is null then
            return null;
         end if;
         case X of
          ['0'..'9'] =>
            return X - '0';
          ['a'..'f'] =>
            return X - 'a' + 10;
          ['A'..'F'] =>
            return X - 'A' + 10;
          [..] =>
            return null;
         end case;
      end func Decode_Hex_Digit;

      func Scan_Number () -> optional Univ_String is
      //  Scan a number, append to Result_Vec
      //  Presume IVS.Peek is initialized to first char of number
      //  (either '0'..'9' or '-').
         
         var Result_Vec : Vector<Univ_Character> := [];

         func Scan_Int () -> Boolean is
         //  Scan an integer, append to Result_Vec
         //  Presume IVS.Peek is initialized to first char of number
         //  or null.  Return #true if OK syntax, #false if not
            if Peek is null then
               IVS.Next();
               if Peek is null then
                  IVS.JSON_Syntax_Error ("EOF while reading an integer");
                  return #false;
               end if;
            end if;
            if Peek not in '0' .. '9' then
               IVS.JSON_Syntax_Error ("Expecting a digit");
               return #false;
            end if;
            while Peek in '0' .. '9' loop
               Result_Vec |= Peek;
               IVS.Next();
            end loop;
            // Syntax OK!
            return #true;
         end func Scan_Int;

         if Peek == '-' then
            //  Negative number
            Result_Vec |= Peek;
            IVS.Next();
         end if;

         if not Scan_Int () then
            //  Syntax error
            return null;
         end if;

         if Peek not null and then Peek == '.' then
            //  Fraction part
            Result_Vec |= Peek;
            Peek := null;
            if not Scan_Int () then
               //  Syntax error
               return null;
            end if;
         end if;

         if Peek not null and then Peek in 'e' | 'E' then
            //  Exponent part [E|e][+|-|]<int>
            Result_Vec |= Peek;
            IVS.Next();
            if Peek is null then
               //  Syntax error
               IVS.JSON_Syntax_Error ("EOF while reading an exponent");
               return null;
            end if;
            if Peek in '+' | '-' then
               Result_Vec |= Peek;
               IVS.Next();
               if Peek is null then
                  //  Syntax error
                  IVS.JSON_Syntax_Error ("EOF while reading an exponent");
                  return null;
               end if;
            end if;
            if not Scan_Int () then
               //  Syntax error
               return null;
            end if;
         end if;

         return From_Vector (Result_Vec);
      end func Scan_Number;

      func Scan_String () -> optional Univ_String is
         //  Read in a JSON string
         var Result_Vec : Vector<Univ_Character> := [Peek];

         loop
            IVS.Next();
            if Peek is null then
               //  Syntax error
               IVS.JSON_Syntax_Error ("EOF while reading a string");
               return null;
            elsif Peek == '\n' then
               //  Syntax error
               IVS.JSON_Syntax_Error ("Unterminated string");
               return null;
            elsif Peek == '\\' then
               IVS.Next();
               case Peek of
                ['r'] =>
                  Peek := '\r';
                ['n'] =>
                  Peek := '\n';
                ['t'] =>
                  Peek := '\t';
                ['f'] =>
                  Peek := '\f';
                ['b'] =>
                  Peek := '\b';
                ['u'] =>
                  //  Unicode using 4 hex digits 
                  var U_Val := 0;

                  for I in 1 .. 4 loop
                     IVS.Next();
                     const Dig := Decode_Hex_Digit (Peek);
                     if Dig is null then
                        return null;
                     end if;
                     U_Val := U_Val * 16 + Dig;
                  end loop;
                  Peek := UTF::Nul_Ch + U_Val;

                [..] =>
                  //  Peek not changed
                  null;
               end case;
               Result_Vec |= Peek;
            else
               Result_Vec |= Peek;
               if Peek == '"' then
                  exit loop;
               end if;
            end if;
         end loop;

         if Peek is null then
            //  Bad string
            return null;
         else
            //  Good string.  No peek-ahead left.
            Peek := null;
            return From_Vector (Result_Vec);
         end if;
      end func Scan_String;

      func Scan_Keyword (Keyword : Univ_String)
         -> optional Univ_String is
         for each C of Keyword forward loop
            if Peek is null or else Peek != C then
               return null;
            end if;
            IVS.Next();
         end loop;

         //  Syntax OK (TBD: should we require a separator after a keyword?)
         return Keyword;
      end func Scan_Keyword;

      //////

      if Peek is null then
         IVS.Next();
      end if;

      while Peek not null loop
         case Peek of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;

          ['0'..'9' | '-'] =>
            //  A JSON number
            return Scan_Number ();

          ['"'] =>
            //  A JSON string
            return Scan_String ();

          ['[' | ']' | '{' | '}' | ':' | ','] =>
            //  A separator
            const Result := Peek | "";
            //  No peak-ahead after a separator which means it can
            //  be "pushed back"
            Peek := null;
            if not Ignore_Comma or else Result != "," then
               return Result;
            end if;

          ['t'] =>
            return Scan_Keyword ("true");

          ['f'] =>
            return Scan_Keyword ("false");

          ['n'] =>
            return Scan_Keyword ("null");

          [..] =>
            IVS.JSON_Syntax_Error ("Invalid JSON token");
            //  Skip over bad character
            IVS.Next();
            return null;
         end case;

         //  Advance to next character
         IVS.Next();
      end loop;
   end func Scan_JSON_Token;

 exports

   func Create(ref var Input_Byte_Stream+) -> JSON_Input_Value_Stream is
     ((Byte_Str => Input_Byte_Stream));

   func Is_Self_Describing (JSON_Input_Value_Stream) -> Boolean is (#true);
     //  This means that you can tell what sort of object you
     //  are reading by looking at the content of the byte stream.

   func Reached_End(JSON_Input_Value_Stream) -> Boolean
     is (JSON_Input_Value_Stream.End_Reached);

   func Read_Int (var IVS : JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> Val : Univ_Integer is

      Val := Read_Optional_Int (IVS, Low, High);
      {Val not null}
   end func Read_Int;

   func Read_Optional_Int
     (var IVS : JSON_Input_Value_Stream;
      Low, High : Univ_Integer) -> optional Univ_Integer is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting an integer");
         return null;
      end if;

      case Token[1] of
       ['n'] =>
         //  "null"
         return null;
       ['0' .. '9' | '-'] =>
         //  From_String will return null if not good integer syntax
         return From_String (Token);
       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting '-' or a digit," |
                  " found \"`(Token)\"");
         return null;
      end case;
   end func Read_Optional_Int;

   func Read_Float (var JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> Univ_Float is
      (Read_Optional_Float (JSON_Input_Value_Stream, Digits));

   func Read_Optional_Float
     (var IVS : JSON_Input_Value_Stream;
      Digits : Univ_Integer) -> Result : optional Univ_Float is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a floating-point number");
         return null;
      end if;

      case Token[1] of
       ['n'] =>
         //  "null"
         return null;
       ['0' .. '9' | '-'] =>
         //  From_String will return null if not good numerical syntax
         return From_String (Token);
       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a floating-point number");
         return null;
      end case;
   end func Read_Optional_Float;

   func Read_Rational (var IVS : JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> Rational
     is (Read_Optional_Rational (IVS, Digits));

   func Read_Optional_Rational
     (var IVS : JSON_Input_Value_Stream;
      Digits : Univ_Integer := -1) -> optional Rational is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON number");
         return null;
      end if;

      case Token[1] of
       ['n'] =>
         //  "null"
         return null;
       ['0' .. '9' | '-'] =>
         //  From_String will return null if not good numerical syntax
         return From_String (Token);
       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON number");
         return null;
      end case;
   end func Read_Optional_Rational;

   func Read_String (var IVS : JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> Univ_String is
      return Read_Optional_String (IVS, Max_Char, Min_Len, Max_Len);
   end func Read_String;
      
   func Read_Optional_String
     (var IVS : JSON_Input_Value_Stream;
      Max_Char : Univ_Character; Min_Len, Max_Len : Univ_Integer)
     -> optional Univ_String is
      
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token == "" then
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON string");
         return null;
      end if;

      case Token[1] of
       ['"'] =>
         //  Strip off the double quotes
         return Token[2 .. |Token|-1];

       ['n'] =>
         //  "null"
         return null;

       [..] =>
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting a JSON string");
         return null;
      end case;
   end func Read_Optional_String;

   func Read_Begin_Seq (var IVS : JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : Univ_Integer is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token != "[" then
         {#false}
         return 0;
      end if;

      //  Always variable length
      return -1;
   end func Read_Begin_Seq;

   func Read_Begin_Optional_Seq (var IVS : JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null then
         IVS.JSON_Syntax_Error ("Expecting a JSON array");
         return 0;
      elsif Token == "null" then
         return null;
      elsif Token == "[" then
         //  Always variable length
         return -1;
      else
         IVS.JSON_Syntax_Error ("Expecting a JSON array");
         return 0;
      end if;
   end func Read_Begin_Optional_Seq;

   func More_Seq_Elements (var IVS : JSON_Input_Value_Stream) -> Boolean is
      if IVS.Peek_Char is null then
         //  Peek ahead
         IVS.Next();
      end if;

      while IVS.Peek_Char not null loop
         case IVS.Peek_Char of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;
          [']'] =>
            //  End of sequence
            return #false;
          [','] =>
            //  Absorb the comma and return #true.
            IVS.Peek_Char := null;
            return #true;
          [..] =>
            //  Anything might come immediately after a '['
            return #true;
         end case;
         //  Get next character
         IVS.Next();
      end loop;
      //  End of stream
      return #false;
   end func More_Seq_Elements;

   func Read_End_Seq (var IVS : JSON_Input_Value_Stream;
      Min_Len, Max_Len : Univ_Integer) -> Actual_Len : optional Univ_Integer is
   //  Absorb end-of-seq indicator and return actual length of sequence.
   //  Return -1 if length not known.
   //  Return null if end-of-seq indicator is missing.
      const Token := Scan_JSON_Token (IVS);
      if Token not null and then Token == "]" then
         return -1;
      else
         IVS.JSON_Syntax_Error ("Missing final ']' for JSON array");
         return null;
      end if;
   end func Read_End_Seq;

   func Read_Begin_Map (var IVS : JSON_Input_Value_Stream) is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token != "{" then
         IVS.JSON_Syntax_Error ("Expecting JSON Object");
      end if;
   end func Read_Begin_Map;

   func Read_Begin_Optional_Map (var IVS : JSON_Input_Value_Stream)
     -> Is_Null : Boolean is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null then
         IVS.JSON_Syntax_Error ("Expecting JSON Object");
         return #true;
      elsif Token == "null" then
         return #true;
      elsif Token == "{" then
         return #false;
      else
         IVS.JSON_Syntax_Error ("Expecting JSON Object");
         return #true;
      end if;
   end func Read_Begin_Optional_Map;

   func More_Map_Elements (var IVS : JSON_Input_Value_Stream) -> Boolean is
      if IVS.Peek_Char is null then
         //  Peek ahead
         IVS.Next();
      end if;

      while IVS.Peek_Char not null loop
         case IVS.Peek_Char of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;
          ['}'] =>
            //  End of object
            return #false;
          [','] =>
            //  Absorb the comma and return #true.
            IVS.Peek_Char := null;
            return #true;
          [..] =>
            //  Anything might come immediately after a '{'
            return #true;
         end case;
         //  Get next character
         IVS.Next();
      end loop;
      //  End of stream
      return #false;
   end func More_Map_Elements;

   func Read_Key_Value_Separator (var IVS : JSON_Input_Value_Stream) is
   //  Skip over the ':' in a Key/Value pair of a map
      const Token := Scan_JSON_Token (IVS);
      if Token is null or else Token != ":" then
         IVS.JSON_Syntax_Error ("Expecting ':'");
      end if;
   end func Read_Key_Value_Separator;

   func Read_End_Map (var IVS : JSON_Input_Value_Stream)
     -> Syntax_OK : Boolean is
   //  Absorb end-of-map indicator.
   //  Return #false if end-of-map indicator is missing.
      const Token := Scan_JSON_Token (IVS);

      if Token not null and then Token == "}" then
         Syntax_OK := #true;
      else
         //  Syntax error
         IVS.JSON_Syntax_Error ("Expecting '}'");
         Syntax_OK := #false;
      end if;
   end func Read_End_Map;

   func Read_Begin_Poly (var JSON_Input_Value_Stream)
     -> Type_Name : Univ_String
      is ("");  --  TBD
   func Read_Begin_Optional_Poly (var JSON_Input_Value_Stream)
     -> Type_Name : optional Univ_String
      is (null);  --  TBD
   func Read_End_Poly (var JSON_Input_Value_Stream)
      is (null);  --  TBD

   func Read_Begin_Obj (var IVS : JSON_Input_Value_Stream) is
      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null or else Token != "[" then
         {#false}
         return;
      end if;
   end func Read_Begin_Obj;

   func Read_Begin_Optional_Obj (var IVS : JSON_Input_Value_Stream)
     -> Is_Null : Boolean is

      const Token := Scan_JSON_Token (IVS, Ignore_Comma => #true);

      if Token is null then
         {#false}
         return #true;

      elsif Token == "null" then
         return #true;

      elsif Token == "[" then
         return #false;

      else
         if Debug then
            Println("Expecting '[' or 'null' but found '`(Token)'");
         end if;
         {#false}
         return #true;
      end if;
      
   end func Read_Begin_Optional_Obj;

   func Read_End_Obj (var IVS : JSON_Input_Value_Stream) is 
      const Token := Scan_JSON_Token (IVS);
      {Token not null and then Token == "]"}
   end func Read_End_Obj;

   func Read_JSON_Value
     (var IVS : JSON_Input_Value_Stream)
     -> Result : optional JSON_Value+ is
   //  Read one JSON value from the JSON-formatted byte stream.
   //  Return null if not good JSON syntax.
      if IVS.Peek_Char is null then
         //  Peek ahead
         IVS.Next();
      end if;

      while IVS.Peek_Char not null loop
         case IVS.Peek_Char of
          [' ' | '\t' | '\n' | '\r'] =>
            //  Ignore white space; stay in loop
            null;

          ['{'] =>
            //  JSON Object
            if Debug then
               Println("Reading a JSON object");
            end if;
            var Obj : JSON_Object_Value for Result := Create();

            Read_Begin_Map (IVS);
            while More_Map_Elements (IVS) loop
               const Key :=
                 Read_Optional_String (IVS, Univ_Character::Last(),
                   Min_Len => 0, Max_Len => 10_000);

               if Key is null then
                  IVS.JSON_Syntax_Error ("Expecting JSON string for Key");
                  return null;
               end if;

               Read_Key_Value_Separator (IVS);

               Obj.Value[Key] := Read_JSON_Value (IVS);
            end loop;
            if Debug then
               Println("JSON Map is `(|Obj.Value|) in length");
            end if;
            if Read_End_Map (IVS) then
               return Obj;
            else
               //  Syntax error
               return null;
            end if;

          ['['] =>
            //  JSON Array
            if Debug then
               Println("Reading a JSON array");
            end if;
            var Arr : JSON_Array_Value for Result := Create();

            const Ignore_Len :=
              Read_Begin_Seq (IVS, Min_Len => 0, Max_Len => 2**15);
            while More_Seq_Elements (IVS) loop
               var Val for Arr := Read_JSON_Value (IVS);
               Arr.Value <|= Val;
            end loop;

            const Act_Len :=
              Read_End_Seq (IVS, Min_Len => 0, Max_Len => 2**15);

            if Debug then
               Println("JSON array is `(|Arr.Value|) in length");
            end if;

            if Act_Len < 0 or else Act_Len == |Arr.Value| then
               return Arr;
            else
               //  Syntax error
               IVS.JSON_Syntax_Error ("Syntax error in JSON array");
               return null;
            end if;

          ['"'] =>
            //  JSON String
            if Debug then
               Println("Reading a JSON string");
            end if;
            const Str := Read_Optional_String
              (IVS, Univ_Character::Last(), Min_Len => 0, Max_Len => 10_000);
               //  Will return "null" on a syntax error

            if Str not null then
               return JSON_String_Value::Create (Str);
            else
               return null;
            end if;

          ['0' .. '9' | '-'] =>
            //  JSON number
            if Debug then
               Println("Reading a JSON number");
            end if;
            const Num := Read_Optional_Rational (IVS);
               //  Will return "null" on a syntax error

            if Num not null then
               return JSON_Number_Value::Create (Num);
            else
               return null;
            end if;

          ['t' | 'f'] =>
            //  JSON Boolean value
            if Debug then
               Println("Reading a JSON bool");
            end if;
            const Token := Scan_JSON_Token (IVS);
            
            if Debug then
               Println("bool token is `(Token)");
            end if;
            if Token not null then
               if Token == "true" then
                  return JSON_Boolean_Value::Create(#true);
               elsif Token == "false" then
                  return JSON_Boolean_Value::Create(#false);
               end if;
            end if;
            //  Syntax error
            IVS.JSON_Syntax_Error ("Expecting 'true' or 'false'");
            return null;

          ['n'] =>
            //  JSON Null value
            if Debug then
               Println("Reading a JSON null");
            end if;
            const Token := Scan_JSON_Token (IVS);
            
            if Token not null and then Token == "null" then
               return JSON_Value::Create(#Null_Value);
            else
               //  Syntax error
               IVS.JSON_Syntax_Error ("Expecting 'null'");
               return null;
            end if;

          [..] =>
            //  Anything else is unexpected
            //  Read and discard the token
            const Token := Scan_JSON_Token (IVS);

            IVS.JSON_Syntax_Error
              ("Unexpected token in JSON stream: \"`(Token)\"");
            return null;
         end case;
         //  Get next character
         IVS.Next();
      end loop;
      //  End of stream
      return null;
   end func Read_JSON_Value;

   func JSON_Syntax_Error
     (IVS : JSON_Input_Value_Stream; Err : Univ_String := "JSON syntax error")
   //  Give an error message, and indicate line and character
   is
      Println ("`(IVS.Source_Line):`(IVS.Source_Char): `(Err)");
   end func JSON_Syntax_Error;

end class PSL::Core::JSON_Input_Value_Stream;

func PSL::Test::Test_JSON_Stream() is

   var IO := IO::Get_IO();
   var B_File : Byte_Stream_Output_File := IO.Create ("json_test.json");

   ref var OVS : JSON_Output_Value_Stream => Create(B_File);

   ref var OOS : Output_Object_Stream => Create(OVS);

   var Next_Val_Out := 1111;
   var Next_Val_In := 1111;

   func Next_Out() -> Univ_Integer is
   //  Return a unique value
      Next_Val_Out := Next_Val_Out + 123;
      return Next_Val_Out;
   end func Next_Out;

   func Next_In() -> Univ_Integer is
   //  Return a unique value
      Next_Val_In := Next_Val_In + 123;
      return Next_Val_In;
   end func Next_In;

   Println ("Testing Read/Write_Optional_Object with a JSON value stream");
   Println (" output in json_test.json");

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Obj (OOS, Univ_Integer::(null));
      else
         Write_Optional_Obj (OOS, I**3);
      end if;
        
   end loop;

   Println ("Testing write sets rather than integers");

   type Int_Set is Set<Integer>;

   func Img(II : Int_Set) -> Univ_String is
      return "[" | (for (I : Integer in II; Sep := "" then ",") =>
                 <""> | Sep | To_String (I)) | "]";
   end func Img;

   for I in 1 .. 7 forward loop
      if I == 3 then
         Write_Optional_Obj (OOS, Int_Set::(null));
      else
         var Test_Set : Int_Set := [for J in 1 .. I => Next_Out()];

         Write_Optional_Obj (OOS, Test_Set);
      end if;
        
   end loop;

   B_File.Close();

   //  Read back in

   var I_File : Byte_Stream_Input_File := IO.Open ("json_test.json");
   ref var IVS : JSON_Input_Value_Stream => Create(I_File);
   ref var IOS : Input_Object_Stream => Create(IVS);

   Println ("About to read in 7 (optional) Integers");

   for I in 1 .. 7 forward loop
      var Z : Univ_Integer;
      // Read_Optional_Obj (IOS, Z);
      Z := Read_Optional_Int (IVS, 0, High => 7**3);
      if I == 3 then
         if Z not null then
            Println ("Expected null but found `(Z)");
         end if;
      else
         if Z != I**3 then
            Println ("Expected `(I**3) but found `(Z)");
         end if;
      end if;
      // Println
      //   ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   Println ("Successful read of 7 optional integers");
   
   Println ("About to read in 7 (optional) Integer sets");
   for I in 1 .. 7 forward loop
      // Println ("Bytes_To_Read = `(Buf.Bytes_To_Read())");
      Println ("Reading set `(I)");
      const Expected : optional Int_Set :=
        (if I == 3 then null else [for J in 1 .. I => Next_In()]);

      if Expected is null then
         Println ("Expecting null");
      else

         Println ("Expecting `(Img(Expected))");
      end if;

      var Z : Int_Set;
      Read_Optional_Obj (IOS, Z);
      if Expected is null then
         if Z not null then
            Println ("Expected null but found `(Img(Z))");
         end if;
      else
         if Z != Expected then
            Println ("Expected `(Img(Expected)) but found `(Img(Z))");
         end if;
      end if;
      // Println
      //   ("after read, Bytes_To_Write = `(Buf.Bytes_To_Write())");
   end loop;

   I_File.Close();
   Println ("All done");
end func PSL::Test::Test_JSON_Stream;

func PSL::Test::Test_JSON_Value_IO (From, To : Univ_String) is
   
   var IO := IO::Get_IO();

   var I_File : Byte_Stream_Input_File := IO.Open (From);

   if I_File is null then
      Println("Cannot open `(From)");
      return;
   end if;

   ref var IVS : JSON_Input_Value_Stream => Create(I_File);

   Println ("About to read JSON file \"`(From)\"");
   const JSON_Val := Read_JSON_Value (IVS);

   Println ("Done reading in JSON file");

   if JSON_Val is null then
      IVS.JSON_Syntax_Error ("JSON File `(From) has a syntax error");
      I_File.Close();
      return;
   end if;

   I_File.Close();

   Println ("About to write value back out to file \"`(To)\"");
   var O_File : Byte_Stream_Output_File := IO.Create (To);
   if O_File is null then
      Println("Cannot create file `(To)");
      return;
   end if;

   ref var OVS : JSON_Output_Value_Stream => Create(O_File);

   Write_JSON_Value (OVS, JSON_Val);
   Println ("Done writing to JSON file");
   O_File.Close();

end func PSL::Test::Test_JSON_Value_IO;
