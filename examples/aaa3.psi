
abstract interface PSL::Core::Sequence<Element_Type is Assignable<>> is
    func Remove_First(var S : Sequence) -> optional Element_Type
      // Returns null when sequence is empty
end interface PSL::Core::Sequence

interface PSL::Core::Direction<> is
    // This is passed to the "to_sequence" operator to generate
    // appropriate direction of sequence
    op "from_univ"(Lit : Univ_Enumeration)
      {Lit in #unordered | #forward | #reverse | #concurrent} -> Direction 
      is import(#direction_from_univ)

    op "to_univ"(Val : Direction) -> Univ_Enumeration 
      is import(#direction_to_univ)

    op "=?"(Left, Right : Direction) -> Ordering
      is import("=?")
end interface PSL::Core::Direction

interface PSL::Core::Integer
  <Range : Countable_Range<Univ_Integer> := -2**62 .. +2**62> is
    // NOTE: We restrict Integer to this range so Univ_Integer can use
    //       values outside this range as indices into an extended-range
    //       integer table.
    op "from_univ"(Lit : Univ_Integer) -> Integer 
      is import(#integer_from_univ)

    op "to_univ"(Val : Integer) -> Univ_Integer 
      is import(#integer_to_univ)

    op "+"(Right : Integer) -> Integer
      is import(#identity)

    op "-"(Right : Integer) -> Integer
      is import(#negate)

    op "abs"(Right : Integer) -> Integer
      is import("abs")

    op "magnitude"(Integer) -> Integer is "abs"

    op "+"(Left, Right : Integer) -> Result : Integer 
      is import("+")

    op "-"(Left, Right : Integer) -> Result : Integer
      is import("-")

    op "*"(Left, Right : Integer) -> Result : Integer 
      is import("*")

    op "/"(Left, Right : Integer) -> Result : Integer
      is import("/")

    op "mod"(Left, Right : Integer) -> Integer
      is import("mod")

    op "rem"(Left, Right : Integer) -> Integer
      is import("rem")

    op "**"(Left, Right : Integer) -> Result : Integer
      is import("**")

    op "+="(var Left : Integer; Right : Integer) 
      is import("+=")

    op "-="(var Left : Integer; Right : Integer) 
      is import("-=")

    op "*="(var Left : Integer; Right : Integer) 
      is import("*=")

    op "/="(var Left : Integer; Right : Integer) 
      is import("/=")

    op "**="(var Left : Integer; Right : Integer) 
      is import("**=")

    op "=?"(Left, Right : Integer) -> Ordering
      is import("=?")

    op ">>"(Integer; Integer) -> Integer is import(">>")

    op "<<"(Integer; Integer) -> Integer is import("<<")

    func Min(Left, Right : optional Integer) -> optional Integer
      is import(#min)
    func Max(Left, Right : optional Integer) -> optional Integer
      is import(#max)

    func Hash(Val : Integer) -> Univ_Integer
      is import(#identity)

    func To_String(Val : Integer) -> Univ_String
      is import(#to_string_int)

    func From_String(Str : Univ_String) -> optional Integer
      is import(#from_string_int)

    func Print(X : Integer) is import(#print_int)
    func Println(X : Integer) is (Println(To_String(X)))

    func First() -> Integer

    func Last() -> Integer

    op "[..]"()->Countable_Range<Integer> is in Countable_Range<Integer>

    op ".."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "<.."(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "<..<"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
    op "|"(Left, Right : Integer) -> Countable_Set<Integer>
      is in Countable_Set<Integer>
  implements for Countable
    // These operations are needed so Integer satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an integer to an int-literal).

    op "+"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("+")

    op "+"(Left : Univ_Integer; Right : Integer) -> Result : Integer 
      is import("+")

    op "-"(Left : Integer; Right : Univ_Integer) -> Result : Integer 
      is import("-")

    op "-"(Left, Right : Integer) -> Result : Univ_Integer
      is import("-")

end interface PSL::Core::Integer

class PSL::Core::Integer is
    const Content : Univ_Integer;  // So this ends up as a wrapper
  exports
    func First() -> Integer is
	return Range.First
    end func First

    func Last() -> Integer is
	return Range.Last
    end func Last

end class PSL::Core::Integer
    
class PSL::Core::Boolean is
  exports
    op "and="(var Left : Boolean; Right : Boolean) is
	Left := Left and Right
    end op "and="

    op "or="(var Left : Boolean; Right : Boolean) is
	Left := Left or Right
    end op "or="

    op "xor="(var Left : Boolean; Right : Boolean) is
	Left := Left xor Right
    end op "xor="

    func To_String(Val : optional Boolean) -> Univ_String is
	if Val is null then
            return "null"
        elsif Val then
	    return "#true"
	else
	    return "#false"
	end if
    end func To_String

    func From_String(Str : Univ_String) -> optional Boolean is
	if Str == "#true" then
	    return #true
	elsif Str == "#false" then
	    return #false
	else
	    return null
	end if
    end func From_String

end class PSL::Core::Boolean

func PSL::Test::Test_Boolean(UX, UY : Univ_Enumeration) is
    const X : Boolean := UX
    const Y : Boolean := UY

    Println(X | " and " | Y | " = " | (X and Y))
    Println(X | " or " | Y | " = " | (X or Y))
    Println(X | " xor " | Y | " = " | (X xor Y))

    var XX := X
    XX and= Y
    Println(X | " and= " | Y | " = " | XX)
    XX := X
    XX or= Y
    Println(X | " or= " | Y | " = " | XX)
    XX := X
    XX xor= Y
    Println(X | " xor= " | Y | " = " | XX)
end func PSL::Test::Test_Boolean

interface PSL::Core::List<List_Elem is Assignable<>> is
    var Elem : List_Elem
    var Next : optional List

    op "|"(Left : List_Elem; Right : List_Elem) -> List
    op "|"(Left : List_Elem; Right : List) -> List
    op "|"(Left : List; Right : List) -> List
    op "|"(Left : List; Right : List_Elem) -> List

    op "|="(var Left : List; Right : List)
    op "|="(var Left : List; Right : List_Elem)
    func Length(L : optional List) -> Univ_Integer
    op "magnitude"(L : optional List) -> Univ_Integer is Length

    op "[]"() -> optional List is (null)

    func Remove_First(var L : List) -> optional List_Elem
    func Remove_Last(var L : List) -> optional List_Elem
    func Remove_Any(var L : List) -> optional List_Elem
end interface PSL::Core::List

class PSL::Core::List is
  exports
    op "|"(Left : List_Elem; Right : List_Elem) -> List is
        return (Elem => Left, Next => (Elem => Right, Next => null))
    end op "|"

    op "|"(Left : List_Elem; Right : List) -> List is
        return (Elem => Left, Next => Right)
    end op "|"

    op "|"(Left : List; Right : List) -> List is
        if Left is null then
            // Left is null, so just return Right
            return Right
        else
            // Recurse with tail of left Basic_list
            return (Elem => Left.Elem, Next => Left.Next | Right)
        end if
    end op "|"

    op "|"(Left : List; Right : List_Elem) -> List is
        return Left | (Elem => Right, Next => null)
    end op "|"

    op "|="(var Left : List; Right : List) is
        if Left is null then
            Left := Right
        else
            // Recurse with tail of Basic_list
            Left.Next |= Right
        end if
    end op "|="

    op "|="(var Left : List; Right : List_Elem) is
        // Just pass the buck
        Left |= (Elem => Right, Next => null)
    end op "|="

    func Length(L : optional List) -> Result : Univ_Integer is
        Result := 0
        for Lst := L then Lst.Next while Lst not null loop
            Result += 1
        end loop
    end func Length

    func Remove_First(var L : List) 
      -> Result : optional List_Elem is
        if L is null then
            return null
        else
            Result := L.Elem
            L <== L.Next
              // carve off L.Next and set L to that
        end if
    end func Remove_First

    func Remove_Last(var L : List) 
      -> Result : optional List_Elem is
        if L is null then
            return null
        elsif L.Next is null then
            Result := L.Elem
            L := null
        else
            // Recurse to remove last element
            return Remove_Last(L.Next)
        end if
    end func Remove_Last

    func Remove_Any(var L : List) 
      -> Result : optional List_Elem is
        // Easiest to remove first element
        return Remove_First(L)
    end func Remove_Any

end class PSL::Core::List


func PSL::Test::Test_List(X, Y : Univ_Integer) is
    type Univ_List is List<Univ_Integer>

    func Println(L : Univ_List) is
        // Print a univ Basic_list
        var N := L
        while N not null loop
            const E : Univ_Integer := N.Elem
            Print(E)
            N := N.Next
            if N not null then
                Print(", ")
            end if
        end loop

        Print("\n")
    end func Println

    func Println_It(L : Univ_List) is
        // Print a univ Basic_list using destructive iterator
        Print("Forward: ")
        var F := L
        while F not null loop
            const E : Univ_Integer := Remove_First(F)
            Print(E)
            if F not null then
                Print(", ")
            end if
        end loop

        Print("\n")

        Print("Reverse: ")
        var R := L
        while R not null loop
            const Z : Univ_Integer := Remove_Last(R)
            Print(Z)
            if R not null then
                Print(", ")
            end if
        end loop

        Print("\n")
    end func Println_It

    var L1 : Univ_List := (Elem => X, Next => null)
    var L2 : Univ_List := (Elem => Y, Next => null)
    var L3 := L1 | L2

    Print("X = "); Println(X)
    Print("Y = "); Println(Y)
    Println("Combining " | X | " and " | Y | " produces ")
    Println(L3)
    Println("Combining X | Y | X | X | Y | Y produces ")
    Println_It(L3 | X | L3 | Y)
end func PSL::Test::Test_List

interface PSL::Core::Closed_Interval<Bound_Type is Comparable<>> is
    // This provides a simple "closed" interval X..Y
    // If a type is countable, then half-open or fully open intervals
    // can be converted into the equivalent closed interval.
    var Low : Bound_Type
    var High : Bound_Type
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean
    op "=?"(Left, Right : Closed_Interval) -> Ordering
end interface PSL::Core::Closed_Interval

class PSL::Core::Closed_Interval is
  exports
    op "in"(Left : Bound_Type; Right : Closed_Interval) -> Boolean is
        return Left >= Right.Low and then Left <= Right.High
    end op "in"

    op "=?"(Left, Right : Closed_Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.

        if Left.High < Right.Low then
            return #less
        elsif Left.Low > Right.High then
            return #greater
        elsif Left.Low == Right.Low and then
          Left.High == Right.High then
            return #equal
        else
            return #unordered
        end if
    end op "=?"
end class PSL::Core::Closed_Interval

interface PSL::Core::Interval<Bound_Type is Comparable<>> is
    // This supports closed, half-open, and open intervals.
    // This is appropriate for uncountable types where you
    // can't normalize all intervals into closed intervals.
    var Low : Bound_Type
    var Low_Is_Open : Boolean
    var High : Bound_Type
    var High_Is_Open : Boolean

    func Singleton(Val : Bound_Type) -> Interval
      // Return interval consisting of a single value

    func Is_Empty(IV : optional Interval) -> Boolean
      // Return True if interval is null or it represents
      // no values

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean

    op "=?"(Left, Right : Interval) -> Ordering
      // "#greater" means Left is strictly greater than Right
      // "#less" means Left is strictly less than Right
      // "#equal" means Left and Right are the same interval
      // "#unordered" means anything else

    op "and"(Left, Right : Interval) -> optional Interval
      // Return intersection of the two intervals

    op "and="(var Left : optional Interval; Right : Interval)
      // Intersect Right into Left

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> optional Interval
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)}
      // Subtract Right interval from Left

    func Overlaps(Left, Right : optional Interval) -> Boolean
      // Return True if intervals overlap

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|"(Left, Right : Interval) {Overlaps(Left, Right)} -> Interval is "or"

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)}
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
    op "|="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is "or="

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)}
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.

end interface PSL::Core::Interval

class PSL::Core::Interval is
  exports
    func Singleton(Val : Bound_Type) -> Interval is
      // Return interval consisting of a single value
	return (Low => Val, Low_Is_Open => #false,
	  High => Val, High_Is_Open => #false)
    end func Singleton

    func Is_Empty(IV : optional Interval) -> Boolean is
      // Return True if interval is null or it represents
      // no values
	return IV is null or else
	  IV.Low > IV.High or else
	  (IV.Low == IV.High and then (IV.Low_Is_Open or IV.High_Is_Open))
    end func Is_Empty

    op "in"(Left : Bound_Type; Right : Interval) -> Boolean is
        case Left =? Right.Low of
          [#less] => return #false
          [#equal] => return not Right.Low_Is_Open
          [#greater] =>
            case Left =? Right.High of
              [#less] => return #true
              [#equal] => return not Right.High_Is_Open
              [#greater] => return #false
            end case
        end case
    end op "in"

    op "=?"(Left, Right : Interval) -> Ordering is
        // Compare two intervals, and consider them #unordered
        // if they overlap at all, unless they are identical.
        // If they don't overlap, then return #less or #greater as appropriate.
        // Return #unordered if any of the comparisons return #unordered.

        // First check for perfect equality
        if Left.Low == Right.Low and then
          Left.High == Right.High and then
          Left.Low_Is_Open == Right.Low_Is_Open and then
          Left.High_Is_Open == Right.High_Is_Open then
            // NOTE: We are considering X..Y-1 != X..<Y since
            //       we don't require countable elements.
            return #equal
        end if

        case Left.High =? Right.Low of
          [#unordered] =>
            return #unordered
          [#less] =>
            return #less
          [#equal] =>
            if Left.High_Is_Open or else Right.Low_Is_Open then
                // No overlap
                return #less
            else
                // We have already ruled out #equal
                return #unordered
            end if
          [#greater] =>
            // Not clearly less, see whether clearly greater.
            case Left.Low =? Right.High of
              [#unordered] =>
                return #unordered
              [#less] =>
                // We have already ruled out #equal
                return #unordered
              [#equal] =>
                if Left.Low_Is_Open or else Right.High_Is_Open then
                    // No overlap
                    return #greater
                else
                    // We have already ruled out #equal
                    return #unordered
                end if
              [#greater] =>
                return #greater
            end case
        end case
    end op "=?"

    op "and"(Left, Right : Interval) -> optional Interval is
      // Return intersection of the two intervals
	var New_Low : Bound_Type
	var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
	var New_High_Is_Open : Boolean
	
	case Left.Low =? Right.Low of
	  [#less] => 
	    New_Low := Right.Low
	    New_Low_Is_Open := Right.Low_Is_Open
	  [#greater] => 
	    New_Low := Left.Low
	    New_Low_Is_Open := Left.Low_Is_Open
	  [#equal] => 
	    New_Low := Left.Low
	    New_Low_Is_Open := Left.Low_Is_Open or Right.Low_Is_Open
	  [#unordered] => 
	    return null
	end case

	case Left.High =? Right.High of
	  [#less] => 
	    New_High := Left.High
	    New_High_Is_Open := Left.High_Is_Open
	  [#greater] => 
	    New_High := Right.High
	    New_High_Is_Open := Right.High_Is_Open
	  [#equal] => 
	    New_High := Left.High
	    New_High_Is_Open := Left.High_Is_Open or Right.High_Is_Open
	  [#unordered] => 
	    return null
	end case

	return (Low => New_Low, Low_Is_Open => New_Low_Is_Open,
	  High => New_High, High_Is_Open => New_High_Is_Open)
    end op "and"

    op "and="(var Left : optional Interval; Right : Interval) is
      // Intersect Right into Left
	if Left not null then
	    Left := Left and Right
	end if
    end op "and="

    func Is_Strictly_Within(Left, Right : optional Interval) -> Boolean is
      // Return #true if Left is strictly within Right,
      // meaning low bound of Left is higher, and high bound is lower.
      // NOTE: If #true, then removing Right from Left will produce two 
      //       non-overlapping intervals.
	if Right is null or else Left is null then
	    return #false
	end if
	return (Left.Low > Right.Low or else 
	  (Left.Low == Right.Low and then Left.Low_Is_Open > Right.Low_Is_Open))
	  and then
	    (Left.High < Right.High or else
	     (Left.High == Right.High and then 
	      Left.High_Is_Open > Right.High_Is_Open))
    end func Is_Strictly_Within

    op "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      -> Result : optional Interval is
      // Subtract out Right interval from Left interval
      // Right must not be strictly within Left, since
      // that would require returning two intervals.
	var New_Low : Bound_Type
	var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
	var New_High_Is_Open : Boolean
	
	case Left.Low =? Right.Low of
	  [#less] => 
	    // Return left part of Left
	    Result := (Low => Left.Low, Low_Is_Open => Left.Low_Is_Open,
	      High => Right.Low, High_Is_Open => not Right.Low_Is_Open)
	  [#greater] => 
	    // Return right part of Left
	    Result := (Low => Right.High, Low_Is_Open => not Right.High_Is_Open,
	      High => Left.High, High_Is_Open => Left.High_Is_Open)
	  [#equal] => 
	    if Left.Low_Is_Open >= Right.Low_Is_Open then
		// Return right part of Left
		Result := (Low => Right.High, 
		  Low_Is_Open => not Right.High_Is_Open,
		  High => Left.High, 
		  High_Is_Open => Left.High_Is_Open)
	    else
		// Only one element is left
		return (Left.Low, #false, Left.Low, #false)
	    end if
	  [#unordered] => 
	    return null
	end case

	if Result.Low > Result.High then
	    // Empty interval
	    return null
	elsif Result.Low == Result.High and then
	  (Result.Low_Is_Open or Result.High_Is_Open) then
	    // Empty interval
	    return null
	else
	    return Result
	end if
    end op "-"

    op "-="(var Left : optional Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)} is
      // Subtract Right interval from Left
	if Left not null then
	    Left := Left - Right
	end if
    end op "-="

    func Overlaps(Left, Right : optional Interval) -> Boolean is
	if Left is null or else Right is null then
	    return #false
	else
	    case Left =? Right of
	      [#equal | #unordered] => return #true
	      [#less | #greater] => return #false
	    end case
	end if
    end func Overlaps

    op "or"(Left, Right : Interval) {Overlaps(Left, Right)} 
      -> Result : Interval is
      // Return union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
	
	Result := Left
	Result or= Right
    end op "or"

    op "or="(var Left : optional Interval; Right : Interval) 
      {Overlaps(Left, Right)} is
      // Compute union of two intervals.  Must have some overlap
      // to ensure that result can be represented as a single interval.
	var Right_Copy for Left := Right
	Left <|= Right_Copy
    end op "or="

    op "<|="(var Left, Right : optional Interval) {Overlaps(Left, Right)} is
      // Compute union of two intervals; leave Right empty.  
      // Must have some overlap to ensure that result can be 
      // represented as a single interval.
	if Left is null then
	    Left <== Right
	elsif Right not null then
	    var Right_Copy <== Right
		// Make copy and null out Right, so
		// we don't end up with Right partially nulled out
	    
	    case Left.Low =? Right_Copy.Low of
	      [#less] => 
		// No change to Left.Low
		null
	      [#greater] => 
		Left.Low <== Right_Copy.Low
		Left.Low_Is_Open := Right_Copy.Low_Is_Open
	      [#equal] => 
		Left.Low_Is_Open and= Right_Copy.Low_Is_Open
	    end case

	    case Left.High =? Right_Copy.High of
	      [#less] => 
		Left.High <== Right_Copy.High
		Left.High_Is_Open := Right_Copy.High_Is_Open
	      [#greater] => 
		// No change to Left.High
		null
	      [#equal] => 
		Left.High_Is_Open and= Right_Copy.High_Is_Open
	    end case
	end if
    end op "<|="

end class PSL::Core::Interval

func PSL::Test::Test_Interval(X, Y, Z : Univ_Integer) is
    var Y_Up_To_Z : Interval<Univ_Integer> := 
      (Low => Y, Low_Is_Open => #false, High => Z, High_Is_Open => #true)

    Println(X | " in " | Y | "..<" | Z | " = " | (X in Y_Up_To_Z))

    var Y_To_Z : Closed_Interval<Univ_Integer> := (Low => Y, High => Z)

    Println(X | " in " | Y | ".." | Z | " = " | (X in Y_To_Z))

    var One_To_X : Closed_Interval<Univ_Integer> :=
      (Low => 1, High => X)

    Println(1 | ".." | X | "=?" | Y | ".." | Z | " = " | 
      (One_To_X =? Y_To_Z))

end func PSL::Test::Test_Interval

interface PSL::Core::AA_Tree<Element is Comparable<>> is

    // This module implements a balanced "AA" tree, originally
    // described by Arne Andersson in the "Proceedings of the Workshop
    // on Algorithms and Data Structures," pp 60-71, Springer Verlag, 1993.
    // The following algorithm and descriptions were taken from the
    // WikiPedia article on AA_Tree: 
    //       http://en.wikipedia.org/wiki/AA_tree
    // Note that various additional checks for a null tree have been added.

    // Only two operations are needed for maintaining balance in an AA tree.
    // These operations are called skew and split. Skew is a right rotation
    // when an insertion or deletion creates a left horizontal link. Split
    // is a conditional left rotation when an insertion or deletion creates two
    // horizontal right links, which once again corresponds to two
    // consecutive red links in red-black trees.

    op "[]"() -> optional AA_Tree
        // Create an empty tree

    func Insert(var T : optional AA_Tree; X : Element)
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

    func Delete(var T : optional AA_Tree; X : Element)
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

    op "in"(X : Element; T : optional AA_Tree) -> Boolean

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.

    op "|="(var T : optional AA_Tree; X : Element) is Insert

    op "<|="(var T : optional AA_Tree; var X : optional Element)
	// Move X into AA_Tree, leaving X null.

    func First(T : optional AA_Tree) -> optional Element
      // Return first (smallest) element in tree

    func Last(T : optional AA_Tree) -> optional Element
      // Return last (greatest) element in tree

    func Remove_First(var T : optional AA_Tree) -> optional Element
      // Remove first (smallest) element in tree

    func Remove_Last(var T : optional AA_Tree) -> optional Element
      // Remove last (greatest) element in tree

    func Remove_Any(var T : optional AA_Tree) -> optional Element
      // Remove some element from tree

    func Count(T : optional AA_Tree) -> Univ_Integer
      // Return a count of the nodes in the tree

    op "magnitude"(AA_Tree) -> Univ_Integer is Count

    func Is_Empty(T : optional AA_Tree) -> Boolean
      // Return True if the tree is empty

end interface PSL::Core::AA_Tree

class PSL::Core::AA_Tree is
    var Value : Element
    var Level : Univ_Integer := 0
    var Left : optional AA_Tree
    var Right : optional AA_Tree

    func Node(var Value : optional Element; Level : Univ_Integer;
      Left, Right : optional AA_Tree) -> AA_Tree is
        // Create a new tree; move Value into it.
        return (Value <== Value, Level => Level, Left => Left, Right => Right)
    end func Node

    func Is_Leaf(T : optional AA_Tree) -> Boolean is
        return T not null and then
          T.Left is null and then T.Right is null
    end func Is_Leaf

    func Leftmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for L => T loop
            if L not null and then L.Left not null then
                // Continue with Left until we reach null
                continue loop with L => L.Left
            else
                // Found left-most
                return L
            end if
        end loop
    end func Leftmost

    func Successor(T : optional AA_Tree) -> optional Element is
        // Return element in tree greater than but closest to T.Value
        if T.Right not null then
            const Succ := Leftmost(T.Right)
            {Succ not null}
            return Succ.Value
        else
            return null
        end if
    end func Successor

    func Rightmost(ref T : optional AA_Tree) -> ref optional AA_Tree is
        for R => T loop
            if R not null and then R.Right not null then
                // Keep following down Right side
                continue loop with R => R.Right
            else
                // Found right-most
                return R
            end if
        end loop
    end func Rightmost

    func Predecessor(T : optional AA_Tree) -> optional Element is
        // Return element in tree less than but closest to T.Value
        if T.Left not null then
            return Rightmost(T.Left).Value
        else
            return null
        end if
    end func Predecessor

    func Skew(var T : optional AA_Tree) is
      // input: T, a node representing an AA tree that needs to be rebalanced.
      // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Left not null and then
          T.Left.Level == T.Level then
            // The current T.Left becomes new root

            // Exchange value of T.Left with root
            T.Value <=> T.Left.Value
           
            // Move old root and T.Left.Right over to right side of tree
            T.Left.Right <=> T.Right
            T.Left.Left <=> T.Right
            T.Left <=> T.Right
        end if
    end func Skew

    func Split(var T : optional AA_Tree) is
        // input: T, a node representing an AA tree that needs to be rebalanced.
        // output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Right not null and then
          T.Right.Right not null and then
          T.Level == T.Right.Right.Level then
            // T.Right becomes the new root
            // Exchange value and level between root and T.Right
            T.Value <=> T.Right.Value
            T.Level <=> T.Right.Level

            // Move old root and T.Right.Left to left side of tree
            T.Left <=> T.Right.Right
            T.Right.Left <=> T.Right.Right
            T.Left <=> T.Right

            // Increment level
            T.Level += 1
        end if
    end func Split

    func Decrease_Level(var T : optional AA_Tree) is
        // input: T, a tree for which we want to remove links that skip levels.
        // output: T with its level decreased.

        if T is null then
            return
        end if
           
        var Should_Be : Univ_Integer := 1

        if T.Left not null then
            Should_Be := T.Left.Level + 1
        end if

        if T.Right not null then
            Should_Be := Min(Should_Be, T.Right.Level + 1)
        end if
            
        if Should_Be < T.Level then
            T.Level := Should_Be
            if T.Right not null and then
              Should_Be < T.Right.Level then
                T.Right.Level := Should_Be
            end if
        end if
    end func Decrease_Level

  exports

    op "[]"() -> optional AA_Tree is
        // Create an empty tree
        return null
    end op "[]"

    // Insertion begins with the normal binary tree search and insertion
    // procedure. Then, as the call stack unwinds (assuming a recursive
    // implementation of the search), it's easy to check the validity of the
    // tree and perform any rotations as necessary. If a horizontal left link
    // arises, a skew will be performed, and if two horizontal right links
    // arise, a split will be performed, possibly incrementing the level of the
    // new root node of the current subtree. Note, in the code as given above,
    // the increment of T.Level. This makes it necessary to continue checking
    // the validity of the tree as the modifications bubble up from the leaves.
    
    op "<|="(var T : optional AA_Tree; var X : optional Element) is
	// Move X into AA_Tree, leaving X null.
        // input: X, the value to be inserted, and 
        // T, the root of the tree to insert it into.
        // output: A balanced T' including X.

        // Do the normal binary tree insertion procedure. 
        // Set the result of the recursive call to the correct 
        // child in case a new node was created or the
        // root of the subtree changes.

        if T is null then
            // Create a new leaf node with X.
            T := Node(X, 1, null, null)
            return
        end if

        case X =? T.Value of
          [#less] =>
            T.Left <|= X
          [#greater] =>
            T.Right <|= X
          [#equal | #unordered] =>
            // Note that the case of X == T.Value is unspecified. 
            // As given, an insert will have no effect. 
            // The implementor may desire different behavior.
	    X := null
            return
        end case

        // Perform skew and then split. 
        // The conditionals that determine whether or
        // not a rotation will occur or not are inside 
        // of the procedures, as given above.

        Skew(T)
        Split(T)
    end op "<|="

    func Insert(var T : optional AA_Tree; X : Element) is
	// Just pass the buck to the "<|=" operation
	var X_Copy for T := X
	T <|= X_Copy
    end func Insert

    // As in most balanced binary trees, the deletion of an internal node can
    // be turned into the deletion of a leaf node by swapping the internal node
    // with either its closest predecessor or successor, depending on which are
    // in the tree or on the implementor's whims. Retrieving a predecessor is
    // simply a matter of following one left link and then all of the remaining
    // right links. Similarly, the successor can be found by going right once
    // and left until a null pointer is found. Because of the AA property of
    // all nodes of level greater than one having two children, the successor
    // or predecessor node will be in level 1, making their removal trivial.
    // 
    // To re-balance a tree, there are a few approaches. The one described by
    // Andersson in his original paper is the simplest, and it is described
    // here, although actual implementations may opt for a more optimized
    // approach. After a removal, the first step to maintaining tree validity
    // is to lower the level of any nodes whose children are two levels below
    // them, or who are missing children. Then, the entire level must be skewed
    // and split. This approach was favored, because when laid down
    // conceptually, it has three easily understood separate steps:
    // 
    //     Decrease the level, if appropriate.
    //     Skew the level.
    //     Split the level.
    // 
    // However, we have to skew and split the entire level this time instead of
    // just a node, complicating our code.

    func Delete(var T : optional AA_Tree; X : Element) is
        // input: X, the value to delete, and T, 
        // the root of the tree from which it should be deleted.
        // output: T', balanced, without the value X.

        if T is null then
            // Not in tree -- should we complain?
            return
        end if

        case X =? T.Value of
          [#less] =>
            Delete(T.Left, X)
          [#greater] =>
            Delete(T.Right, X)
          [#equal] =>
            // If we're a leaf, easy, otherwise reduce to leaf case. 
            if Is_Leaf(T) then
                T := null
            elsif T.Left is null then
                // Get successor value and delete it from right tree,
                // and set root to have that value
                const Succ := Successor(T)
                Delete(T.Right, Succ)
                T.Value := Succ
            else
                // Get predecessor value and delete it from left tree,
                // and set root to have that value
                const Pred := Predecessor(T)
                Delete(T.Left, Pred)
                T.Value := Pred
            end if
          [#unordered] =>
            // Not in tree; should we complain?
            return
        end case

        // Rebalance the tree. Decrease the level of all nodes in this level if
        // necessary, and then skew and split all nodes in the new level.

        if T is null then
            return
        end if

        Decrease_Level(T)
        Skew(T)
        Skew(T.Right)
        if T.Right not null then
            Skew(T.Right.Right)
        end if
        Split(T)
        Split(T.Right)
    end func Delete

    op "in"(X : Element; T : optional AA_Tree) -> Result : Boolean is
        for P => T while P not null loop
            case X =? P.Value of
              [#less] =>
                continue loop with P => P.Left
              [#greater] =>
                continue loop with P => P.Right
              [#equal] =>
                return #true
              [#unordered] =>
                return #false
            end case
        end loop
        return #false   // Not found
    end op "in"

    func First(T : optional AA_Tree) -> optional Element is
      // Return first (smallest) element in tree
        if T is null then
            return null
        else 
            return Leftmost(T).Value
        end if
    end func First

    func Last(T : optional AA_Tree) -> optional Element is
      // Return last (greatest) element in tree
        if T is null then
            return null
        else
            return Rightmost(T).Value
        end if
    end func Last


    func Remove_First(var T : optional AA_Tree) -> Result : optional Element is
      // Remove first (smallest) element in tree
        Result := First(T)
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_First

    func Remove_Last(var T : optional AA_Tree) -> Result : optional Element is
      // Remove last (greatest) element in tree
        Result := Last(T)
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_Last

    func Remove_Any(var T : optional AA_Tree) -> Result : optional Element is
      // Remove some element from tree
        if T is null then
            return null
        end if
        Result := T.Value
        if Result not null then
            Delete(T, Result)
        end if
    end func Remove_Any

    func Is_Empty(T : optional AA_Tree) -> Boolean is
      // Return True if the tree is empty
        return T is null
    end func Is_Empty

    func Count(T : optional AA_Tree) -> Univ_Integer is
      // Return a count of the nodes in the tree
        if T is null then
            return 0
        else
            return Count(T.Left) + Count(T.Right) + 1
        end if
    end func Count

    func Overlapping(T : optional AA_Tree; X : Element) -> optional Element is
        // input: X, the value to find, and T, 
        // the root of the tree to be searched.
        // output: the element equal to or "unordered" relative to X.
        if T is null or else T.Value is null then
            return null
        else
            case X =? T.Value of
              [#less] =>
                return Overlapping(T.Left, X)
              [#greater] =>
                return Overlapping(T.Right, X)
              [#equal | #unordered] =>
                // Close enough
                return T.Value
            end case
        end if
    end func Overlapping

end class PSL::Core::AA_Tree

func PSL::Test::Test_AA_Tree
  (A : Univ_Integer; B : Univ_Integer; C : Univ_Integer) is
    type Univ_Tree is AA_Tree<Univ_Integer>
    var T : Univ_Tree := []
    var X : Univ_Integer := A

    Insert(T, A)
    Println("Count = " | Count(T) | " after insert of " | A)
    Insert(T, B)
    Println("Count = " | Count(T) | " after insert of " | B)
    Insert(T, C)
    Println("Count = " | Count(T) | " after insert of " | C)

    Insert(T, A)
    Println("Count = " | Count(T) | " after another insert of " | A)

    Println(A | " in T = " | (A in T))
    Println(B | " in T = " | (B in T))
    Println(C | " in T = " | (C in T))
    Println("7 in T = " | (7 in T))

    for E := Remove_First(T) then Remove_First(T) while E not null loop
        Println("Remove_First = " | E)
    end loop

    Println("Count after loop : " | Count(T))

    for I in 1..10 forward loop
        Insert(T, I)
        Println("Count = " | Count(T) | " after insert of " | I)
    end loop

    for L := Remove_Last(T) then Remove_Last(T) while L not null loop
        Println("Remove_Last = " | L)
    end loop

    Println("Count after loop : " | Count(T))

    for J in 1..10 reverse loop
        Insert(T, J)
        Println("Count = " | Count(T) | " after insert of " | J)
    end loop

    Println("Count after loop : " | Count(T))

    Println("Overlapping(T, 5) = " | Overlapping(T, 5))

    for Z := Remove_Any(T) then Remove_Any(T) while Z not null loop
        Println("Remove_Any = " | Z)
    end loop

    Println("Count after loop : " | Count(T))

    for K in 1..10 loop
        Insert(T, K)
        Println("Count = " | Count(T) | " after insert of " | K)
    end loop

    for F := Remove_First(T) then Remove_First(T) while F not null loop
        Println("Remove_First = " | F)
    end loop

    Println("Count after loop : " | Count(T))

end func PSL::Test::Test_AA_Tree

abstract interface PSL::Containers::Keyed<Key_Type is Hashable<>> is
    func Key_Of(ref const KV : Keyed) -> ref const Key_Type
    func Has_Value(KV : Keyed) -> Boolean
	// Return #true if Keyed object has a non-null value
    func Key_Only(Key : Key_Type) -> Keyed
	// Return a Keyed object given a key, having no associated value
end interface PSL::Containers::Keyed

interface PSL::Containers::Key_Value
  <Key_Type is Assignable<>; Value_Type is Assignable<>> 
  implements Keyed<Key_Type> is
  // This supports the use of [Key => Value] as a way to
  // add a single element to an existing indexable container of some sort.
    var Key : optional Key_Type
    var Value : optional Value_Type
    op "[]"() -> Key_Value
    op "var_indexing"(ref var KV : Key_Value; Index : Key_Type) 
      -> ref var Value_Type
    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type
    func Has_Value(KV : Key_Value) -> Boolean
	// Return #true if Key_Value object has a non-null value
    func Key_Only(Key : Key_Type) -> Key_Value
	// Return a Key_Value object given a key, having no associated value
end interface PSL::Containers::Key_Value

class PSL::Containers::Key_Value is
  exports
    op "[]"() -> Key_Value is
	return (Key => null, Value => null)
    end op "[]"

    op "var_indexing"(ref var KV : Key_Value; Index : Key_Type) 
      -> ref var Value_Type is
	KV.Key := Index
	return KV.Value
    end op "var_indexing"

    func Key_Of(ref const KV : Key_Value) -> ref const Key_Type is
	return KV.Key
    end func Key_Of

    func Has_Value(KV : Key_Value) -> Boolean is
	// Return #true if Key_Value object has a non-null value
	return KV.Value not null
    end func Has_Value

    func Key_Only(Key : Key_Type) -> Key_Value is
	// Return a Key_Value object given a key, having no associated value
	return [Key => null]
    end func Key_Only
end class PSL::Containers::Key_Value

interface PSL::Containers::Basic_Map<KV_Type is Keyed<>> is
  // A basic hashed-map module

    op "[]"() -> Basic_Map

    op "|="(var Left : Basic_Map; Right : KV_Type)
	// Add Key=>Value to Basic_Map, replacing pre-existing Basic_Mapping
	// for Key, if any.

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type)
	// Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
	// for Key, if any, leaving Right null.

    op "+="(var Left : Basic_Map; Right : KV_Type) is "|="
	// A synonym for adding a key=>value KV_Type

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean
	// Return True if given key has a Basic_Mapping in the Basic_Map

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type)   // aka Exclude
	// Remove Basic_Mapping for Right, if present

    op "index_set"(M : Basic_Map) -> Set<KV_Type::Key_Type>
	// Return set of keys with Basic_Mappings

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type
	// Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type
	// Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Basic_Map) -> optional KV_Type
	// Remove one Basic_Mapping from the Basic_Map.  
	// Return null if Basic_Map is empty

    func Count(M : Basic_Map) -> Univ_Integer
	// Number of Basic_Mappings in the table

    op "magnitude"(Basic_Map) -> Univ_Integer is Count

    func Is_Empty(M : Basic_Map) -> Boolean
	// Return True if map has no mappings

    func Dump_Statistics(M : Basic_Map)
      // A debugging routine to show bucket sizes of Basic_Map

end interface PSL::Containers::Basic_Map

class PSL::Containers::Basic_Map is
  // A basic hashed-map module

  // A Basic_Map is represented as a hash table, where each bucket is 
  // a linked list of key/value KV_Types.
  // When key/value KV_Types are deleted from the Basic_Map they end 
  // up as "null"s in the list.  
  // We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface Hash_Bucket<> is
      // a simple linked-list is used as a hash bucket
	var Elem : optional KV_Type
	var Tail : optional Hash_Bucket
    end interface Hash_Bucket

    var Count : Univ_Integer
    var Table : optional Basic_Array<optional Hash_Bucket<>>
    const Initial_Table_Size := 4
    const Debugging : Boolean := #false
    
    func Empty(Table_Size : Univ_Integer) -> Basic_Map is
	// Create an empty Basic_Map with the given table size
        return (Count => 0, Table => Create(Table_Size, null))
    end func Empty

    func Move_One(var To : Basic_Map; var Elem : optional KV_Type) is
	// Move Element into table, without expanding table.
	// Elem is set to null as a result.
	const Index := Hash(Key_Of(Elem)) mod |To.Table| + 1
	ref Bucket => To.Table[Index]

	if Bucket is null then
	    // Bucket is now empty, so create bucket
	    // with Elem as its only element.
	    Bucket := (Elem <== Elem, Tail => null)
	else
	    // See whether Elem already in bucket
	    var Has_Empty_Slot : Boolean := #false
	    for B => Bucket then B.Tail while B not null loop
		if B.Elem is null then
		    // Remember there is an empty slot
		    Has_Empty_Slot := #true
		elsif Key_Of(Elem) == Key_Of(B.Elem) then
		    // Already there; replace it in case Value is different.
		    B.Elem <== Elem
		    return
		end if
	    end loop

	    if Has_Empty_Slot then
		// Fill in the empty slot
		for B => Bucket then B.Tail while B not null loop
		    if B.Elem is null then
			// Use the empty slot
			B.Elem <== Elem
			exit loop
		    end if
		end loop
	    else
		// Make old bucket the new tail of the new bucket.
		Bucket := (Elem <== Elem, Tail <== Bucket)
	    end if
	end if

	To.Count += 1
    end func Move_One

    func Add_One(var To : Basic_Map; Elem : KV_Type) is
	// Add Element to table, without expanding it
	var Elem_Copy for To := Elem

	// Just pass the buck to "Move_One"
	Move_One(To, Elem_Copy)
    end func Add_One

    func Expand_Table(var Expanding : Basic_Map) is
	// Expand table of given Basic_Map.
	if Debugging then
	    Println(" Expanding hash table, Count = " | Expanding.Count | 
	      ", Length = " | |Expanding.Table|)
	end if
	var Old_Basic_Map <== Expanding
	Expanding := Empty(2 * |Old_Basic_Map.Table|)
	// Move elements into new table
	loop
	    var Elem for Expanding := Remove_Any(Old_Basic_Map)
		// "for Expanding" means to allocate Elem in
		// region associated with Expanding.
	    if Elem is null then
		exit loop
	    end if
	    Move_One(Expanding, Elem)
	end loop
	if Debugging then
	    Println(" After expansion, Count = " | Expanding.Count |
	      ", Length = " | |Expanding.Table|)
	end if
    end func Expand_Table

  exports
    op "[]"() -> Basic_Map is
        return (Count => 0, Table => null)
    end op "[]"

    op "|="(var Left : Basic_Map; Right : KV_Type) is
	if not Has_Value(Right) then
	    // Putting in Key => null is equivalent to deleting Key
	    Left -= Key_Of(Right)
	    return
	end if

	if Left.Table is null then
	    Left := Empty(Initial_Table_Size)
	elsif Left.Count >= 2*Length(Left.Table) then
	    // Expand table if averaging 2 or more per hash bucket
	    Expand_Table(Left)
	end if
        Add_One(Left, Right)
    end op "|="

    op "<|="(var Left : Basic_Map; var Right : optional KV_Type) is
	// Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
	// for Key, if any, leaving Right null.
	if not Has_Value(Right) then
	    // Putting in Key => null is equivalent to deleting Key
	    Left -= Key_Of(Right)
	    Right := null
	    return
	end if

	if Left.Table is null then
	    Left := Empty(Initial_Table_Size)
	elsif Left.Count >= 2*Length(Left.Table) then
	    // Expand table if averaging 2 or more per hash bucket
	    Expand_Table(Left)
	end if
        Move_One(Left, Right)
    end op "<|="

    op "in"(Left : KV_Type::Key_Type; Right : Basic_Map) -> Boolean is
	if Right.Count == 0 then
	    // Empty Basic_Map
	    return #false
	end if
	const Index := Hash(Left) mod Length(Right.Table) + 1
	ref Bucket => Right.Table[Index]
	if Bucket is null then
	    // Hash bucket is empty
	    return #false
	end if
	// Scan for Elem in hash bucket
	for B => Bucket then B.Tail while B not null loop 
	    if B.Elem not null and then
	      Has_Value(B.Elem) and then
	      Key_Of(B.Elem) == Left then
		// Found it
		return #true
	    end if
	end loop
	// Not in Basic_Map
	return #false
    end op "in"

    op "-="(var M : Basic_Map; Key : KV_Type::Key_Type) is
      // Remove the given key from the Basic_Map, if present
	if M.Count == 0 then
	    // Empty Basic_Map
	    return
	end if

	const Index := Hash(Key) mod Length(M.Table) + 1
	ref Bucket => M.Table[Index]
	if Bucket is null then
	    // Hash bucket is empty
	    return
	end if

	// Scan for Key in bucket
	for B => Bucket then B.Tail while B not null loop
	    if B.Elem not null and then
	      Key_Of(B.Elem) == Key then
		// Found it.  Map it to null, and decrement Basic_Map count.
		B.Elem := null
		M.Count -= 1
		return
	    end if
	end loop
	// Not found
    end op "-="
   
    op "index_set"(M : Basic_Map) -> Result : Set<KV_Type::Key_Type> is
	// Return set of keys with non-null Basic_Mappings
	Result := []
        if M.Count == 0 then
            return
        end if
	for each Bucket of M.Table loop
	    for B => Bucket then B.Tail while B not null loop
		if B.Elem not null and then
		  Has_Value(B.Elem) then
		    Result |= Key_Of(B.Elem)
		end if
	    end loop
	end loop
    end op "index_set"

    op "indexing"(ref M : Basic_Map; Key : KV_Type::Key_Type) {Key in M} 
      -> ref KV_Type is
	// Used for references to M[Key]; requires the Key to be in M.
	{M not null; M.Count > 0}
	const Index := Hash(Key) mod Length(M.Table) + 1
	// Scan for Key in bucket
	for B => M.Table[Index] then B.Tail while B not null loop
	    if B.Elem not null and then
	      Key_Of(B.Elem) == Key then
		// Found it.  Return reference to element of KV_Type
		{Has_Value(B.Elem)}
		return B.Elem
	    end if
	end loop
	{#false}
    end op "indexing"

    op "var_indexing"(ref var M : Basic_Map; Key : KV_Type::Key_Type) 
      -> ref var optional KV_Type is
	// Used for assignments to M[Key]; Key is added to M if not present
	if M.Table not null then
	    const Index := Hash(Key) mod Length(M.Table) + 1
	    // Scan for Key in bucket
	    for B => M.Table[Index] then B.Tail while B not null loop
		if B.Elem not null and then
		  Key_Of(B.Elem) == Key then
		    // Found it.  Return reference to element of KV_Type
		    return B.Elem
		end if
	    end loop
	end if

	// Not in table.  Add it, and then return reference
	if M.Table is null then
	    M := Empty(Initial_Table_Size)
	elsif M.Count >= 2*Length(M.Table) then
	    // Expand table if averaging 2 or more per hash bucket
	    Expand_Table(M)
	end if

	// Add [Key => null] to front of appropriate bucket.
	const Index := Hash(Key) mod Length(M.Table) + 1
	ref Bucket => M.Table[Index]
	Bucket := (Elem => Key_Only(Key), Tail <== Bucket)
	M.Count += 1

	// Return ref to new element
	return Bucket.Elem
    end op "var_indexing"

    func Count(M : Basic_Map) -> Univ_Integer is
        if M is null then
            return 0
        else
            return M.Count
        end if
    end func Count

    func Is_Empty(M : Basic_Map) -> Boolean is
	// Return True if map has no mappings
	return M.Count == 0
    end func Is_Empty

    func Remove_Any(var M : Basic_Map) -> Result : optional KV_Type is
	if M.Count == 0 then
	    // Basic_Map is empty
	    return null
	else
	    // Find a non-empty bucket and pull out an item.
	    for each Bucket of M.Table loop
		if Bucket not null then
		    for B => Bucket then B.Tail while B not null loop 
			if B.Elem not null then
			    // Found an item, remove from Bucket and return
			    Result <== B.Elem
			    M.Count -= 1
			    return
			end if
		    end loop
		    // This bucket is completely empty, so might
		    // as well empty it out.
		    Bucket := null
		end if
		// Go on to the next bucket, this one's empty
	    end loop
	    // Should never get here
	    return null
	end if
    end func Remove_Any

    func Dump_Statistics(M : Basic_Map) is
      // A debugging routine to show bucket sizes of Basic_Map
	Println("Basic_Map statistics: Count = " | M.Count)
	if M.Table is null then
	    Println(" Table is null")
	else
	    Println(" Table of length " | Length(M.Table))
	    for each [I => Bucket] of M.Table forward loop
		Print("  Bucket #" | I)
		if Bucket is null then
		    Println(" is null")
		else
		    var Len := 0
		    var Holes := 0
		    for B => Bucket then B.Tail while B not null loop
			Len += 1
			if B.Elem is null then
			    // This list has a hole
			    Holes += 1
			end if
		    end loop
		    if Holes > 0 then
			Println(" of length " | Len | " with " | 
			  Holes | " holes")
		    else
			Println(" of length " | Len)
		    end if
		end if
	    end loop
	end if
    end func Dump_Statistics

end class PSL::Containers::Basic_Map

func PSL::Test::Test_Basic_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    type Enum_String_KV_Type is Key_Value<Univ_Enumeration, Univ_String>
    type Enum_String_Basic_Map is Basic_Map<Enum_String_KV_Type>

    var M : Enum_String_Basic_Map := [X => [X => Y], A => [A => B]]

    Println("Count = " | Count(M))

    for each KV of M loop
	ref const K => KV.Key
	ref const V => KV.Value
	Println("Basic_Mapping " | K | " => " | V)
	Println(K | " in M = " | (K in M))
    end loop

    Println("#xy in M = " | (#xy in M))

    M |= [X => null]

    Println("Count after deletion = " | Count(M))

    for each KV of M loop
	ref const K => KV.Key
	ref const V => KV.Value
	Println("Basic_Mapping " | K | " => " | V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " | Count(M))

    for each KV of M loop
	ref const K => KV.Key
	ref const V => KV.Value
	Println("Basic_Mapping " | K | " => " | V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " | Count(M))

    for each KV of M loop
	ref const K => KV.Key
	ref const V => KV.Value
	Println("Basic_Mapping " | K | " => " | V)
    end loop

    M -= A

    Println("Count after deletion = " | Count(M))

    for each KV of M loop
	ref const K => KV.Key
	ref const V => KV.Value
	Println("Basic_Mapping " | K | " => " | V)
    end loop

    var Ran := Random::Start(Hash(A))
    var MUI : Basic_Map<Key_Value<Univ_Integer, Univ_Integer>> := []

    Println("Adding 100 random KV_Typeings to Basic_Map.")
    for I in 1..100 loop
	const Key := Next(Ran) mod 100
	const Value := Next(Ran) mod 100
	MUI[Key] := [Key => Value]
    end loop
    Println("Basic_Map is now of count = " | Count(MUI))

    for each [K => KV] of MUI loop
	ref const V => KV.Value
	Println("Basic_Mapping " | K | " => " | V)
	Println("MUI[" | K | "] = " | MUI[K].Value)
    end loop

    var I := 0
    for KV_Type in MUI loop
	I += 1
	Print(" [" | Key_Of(KV_Type) | " => " | KV_Type.Value | "]")
	if I mod 5 == 0 then
	    Print('\n')
	end if
    end loop
    if I mod 5 != 0 then
	Print('\n')
    end if

end func PSL::Test::Test_Basic_Map

class PSL::Containers::Set is
  // A hashed-set module

  // A Set is represented as a hash table, where each bucket is a linked list.
  // When elements are deleted from the Set they end up a "null"s in the
  // list.  We expand the table when the Count gets to be twice
  // that of the length of the table.

    interface KV_Wrapper<> implements Keyed<Element_Type> is
      // Create a wrapper for a key that implements the Keyed interface
	var Key : Element_Type
	func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type
	func Has_Value(KV : KV_Wrapper) -> Boolean
	    // Return #true if KV_Wrapper object has a non-null value
	func Key_Only(Key : Element_Type) -> KV_Wrapper
	    // Return a KV_Wrapper object given a key, 
	    // having no associated value
    end interface KV_Wrapper

    class KV_Wrapper is
      // Create a wrapper for a key that implements the Keyed interface
      exports
	func Key_Of(ref const KV : KV_Wrapper) -> ref const Element_Type is
	    return KV.Key
	end func Key_Of

	func Has_Value(KV : KV_Wrapper) -> Boolean is
	    // Return #true if KV_Wrapper object has a non-null value
	    return #true
	end func Has_Value

	func Key_Only(Key : Element_Type) -> KV_Wrapper is
	    // Return a KV_Wrapper object given a key, 
	    // having no associated value.
	    // NOTE: This is not really meaningful for sets, since there
	    //       isn't a value.
	    return (Key => Key)
	end func Key_Only
    end class KV_Wrapper
	
    var Data : Basic_Map<KV_Wrapper<>>
	// Set is represented as a map from keys to nothing.

  exports
    op "[]"() -> Set is
        return (Data => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Set is
	Result := []
	Result.Data |= (Key => Elem)
    end func Singleton

    op "|"(Left, Right : Element_Type) -> Result : Set is
	Result := []
	Result.Data |= (Key => Left)
	Result.Data |= (Key => Right)
    end op "|"

    op "|"(Left : Set; Right : Element_Type) -> Result : Set is
	Result := Left
	Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Set) -> Result : Set is
	Result := Right
	Result |= Left
    end op "|"

    op "|"(Left : Set; Right : Set) -> Result : Set is
	// Union, iterate over smaller Set
	if Count(Left.Data) <= Count(Right.Data) then
	    Result := Right
	    Result |= Left
	else
	    Result := Left
	    Result |= Right
	end if
    end op "|"

    op "|="(var Left : Set; Right : Set) is
        if Count(Left.Data) == 0 then
            Left := Right
        else
	    for Elem in Right loop
		Left |= Elem
	    end loop
	end if
    end op "|="

    op "|="(var Left : Set; Right : Element_Type) is
	Left.Data |= (Key => Right)
    end op "|="

    op "<|="(var Left : Set; var Right : optional Element_Type) is
	// Move Right into Set Left
	var KV : KV_Wrapper := (Key <== Right)
	Left.Data <|= KV
    end op "<|="

    op "<|="(var Left : Set; var Right : Set) is
	// Move all elements of Right into Left, leaving Right empty.
	loop
	    // Extract element from Right, in region for Left
	    var Elem for Left := Remove_Any(Right)
	    if Elem is null then
		// All done
		return
	    end if
	    // Move element into Left
	    Left <|= Elem
	end loop
    end op "<|="

    op "in"(Left : Element_Type; Right : Set) -> Boolean is
	return Left in Right.Data
    end op "in"

    op "=?"(Left, Right : Set) -> Ordering is
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right.Data) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right.Data) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    op "and"(Left, Right : Set) -> Result : Set is
	// Intersection, iterate over smaller Set
	if Count(Left.Data) < Count(Right.Data) then
	    // Left is smaller
	    Result := []
	    for Elem in Left loop
		if Elem in Right then
		    Result |= Elem
		end if
	    end loop
	else
	    // Left is bigger
	    Result := Left
	    for Elem in Right loop
		if Elem in Left then
		    Result |= Elem
		end if
	    end loop
	end if
    end op "and"

    op "and="(var Left : Set; Right : Set) is
	// Intersection, iterate over smaller Set
	if Count(Left.Data) <= Count(Right.Data) then
	    // Left is smaller
	    for Elem in Left loop
		if Elem not in Right then
		    Left -= Elem
		end if
	    end loop
	else
	    // Left is bigger
	    var Result : Set for Left := []
	    for Elem in Right loop
		if Elem in Left then
		    Result |= Elem
		end if
	    end loop
	    Left <== Result
	end if
    end op "and="

    op "xor"(Left, Right : Set) -> Result : Set is
	// Symmetric difference
	// Want elements that are only in one of the two inputs
	if Count(Left.Data) < Count(Right.Data) then
	    // Swap order to shorten iteration
	    Result := Right
	    Result xor= Left
	else
	    Result := Left
	    Result xor= Right
	end if
    end op "xor"
    
    op "xor="(var Left : Set; Right : Set) is
	// Want elements that are only in one of the two inputs
	for Elem in Right loop
	    if Elem in Left then
		Left -= Elem
	    else
		Left += Elem
	    end if
	end loop
    end op "xor="

    op "-"(Left, Right : Set) -> Result : Set is
	// Set difference, iterate over smaller Set
	if Count(Left.Data) < Count(Right.Data) then
	    // Left is smaller, build up 
	    Result := []
	    for Elem in Left loop
		if Elem not in Right then
		    Result |= Elem
		end if
	    end loop
	else
	    // Left is bigger, tear down
	    Result := Left
	    Result -= Right
	end if
    end op "-"

    op "-="(var Left : Set; Right : Set) is
	// Compute Set difference
	for Elem in Right loop
	    Left -= Elem
	end loop
    end op "-="

    op "-="(var S : Set; Elem : Element_Type) is
      // Remove the given element from the Set, if present
	S.Data -= Elem
    end op "-="
   
    func Count(S : Set) -> Univ_Integer is
	return Count(S.Data)
    end func Count

    func Is_Empty(S : Set) -> Boolean is
	return Is_Empty(S.Data)
    end func Is_Empty

    func Remove_Any(var S : Set) -> Result : optional Element_Type is
	var Result_Wrapper for Result := Remove_Any(S.Data)
	if Result_Wrapper is null then
	    return null
	else
	    Result <== Result_Wrapper.Key
	end if
    end func Remove_Any

    func Dump_Statistics(S : Set) is
      // A debugging routine to show bucket sizes of Set
	Dump_Statistics(S.Data)
    end func Dump_Statistics

end class PSL::Containers::Set

func PSL::Test::Test_Set(A, X, Y, Z : Univ_Integer) is
    var S : Set<Univ_Integer> := X | Y | Z
    if A in S then
        Println(A | " is in " | X | "|" | Y | "|" | Z)
    else
        Println(A | " is *not* in " | X | "|" | Y | "|" | Z)
    end if

    const Save_Set := S

    const CSet : Set<Univ_Integer> := [Z, Y, X]
    Println("[Z, Y, X] =? (X | Y | Z) --> " |
      ( CSet =? S ))

    var Ran := Random::Start(A)
    Println("Adding 100 random digits to Set.")
    for I in 1..100 loop
        const N := Next(Ran) mod 100
        S |= N
        S |= N  // Make sure it doesn't produce duplicates
    end loop
    Println("Set is now of count = " | Count(S))
    Println("Contents of Set:")
    var I := 1
    for Elem in S loop
	Print(Elem | " ")
	if I mod 10 == 0 then
	    Print('\n')
	end if
	I += 1
    end loop
    if Count(S) mod 10 != 0 then
	Print('\n')
    end if
    Println("S Before adding random elements =? now --> " |
      (Save_Set =? S))
    Println("S =? S --> " | (S =? S))

    var Small_Set : Set<Univ_Integer> := []
    Small_Set += -1
    Small_Set or= [2]

    Println("S =? (-1 | 2) --> " | (S =? Small_Set))
    Println("[2 , -1] =? (-1 | 2) --> " | ([2, -1] =? Small_Set))

    Println("S =? [] --> " | (S =? []))

    Println("Count(S) = " | Count(S))
    
    const Before_Exclude := S
    S -= X
    Println("After Exclude(S, " | X | "), Count(S) = " | Count(S))
    Println("Before_Exclude =? After Exclude --> " | (Before_Exclude =? S))

    Dump_Statistics(S)
end func PSL::Test::Test_Set


class PSL::Containers::Countable_Set is

    type Element_Interval is Closed_Interval<Element_Type>

    func Len(IV : Element_Interval) -> Univ_Integer is (IV.High - IV.Low + 1);

    var Items : optional AA_Tree<Element_Interval>
  exports
    op "[]"() -> Countable_Set is
        return (Items => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Countable_Set is
	Result := []
	Result.Items |= (Low => Elem, High => Elem)
    end func Singleton

    op ".."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (Low => Left, High => Right)
        end if
    end op ".."
    
    op "<.."(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left+1, High => Right)
        end if
    end op "<.."
    
    op "<..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right-1 then
            Result.Items |= (Low => Left+1, High => Right-1)
        end if
    end op "<..<"
    
    op "..<"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, High => Right-1)
        end if
    end op "..<"
    
    op "|"(Left, Right : Element_Type) -> Result : Countable_Set is
        Result := []
        if Left >= Right-1 and then Left <= Right + 1 then
            // Can combine elements into a single interval
            if Left <= Right then
                Result.Items |= (Low => Left, High => Right)
            else
                Result.Items |= (Low => Right, High => Left)
            end if
        else
            // Make each element its own interval
            Result.Items |= (Low => Left, High => Left)
            Result.Items |= (Low => Right, High => Right)
        end if
    end op "|"

    op "|"(Left : Countable_Set; Right : Element_Type) 
      -> Result : Countable_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Countable_Set) -> Countable_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Countable_Set; Right : Countable_Set) 
      -> Result : Countable_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Countable_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := (Low => Right, High => Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end op "|="

    op "<|="(var Left : Countable_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
	// NOTE: No copy minimization done for countable types.
	Left |= Right
	Right := null
    end op "<|="

    op "<|="(var Left : Countable_Set; var Right : Countable_Set) is
	// Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items
        else
            // Iterate through the tree
	    loop
		// Extract interval from Right
		var Right_IV for Left := Remove_Any(Right.Items)

		if Right_IV is null then
		    return   // All done
		end if

                // See whether it overlaps with an existing interval
                // in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    if Left_IV.Low <= Right_IV.Low and then
                      Left_IV.High >= Right_IV.High then
                        // Right_IV is subsumed; nothing to add in
                        Right_IV := null
                        exit loop
                    else
                        // Need to delete Left_IV and incorporate
                        // into Right_IV
                        Delete(Left.Items, Left_IV)
                        if Left_IV.Low < Right_IV.Low then
                            Right_IV.Low := Left_IV.Low
                        end if
                        if Left_IV.High > Right_IV.High then
                            Right_IV.High := Left_IV.High
                        end if

                        // Now see if there is anything still overlapping
                        Left_IV := Overlapping(Left.Items, Right_IV)
                    end if
                end loop

                if Right_IV not null then
                    // Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end op "<|="

    op "|="(var Left : Countable_Set; Right : Countable_Set) is
	// Pass the buck to the "<|=" operation
	var Right_Copy for Left := Right
	Left <|= Right_Copy
    end op "|="

    op "-"(Left, Right : Countable_Set) -> Result : Countable_Set is
      // Set difference
	Result := Left
	Result -= Right
    end op "-"

    op "-"(Left : Countable_Set; Right : Element_Type)
      -> Result : Countable_Set is
      // Remove one element
        Result := Left
        Result -= Right
    end op "-"
        
    op "-="(var S : Countable_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
	const IV := Overlapping(S.Items, (Low => Elem, High => Elem))
	  // Get interval, if any, which overlaps given element

	if IV not null then
	    // Delete interval and put back after removing Elem
	    Delete(S.Items, IV)
	    if IV.High > IV.Low then
		// We need to put something back
		if IV.Low == Elem then
		    S.Items |= (Low => IV.Low + 1, High => IV.High)
		elsif IV.High == Elem then
		    S.Items |= (Low => IV.Low, High => IV.High-1)
		else
		    // Elem is in the middle, put back intervals
		    // on either side.
		    S.Items |= (Low => IV.Low, High => Elem-1)
		    S.Items |= (Low => Elem+1, High => IV.High)
		end if
	    end if
	end if

    end op "-="

    op "-="(var Left : Countable_Set; Right : Countable_Set) is
      // Remove all elements of Right from Left, if present
	for Elem in Right loop
	    Left -= Elem
	end loop
    end op "-="

    op "and"(Left, Right : Countable_Set) -> Result : Countable_Set is
	// Intersection
	Result := []
	for Elem in Right loop
	    if Elem in Left then
		Result += Elem
	    end if
	end loop
    end op "and"

    op "and="(var Left : Countable_Set; Right : Countable_Set) is
	// Intersection
	for Elem in Left loop
	    if Elem not in Right then
		Left -= Elem
	    end if
	end loop
    end op "and="

    op "xor"(Left, Right : Countable_Set) -> Result : Countable_Set is
	// Symmetric difference
	Result := Left
	Result xor= Right
    end op "xor"

    op "xor="(var Left : Countable_Set; Right : Countable_Set) is
	// Symmetric difference
	// Want elements that are only in one of the two inputs
	for Elem in Right loop
	    if Elem in Left then
		Left -= Elem
	    else
		Left += Elem
	    end if
	end loop
    end op "xor="

    op "in"(Left : Element_Type; Right : Countable_Set) -> Boolean is
        return Overlapping(Right.Items, (Low => Left, High => Left)) not null
    end op "in"

    op "=?"(Left, Right : Countable_Set) -> Ordering is
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    func Count(S : Countable_Set) -> Result : Univ_Integer is
        // Return count of items in set

        Result := 0

        // Iterate through them to build up count
        for Next_IV in S.Items loop
            Result += Len (Next_IV)
        end loop
    end func Count

    func Is_Empty(S : Countable_Set) -> Boolean is
	return Is_Empty(S.Items)
    end func Is_Empty

    func First(S : Countable_Set) -> optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end func First

    func Last(S : Countable_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end func Last

    op "indexing"(S : Countable_Set; Index : Univ_Integer)
      -> optional Element_Type is
         //  Return "Index"th element of set S, counting 1 .. Count(S)
         if Index <= 0 then
             return null
         end if

         var Start_Offset := Index - 1

         for IV in S.Items forward loop
             const IV_Len := Len (IV)
             if Start_Offset < IV_Len then
                 //  It is in this interval
                 return IV.Low + Start_Offset
             end if
             Start_Offset -= IV_Len
         end loop

         return null
    end op "indexing"

    op "slicing"(S : Countable_Set; 
      Index_Set : Countable_Range<Univ_Integer>) -> Result : Countable_Set is
         //  Return subset of set S, elements S[Index_Set.First] through
         //  S[Index_Set.Last], counting 1 .. Count(S)
         var Start_Offset := Index_Set.First - 1
         var End_Offset := Index_Set.Last - 1

         Result := []

         if Start_Offset < 0 then
             Start_Offset := 0
         end if

         if End_Offset < Start_Offset then
             return
         end if

         for IV in S.Items forward loop
             const IV_Len := Len (IV)
             if Start_Offset < IV_Len then
                 //  It starts in this interval
                 if End_Offset < IV_Len then
                     //  It ends in this interval as well
                     Result.Items |=
                        (Low => IV.Low + Start_Offset,
                         High => IV.Low + End_Offset)
                     return
                 else
                     //  It extends to the next interval
                     Result.Items |=
                        (Low => IV.Low + Start_Offset,
                         High => IV.High)
                     Start_Offset := 0
                 end if
             else
                 Start_Offset -= IV_Len
             end if
             End_Offset -= IV_Len
         end loop
    end op "slicing"

    op "/"(Set : Countable_Set; Num_Pieces : Univ_Integer)
      -> Result : Vector<Countable_Set> is
       // Divide a set into a vector of sets, each of similar size
        {> Num_Pieces > 0 <}

        if Num_Pieces <= 1 then
            //  Return a vector of length 1 if Num_Pieces is 1 (or less)
            return Create(1, Set)
        end if

        const Size := Count(Set)
        const Small_Piece_Size := Size / Num_Pieces
        const Big_Piece_Size := Small_Piece_Size + 1
        const Num_Big_Pieces := Size rem Num_Pieces

        //  Create the result
        Result := Create(Num_Pieces, [])

        //  Fill in the elements of the result vector with slices of the set.
        var Index := 1

        //  Big pieces first
        for I in 1 .. Num_Big_Pieces forward loop
            Result[I] := Set[Index .. Index + Big_Piece_Size - 1]
            Index += Big_Piece_Size
        end loop

        //  Small pieces next
        if Small_Piece_Size > 0 then
            for I in Num_Big_Pieces + 1 .. Num_Pieces forward loop
                Result[I] := Set[Index .. Index + Small_Piece_Size - 1]
                Index += Small_Piece_Size
            end loop
        end if

        {> Index == Size + 1 <}
            
    end op "/"

    func Remove_First(var S : Countable_Set) 
      -> Result : optional Element_Type is
        // Return first element of set

        // Get first interval in tree
        var First_IV := Remove_First(S.Items)
        if First_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if First_IV.High > First_IV.Low then
            // Need to put back the remainder
            S.Items |= (Low => First_IV.Low+1, High => First_IV.High)
        end if

        // Return first item
        return First_IV.Low
    end func Remove_First

    func Remove_Last(var S : Countable_Set) -> Result : optional Element_Type is
        // Remove last element of set

        // Get Last interval in tree
        var Last_IV := Remove_Last(S.Items)
        if Last_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if Last_IV.High > Last_IV.Low then
            // Need to put back the remainder
            S.Items |= (Low => Last_IV.Low, High => Last_IV.High-1)
        end if

        // Return Last item
        return Last_IV.High
    end func Remove_Last

    func Remove_Any(var S : Countable_Set) -> optional Element_Type is
        // Remove any element of set

        // Get any interval in tree
        var Any_IV := Remove_Any(S.Items)
        if Any_IV is null then
            // Tree is empty
            return null
        end if

        // See whether interval has more than one value in it
        if Any_IV.High > Any_IV.Low then
            // Need to remove one to return and put back the remainder
            if (Any_IV.High - Any_IV.Low) mod 2 == 0 then
                // Return high bound when high-low is even
                // NOTE: We do this to avoid having algorithms become
                //       dependent on always getting values in ascending 
                //       or descending order.
                S.Items |= (Low => Any_IV.Low, High => Any_IV.High-1)
                return Any_IV.High
            else
                // Return low bound when high-low is odd
                S.Items |= (Low => Any_IV.Low+1, High => Any_IV.High)
                return Any_IV.Low
            end if
        else
            // Return only item in interval
            return Any_IV.Low
        end if

    end func Remove_Any

end class PSL::Containers::Countable_Set

func PSL::Test::Test_Countable_Set(A, X, Y, Z : Integer) is
    var S : Countable_Set<Integer> := X | Y..Z
    Println(A | " in " | X | "|" | Y | ".." | Z | "=" | ( A in S ))

    const Agg : Countable_Set<Integer> := [X, Y, Z]
    const Or : Countable_Set<Integer> := Y | Z | X

    Println(" [X, Y, Z] =? (Y | Z | X) --> " | ( Agg =? Or ))

    for J in S loop 
        Println("Remove_Any(S) = " | J)
    end loop

    S := []

    for I in 1..10 forward loop
        S += I
        Println("Adding " | I | " to S, Count = " | Count(S))
    end loop

    for K in S loop 
        Println("Remove_Any(S) = " | K)
    end loop

    Println("Count(S) = " | Count(S))
    S -= 7
    Println("After S -= 7, Count(S) = " | Count(S))

    var Xor := S xor [2, 5, 12, 15]
    Print("S xor [2, 5, 12, 15] = ")
    for J in Xor forward loop
	Print(J | " ")
    end loop
    Print('\n')

    for I in -1 .. 11 forward loop
       Println("S[" | I | "] = " | S[I])
    end loop

    for I in -1 .. 11 forward loop
        for J in I-2 .. I + 5 forward loop
            Print("S[" | I | " .. " | J | "] = ")
            const Slice := S[I .. J]
            for K in Slice forward loop
                Print(K | " ")
            end loop
            Print('\n')
        end loop
    end loop

    for Num in 1 .. 11 forward loop
       Print("S / " | Num | " =")
       for each Piece of S / Num forward loop
          Print (" {")
          for J in Piece forward loop
              Print(J | " ")
          end loop
          Print ("}")
       end loop
       Print('\n')
    end loop
end func PSL::Test::Test_Countable_Set

interface PSL::Containers::Ordered_Set<Element_Type is Comparable<>> is
  // A set abstraction that supports efficiently storing potentially
  // large ranges of values
    op "[]"() -> Ordered_Set

    func Singleton(Elem : Element_Type) -> Ordered_Set
	// Return a set consisting of a single element

    op ".."(Left, Right : Element_Type) -> Ordered_Set
	// Closed interval of values
    op "<.."(Left, Right : Element_Type) -> Ordered_Set
	// Open-Closed interval of values
    op "..<"(Left, Right : Element_Type) -> Ordered_Set
	// Closed-Open interval of values
    op "<..<"(Left, Right : Element_Type) -> Ordered_Set
	// Open interval of values

    op "|"(Left, Right : Element_Type) -> Ordered_Set
    op "|"(Left : Ordered_Set; Right : Element_Type) -> Ordered_Set
    op "|"(Left : Element_Type; Right : Ordered_Set) -> Ordered_Set
    op "|"(Left : Ordered_Set; Right : Ordered_Set) -> Ordered_Set

    op "|="(var Left : Ordered_Set; Right : Element_Type)
    op "|="(var Left : Ordered_Set; Right : Ordered_Set)

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set)
	// Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Ordered_Set) -> Ordered_Set
      // Set difference
    op "-="(var S : Ordered_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Ordered_Set; Right : Ordered_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|"   // union
    op "or="(var Left : Ordered_Set; Right : Ordered_Set) is "|="

    op "+"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Ordered_Set is "|"   // Union
    op "+="(var Left : Ordered_Set; Right : Ordered_Set) is "|="
    op "+="(var Left : Ordered_Set; Right : Element_Type) is "|="
   
    op "and"(Left, Right : Ordered_Set) -> Ordered_Set
	// Intersection
    op "and="(var Left : Ordered_Set; Right : Ordered_Set)

    op "xor"(Left, Right : Ordered_Set) -> Ordered_Set
	// Symmetric difference
    op "xor="(var Left : Ordered_Set; Right : Ordered_Set)

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean

    op "=?"(Left, Right : Ordered_Set) -> Ordering
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise

    func Is_Empty(S : Ordered_Set) -> Boolean

    func Lower_Bound(S : Ordered_Set) -> optional Element_Type
	// Lower bound of set
    func Lower_Bound_Is_Open(S : Ordered_Set) -> Boolean
	// Whether lower bound is "open" or "closed"

    func Upper_Bound(S : Ordered_Set) -> optional Element_Type
	// Upper bound of set
    func Upper_Bound_Is_Open(S : Ordered_Set) -> Boolean
	// Whether upper bound is "open" or "closed"

    func Remove_First(var S : Ordered_Set) -> optional Interval<Element_Type>
	// Remove first interval of set (lowest low bound)

    func Remove_Last(var S : Ordered_Set) -> optional Interval<Element_Type>
	// Remove last interval of set (highest high bound)

    func Remove_Any(var S : Ordered_Set) -> optional Interval<Element_Type>
	// Remove an arbitrary interval of set

end interface PSL::Containers::Ordered_Set

class PSL::Containers::Ordered_Set is

    type Element_Interval is Interval<Element_Type>

    var Items : optional AA_Tree<Element_Interval>

    func Remove_Interval(var S : Ordered_Set; Remove_IV : Element_Interval) is
      // Remove the given interval from the set, if present
	if Remove_IV.Low > Remove_IV.High then
	    // Nothing to remove
	    return
	end if

	  // Find an interval within the AA_Tree that overlaps
	for Remaining_IV := Remove_IV while Remaining_IV not null loop
	    // Get overlap, if any
	    var IV := Overlapping(S.Items, Remaining_IV)

	    if IV is null then
		// No overlap, nothing left to remove
		exit loop
	    end if
	
	    // Found an overlapping interval; delete it and add back what's left
	    Delete(S.Items, IV)
	    if Is_Strictly_Within(Remaining_IV, IV) then
		// Add back left and right remnants
		// Remaining_IV is fully subsumed.
		S.Items |= (Low => IV.Low, Low_Is_Open => IV.Low_Is_Open, 
		  High => Remaining_IV.Low, 
		  High_Is_Open => not Remaining_IV.Low_Is_Open)
		S.Items |= (Low => Remaining_IV.High, 
		  Low_Is_Open => not Remaining_IV.High_Is_Open,
		  High => IV.High, 
		  High_Is_Open => IV.High_Is_Open)
		// we are all done now
		exit loop
	    end if

	    // May be something left
	    const Overlap := IV and Remaining_IV
	    IV -= Overlap

	    if not Is_Empty(IV) then
		// Worth putting the interval back
		S.Items |= IV
	    end if

	    continue loop with Remaining_IV => Remaining_IV - Overlap

	end loop

    end func Remove_Interval

    func Is_Subset(Left, Right : Ordered_Set) -> Boolean is
	// Return True if Left is a subset of Right
	for Left_IV in Left loop
	    for Remaining_IV := Left_IV while not Is_Empty(Remaining_IV) loop
		const Right_IV := Overlapping(Right.Items, Remaining_IV)
		if Right_IV is null then
		    // Found some values that are not in Right
		    return #false
		end if

		// Loop around with what is left
		continue loop with Remaining_IV => Remaining_IV - Right_IV
	    end loop
	end loop
	// Everything in Left was found in Right
	return #true
    end func Is_Subset

  exports
    op "[]"() -> Ordered_Set is
        return (Items => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Ordered_Set is
	// Return a set consisting of a single element
	Result := []
	Result.Items |= Singleton(Elem)
    end func Singleton

    op ".."(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false, 
	      High => Right, High_Is_Open => #false)
        end if
    end op ".."
    
    op "<.."(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
	      High => Right, High_Is_Open => #false)
        end if
    end op "<.."
    
    op "<..<"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #true,
	      High => Right, High_Is_Open => #true)
        end if
    end op "<..<"
    
    op "..<"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #false,
	      High => Right, High_Is_Open => #true)
        end if
    end op "..<"
    
    op "|"(Left, Right : Element_Type) -> Result : Ordered_Set is
        Result := []
	Result |= Left
	if Left != Right then
	    Result |= Right
        end if
    end op "|"

    op "|"(Left : Ordered_Set; Right : Element_Type) 
      -> Result : Ordered_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Ordered_Set) -> Ordered_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Ordered_Set; Right : Ordered_Set) 
      -> Result : Ordered_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Ordered_Set; Right : Element_Type) is
        const Right_IV : Element_Interval := Singleton(Right)
        const Left_IV := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            // Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end op "|="

    op "<|="(var Left : Ordered_Set; var Right : optional Element_Type) is
        // Move element into set, leaving Right null afterward.
	// TBD: No copy minimization done at the moment
	Left |= Right
	Right := null
    end op "<|="

    op "|="(var Left : Ordered_Set; Right : Ordered_Set) is
        if Count(Left.Items) == 0 then
            Left := Right
        else
            // Make a copy of the Right set
            var Right_Copy for Left := Right

	    // Merge all of its intervals into Left
	    Left <|= Right_Copy
	end if
    end op "|="

    op "<|="(var Left : Ordered_Set; var Right : Ordered_Set) is
	// Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items
        else
            // Iterate through the tree
	    loop
		// Extract interval from Right
		var Right_IV for Left := Remove_Any(Right.Items)
		if Right_IV is null then
		    return
		end if

                // See whether it overlaps with an existing interval
                // in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
		    // Incorporate left interval into Right_IV
		    Right_IV |= Left_IV

		    if Right_IV == Left_IV then
			// Right_IV fully subsumed by existing interval
			Right_IV := null
			exit loop
		    end if

		    // Need to delete Left_IV 
		    Delete(Left.Items, Left_IV)

		    // Now see if there is anything still overlapping
		    Left_IV := Overlapping(Left.Items, Right_IV)
                end loop

                if not Is_Empty(Right_IV) then
                    // Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end op "<|="

    op "-"(Left, Right : Ordered_Set) -> Result : Ordered_Set is
      // Set difference
	Result := Left
	Result -= Right
    end op "-"

    op "-="(var S : Ordered_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
	Remove_Interval(S, Singleton(Elem))
    end op "-="

    op "-="(var Left : Ordered_Set; Right : Ordered_Set) is
      // Remove all intervals of Right from Left, if present
	for IV in Right loop
	    Remove_Interval(Left, IV)
	end loop
    end op "-="

    op "and"(Left, Right : Ordered_Set) -> Result : Ordered_Set is
	// Intersection

	// Add elements that are in both Right and Left into result
	Result := []
	for Right_IV in Right loop
	    for Remaining_IV := Right_IV while Remaining_IV not null loop
		var Left_IV := Overlapping(Left.Items, Remaining_IV)

		if Left_IV is null then
		    exit loop
		end if

		// Compute overlap, add into result, and then loop
		// around after removing it from Remaining_IV
		const Overlap := Remaining_IV and Left_IV

		Result.Items |= Overlap

		continue loop with Remaining_IV => Remaining_IV - Overlap
	    end loop
	end loop
    end op "and"

    op "and="(var Left : Ordered_Set; Right : Ordered_Set) is
	// Intersection
	Left := Left and Right
    end op "and="

    op "xor"(Left, Right : Ordered_Set) -> Ordered_Set is
	// Symmetric difference

	return (Left - Right) or (Right - Left)
    end op "xor"

    op "xor="(var Left : Ordered_Set; Right : Ordered_Set) is
	// Symmetric difference
	// Want elements that are only in one of the two inputs
	const Only_In_Right := Right - Left
	Left -= Right
	Left += Only_In_Right
    end op "xor="

    op "in"(Left : Element_Type; Right : Ordered_Set) -> Boolean is
        return Overlapping(Right.Items, Singleton(Left)) not null
    end op "in"

    op "=?"(Left, Right : Ordered_Set) -> Ordering is
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise
	if Is_Subset(Left, Right) then
	    if Is_Subset(Right, Left) then
		return #equal
	    else
		return #less
	    end if
	elsif Is_Subset(Right, Left) then
	    return #greater
	else
	    return #unordered
	end if
    end op "=?"

    func Is_Empty(S : Ordered_Set) -> Boolean is
        // Return count of items in set
	return Count(S.Items) == 0
    end func Is_Empty

    func Lower_Bound(S : Ordered_Set) -> optional Element_Type is
        const First_IV := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end func Lower_Bound

    func Lower_Bound_Is_Open(S : Ordered_Set) -> Boolean is
        const First_IV := First(S.Items)
        if First_IV is null then
            return #true   // TBD: or null?
        else
            return First_IV.Low_Is_Open
        end if
    end func Lower_Bound_Is_Open

    func Upper_Bound(S : Ordered_Set) -> optional Element_Type is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end func Upper_Bound

    func Upper_Bound_Is_Open(S : Ordered_Set) -> Boolean is
        const Last_IV := Last(S.Items)
        if Last_IV is null then
            return #true   // TBD: or null?
        else
            return Last_IV.High_Is_Open
        end if
    end func Upper_Bound_Is_Open

    func Remove_First(var S : Ordered_Set) 
      -> optional Interval<Element_Type> is
	// Remove first interval of set (lowest low bound)
	return Remove_First(S.Items)
    end func Remove_First

    func Remove_Last(var S : Ordered_Set) 
      -> optional Interval<Element_Type> is
	// Remove last interval of set (highest high bound)
	return Remove_Last(S.Items)
    end func Remove_Last

    func Remove_Any(var S : Ordered_Set) 
      -> optional Interval<Element_Type> is
	// Remove an arbitrary interval of set
	return Remove_Any(S.Items)
    end func Remove_Any

end class PSL::Containers::Ordered_Set

func PSL::Test::Test_Ordered_Set(A, X, Y, Z : Univ_Real) is
    var S : Ordered_Set<Univ_Real> := X | Y..Z
    Println(A | " in " | X | "|" | Y | ".." | Z | "=" | ( A in S ))

    const Agg : Ordered_Set<Univ_Real> := [X, Y, Z]
    const Or : Ordered_Set<Univ_Real> := Y | Z | X
    const Open_Ind : Map<Boolean, Univ_String> := [#false => "", #true => "<"]

    Println(" [X, Y, Z] =? (Y | Z | X) --> " | ( Agg =? Or ))

    S := []

    var R := 0.0
    for I in 1..10 forward loop
	R += 1.0
        S += R
        Println("Adding " | R | " to S, Is_Empty(S) = " | Is_Empty(S))
    end loop

    var Xor := S xor [2.0, 5.0, 12.0, 15.0]
    Print("S xor [2.0, 5.0, 12.0, 15.0] = ")
    for IV in Xor forward loop
	if IV.Low != IV.High then
	    Print(IV.Low | Open_Ind[IV.Low_Is_Open] | ".." | 
	      Open_Ind[IV.High_Is_Open] | IV.High | " ")
	else
            Print(IV.Low | " ")
	end if
    end loop
    Print('\n')
end func PSL::Test::Test_Ordered_Set

interface PSL::Core::Univ_Real<> is
    op "+"(Right : Univ_Real) -> Univ_Real
      is import(#identity)

    op "-"(Right : Univ_Real) -> Univ_Real
      is import(#real_negate)

    op "abs"(Right : Univ_Real) -> Univ_Real
      is import(#real_abs)

    op "magnitude"(Univ_Real) -> Univ_Real is "abs"

    op "+"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_add)

    op "-"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_subtract)

    op "*"(Left, Right : Univ_Real) -> Result : Univ_Real 
      is import(#real_multiply)

    op "*"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_int_multiply)

    op "*"(Left : Univ_Integer; Right : Univ_Real) -> Univ_Real

    op "/"(Left, Right : Univ_Real) -> Result : Univ_Real
      is import(#real_divide)

    op "/"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_int_divide)

    op "**"(Left : Univ_Real; Right : Univ_Integer) -> Univ_Real
      is import(#real_exp)

    op "+="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_add)

    op "-="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_subtract)

    op "*="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_multiply)

    op "/="(var Left : Univ_Real; Right : Univ_Real) 
      is import(#real_assign_divide)

    op "**="(var Left : Univ_Real; Right : Univ_Integer) 
      is import(#real_assign_exp)


    op "=?"(Left, Right : Univ_Real) -> Ordering
      is import(#real_compare)

    func Min(Left, Right : optional Univ_Real) -> optional Univ_Real
      is import(#real_min)
    func Max(Left, Right : optional Univ_Real) -> optional Univ_Real
      is import(#real_max)

    func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Univ_Real

    func Hash(Val : Univ_Real) -> Univ_Integer
      is import(#identity)

    func To_String(Val : Univ_Real) -> Univ_String
      is import(#to_string_real)

    func From_String(Str : Univ_String) -> optional Univ_Real
      is import(#from_string_real)

    func Print(X : Univ_Real) is import(#print_real)
    func Println(X : Univ_Real) is (Println(To_String(X)))

    func Round_To_Int(Real : Univ_Real) -> Univ_Integer
      is import(#round_to_int)

    func Int_To_Real(Int : Univ_Integer) -> Univ_Real
      is import(#int_to_real)

    op "in"(Left : Univ_Real; Right : Ordered_Set<Univ_Real>) -> Boolean
      is in Ordered_Set<Univ_Real>

end interface PSL::Core::Univ_Real

class PSL::Core::Univ_Real is
  exports
    op "*"(Left : Univ_Integer; Right : Univ_Real) -> Univ_Real is
        // Hand off to built-in real * int op
        return Right * Left
    end op "*"

    func Sqrt(Val : Univ_Real {Val >= 0.0}) -> Result : Univ_Real is
	{Val >= 0.0}
	Result := Val / 2.0
	while Result > 0.0 and then Result * Result / Val 
	  not in 0.9999999999999 .. 1.00000000000001 loop
	    Result := (Val / Result + Result)/2.0
	end loop
    end func Sqrt

end class PSL::Core::Univ_Real
    
func PSL::Test::Test_Real() is
    var X := 3.5
    var Y := 5.22
    var Z := X + Y

    Println("X = " | X | ", Y = " | Y | ", X + Y = " | Z)
    var Teeny := 0.000023
    Println("Teeny = " | Teeny)
    var Small := 0.005
    Println("Small = " | Small)
    var Medium := 235.123
    Println("Medium = " | Medium)
    var Big := 11.0**5
    Println("Big = " | Big)
    var Huge := 13.0**15
    Println("Huge = " | Huge)

    Println("Y in 1.0 .. 6.0 = " | ( Y in 1.0 .. 6.0 ))
    
    Println("Y in 1.0 ..< 5.22 = " | ( Y in 1.0 ..< 5.22 ))

    Println("Sqrt(2.0) = " | Sqrt(2.0))

    Println("Sqrt(-2.0) = " | Sqrt(-2.0))
end func PSL::Test::Test_Real

abstract interface PSL::Core::Indexable
  <Elem_Type is Assignable<>; Index_Type is Countable<>> is
    // An indexable container
    op "indexing"(ref A : Indexable; Index : Index_Type) -> ref Elem_Type
    func Length(A : Indexable) -> Univ_Integer
    op "magnitude"(Indexable) -> Univ_Integer is Length
    op "index_set"(A : Indexable) -> Countable_Range<Index_Type>
    func Bounds(A : Indexable) -> Countable_Range<Index_Type> is "index_set"
end interface PSL::Core::Indexable

interface PSL::Containers::Basic_Array<Element_Type is Assignable<>> is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
    func Create(Length : Univ_Integer<>; Val : optional Element_Type) 
      -> Basic_Array 
      is import(#basic_array_create)
    op "[]"() -> Basic_Array is (Create(0, null))
    op "indexing"(ref V : Basic_Array; Index : Univ_Integer<>) -> 
      ref Element_Type is import(#basic_array_indexing)
    op "var_indexing"(ref var V : Basic_Array; Index : Univ_Integer<>) -> 
      ref var Element_Type is import(#basic_array_indexing)
    func Length(V : Basic_Array) -> Univ_Integer<>
      is import(#basic_array_length)
    op "magnitude"(Basic_Array) -> Univ_Integer<> is Length
    op "|"(Left, Right : Basic_Array) -> Basic_Array
    op "index_set"(A : Basic_Array) -> Countable_Range<Univ_Integer>
    op "<|="(var Left : Basic_Array; var Right : optional Element_Type)
end interface PSL::Containers::Basic_Array

class PSL::Containers::Basic_Array is
  // Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
  exports
    op "|"(Left, Right : Basic_Array) -> Result : Basic_Array is
        const Left_Len := Length(Left)

        if Left_Len == 0 then
            return Right
        end if

        Result := Create(Left_Len + Length(Right), null)

        // Copy the Left elements
        for I in 1..Left_Len concurrent loop
            Result[I] := Left[I]
        end loop

        // Copy the Right elements
        
        for J in 1..Length(Right) concurrent loop
            Result[Left_Len + J] := Right[J]
        end loop
    end op "|"
            
    op "index_set"(A : Basic_Array) -> Countable_Range<Univ_Integer> is
	return 1..Length(A)
    end op "index_set"

    op "<|="(var Left : Basic_Array; var Right : optional Element_Type) is
        const Left_Len := |Left|
        var Result : Basic_Array for Left := Create(Left_Len+1, null)

        for I in 1 .. Left_Len concurrent loop
            Result[I] <== Left[I]
        end loop

        Result[Left_Len+1] <== Right

        Left <== Result
    end op "<|="
end class PSL::Containers::Basic_Array

func PSL::Test::Test_Basic_Array() is
    var A : Basic_Array<Univ_Integer<>> := Create(3, 7)
    A[1] := 42
    A[2] += 6
    A[3] += A[2]
    Print("The answer is: " | A[1] + A[2] + A[3] | "\n")
    Print("Length(A) = " | Length(A) | "\n")

    var B := A | A
    Print("Length(B) = " | Length(B) | ", B[5] = " | B[5] | "\n")
    for I in 1..Length(B) forward loop
        Print("B[" | I | "] = " | B[I] | ", ")
    end loop
    Print("\n")

    const C : Basic_Array<Univ_Integer> := [1, 3, 5, 7];
    Print("C = [")
    for each [I => E] of C forward loop
        Print((I > 1? ", " : "") | E)
    end loop
    Println("]")
    Println("|C| = " | |C|)
end func PSL::Test::Test_Basic_Array
    
interface PSL::Core::Vector<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Extendable vector, indexed by Univ_Integer, 1..Length
    op "[]"() -> Vector
    func Create(Length : Univ_Integer; Value : Element_Type) -> Vector
    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type
    op "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      -> Vector  // a "read-only" slice
    op "index_set"(V : Vector) -> Countable_Range<Univ_Integer>
    func Bounds(V : Vector) -> Countable_Range<Univ_Integer> is "index_set"
    op "|="(var V : Vector; Elem : Element_Type)
    op "|="(var V : Vector; Right : Vector)
    op "<|="(var V : Vector; var Elem : optional Element_Type)
    op "|"(Left, Right : Vector) -> Vector
    op "|"(Left : Vector; Right : Element_Type) -> Vector
    func Length(V : Vector) -> Univ_Integer
    op "magnitude"(Vector) -> Univ_Integer is Length
end interface PSL::Core::Vector
    
class PSL::Core::Vector is
  // Extendable vector, indexed by Univ_Integer, 1..Length
    const Initial_Size := 4
    var Count : Univ_Integer := 0
    var Data : optional Basic_Array<optional Element_Type>

    func Expand_By_One(var V : Vector) is
        // Expand size by one
        if V.Data is null then
            V.Data := Create(Initial_Size, null)
        elsif V.Count == Length(V.Data) then
            // Double the size
            var Old_Data <== V.Data
            V.Data := Create(2*V.Count, null)
            for I in 1..V.Count loop
                V.Data[I] <== Old_Data[I]
            end loop
            Old_Data := null
        end if
        V.Count += 1
    end func Expand_By_One

    func Expand_Count(var V : Vector; New_Count : Univ_Integer) is
        // Expand count to new count, putting nulls in new slots
        if V.Data is null then
            V.Data := Create(Max(New_Count, Initial_Size), null)
        elsif Length(V.Data) < New_Count then
            var Old_Data <== V.Data
            V.Data := Create(Max(New_Count, 2*Length(Old_Data)), null)
            for I in 1..V.Count loop
                V.Data[I] := Old_Data[I]
            end loop
            Old_Data := null
        end if
        V.Count := New_Count
    end func Expand_Count

  exports
    op "[]"() -> Vector is
        return (Count => 0, Data => null)
    end op "[]"

    func Create(Length : Univ_Integer; Value : Element_Type) -> Vector is
        return (Count => Length, Data => Create (Length, Value))
    end func Create

    func Length(V : Vector) -> Univ_Integer is
        return V.Count
    end func Length

    op "indexing"(ref V : Vector; Index : Univ_Integer) -> 
      ref Element_Type is
        {*vector_index_out_of_bounds* Index in 1..V.Count}
        return V.Data[Index]
    end op "indexing"

    op "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      -> Vector is
      // a "read-only" slice
        return [for I in Index_Set => V[I]]
    end op "slicing"

    op "index_set"(V : Vector) -> Countable_Range<Univ_Integer> is
        return 1..Length(V)
    end op "index_set"

    op "<|="(var V : Vector; var Elem : optional Element_Type) is
        Expand_By_One(V)
        V.Data[V.Count] <== Elem
    end op "<|="

    op "|="(var V : Vector; Elem : Element_Type) is
        Expand_By_One(V)
        V.Data[V.Count] := Elem
    end op "|="
    
    op "|="(var V : Vector; Right : Vector) is
        const Orig_Count := V.Count
        if Orig_Count == 0 then
            // Just copy right
            V := Right;
        else
            // Grow V, and then copy in Right
            Expand_Count(V, V.Count + Right.Count)
            for I in 1..Right.Count loop
                V[I+Orig_Count] := Right[I]
            end loop
        end if
    end op "|="

    op "|"(Left, Right : Vector) -> Result : Vector is
        // Copy left into result, and then add in the Right elements
        if Left.Count == 0 then
            // Left is null vector; result is determined by Right
            Result := Right
        else
            // Start with Left
            Result := Left
            Result |= Right
        end if
    end op "|"

    op "|"(Left : Vector; Right : Element_Type) -> Result : Vector is
        Result := Left
        Result |= Right
    end op "|"

end class PSL::Core::Vector

func PSL::Test::Test_Vector() is
    var V : Vector<Univ_Integer> := []
    var U : Vector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " | V[1] | ", " | V[2])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 1..Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    Println("\"indexing\"(V, 12) := 33;")
    "indexing"(V, 12) := 33
    for I in 1..Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 1..Length(Slice) forward loop
        Println("Slice[" | I | "] = " | Slice[I])
    end loop
end func PSL::Test::Test_Vector

interface PSL::Core::ZVector<Element_Type is Assignable<>> 
  implements Indexable<Element_Type, Univ_Integer> is
  // Extendable vector, indexed by Univ_Integer, 0..Length-1
    op "[]"() -> ZVector
    func Create(Length : Univ_Integer; Value : Element_Type) -> ZVector
    op "indexing"(ref V : ZVector; Index : Univ_Integer) -> 
      ref Element_Type
    op "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      -> ZVector
      // a "read-only" slice
    op "index_set"(V : ZVector) -> Countable_Range<Univ_Integer>
    op "|="(var V : ZVector; Elem : Element_Type)
    op "<|="(var V : ZVector; var Elem : optional Element_Type)
    op "|"(Left, Right : ZVector) -> ZVector
    func Length(V : ZVector) -> Univ_Integer
    op "magnitude"(ZVector) -> Univ_Integer is Length
end interface PSL::Core::ZVector
    
class PSL::Core::ZVector is
  // Extendable ZVector, indexed by Univ_Integer, 0..Length-1
    var Vec : Vector<Element_Type>

  exports
    op "[]"() -> ZVector is
        return (Vec => [])
    end op "[]"

    func Create(Length : Univ_Integer; Value : Element_Type) -> ZVector is
        return (Vec => Create(Length, Value))
    end func Create

    func Length(V : ZVector) -> Univ_Integer is
        return Length(V.Vec)
    end func Length

    op "indexing"(ref V : ZVector; Index : Univ_Integer) -> 
      ref Element_Type is
        {Index in 0..<Length(V.Vec)}  // Index out of bounds
        return V.Vec[Index+1]
    end op "indexing"

    op "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      -> ZVector is
      // a "read-only" slice
        return [for I in Index_Set => V[I]]
    end op "slicing"

    op "index_set"(V : ZVector) -> Countable_Range<Univ_Integer> is
        return 0..<Length(V.Vec)
    end op "index_set"

    op "<|="(var V : ZVector; var Elem : optional Element_Type) is
        V.Vec <|= Elem
    end op "<|="

    op "|="(var V : ZVector; Elem : Element_Type) is
        V.Vec |= Elem
    end op "|="
    
    op "|"(Left, Right : ZVector) -> Result : ZVector is
        return (Vec => Left.Vec | Right.Vec)
    end op "|"

end class PSL::Core::ZVector

func PSL::Test::Test_ZVector() is
    var V : ZVector<Univ_Integer> := []
    var U : ZVector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " | V[0] | ", " | V[1])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 0..<Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    Println("\"indexing\"(V, 11) := 33;")
    "indexing"(V, 11) := 33
    for I in 0..<Length(V) forward loop
        Println("V[" | I | "] = " | V[I])
    end loop
    const Slice := V[3..7]
    Println("Slice := V[3..7]")
    for I in 0..<Length(Slice) forward loop
        Println("Slice[" | I | "] = " | Slice[I])
    end loop
end func PSL::Test::Test_ZVector

interface PSL::Core::ZString<> is
  // A universal string with characters indexed starting at 0
    op "from_univ"(Univ : Univ_String) -> ZString
      is import(#identity)
    op "to_univ"(ZStr : ZString) -> Univ_String
      is import(#identity)

    func Print(ZString) is import(#print_string)
    func Println(ZString) is import(#println_string)
    func Readln() -> optional ZString is import(#read_string)

    op "*"(Left : Univ_Integer; Right : ZString) -> ZString
	// Produce specified number of "Right" strings in a row
    op "*"(Left : ZString; Right : Univ_Integer) -> ZString
	// Produce specified number of "Left" strings in a row

    op "|"(Left, Right : ZString) -> ZString 
      is import(#concat_string)

    op "=?"(Left, Right : ZString) -> Ordering
      is import(#string_compare)

    op "|="(var Left : ZString; Right : ZString)
      is import(#assign_concat_string)

    op "indexing"(Str : ZString; Index : Univ_Integer<>) -> Univ_Character
	// a "read-only" element, indexed 0..<Length(Str)

    op "index_set"(Str : ZString) -> Countable_Range<Univ_Integer>
        // Return set of indices for string

    op "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> ZString
	// a "read-only" slice

    func Length(Str : ZString) -> Univ_Integer
      is import(#string_length)

    op "magnitude"(ZString) -> Univ_Integer is Length

    func Hash(Val : ZString) -> Univ_Integer
      is import(#identity)

    op "|"(Left : ZString; Right : Right_Type is Imageable<>) 
      -> ZString

    op "|"(Left : Left_Type is Imageable<>; Right : ZString)
      -> ZString

    op "|="(var Left : ZString; Right : Right_Type is Imageable<>)

    // Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) -> ZVector<Univ_Character>
    func From_ZVector(Vec : ZVector<Univ_Character>) -> ZString
      is import(#string_from_vector)

end interface PSL::Core::ZString
    
class PSL::Core::ZString is
  // A universal string with characters indexed starting at 0
    var U_Str : Univ_String

  exports
    op "indexing"(Str : ZString; Index : Univ_Integer<>) -> Univ_Character is
	// a "read-only" element, indexed 0..<Length(Str)
        return Str.U_Str[Index+1]
    end op "indexing"

    op "index_set"(Str : ZString) -> Countable_Range<Univ_Integer> is
        // Return set of indices for string
        return 0 ..< |Str.U_Str|
    end op "index_set"

    op "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      -> ZString is
	// a "read-only" slice
        return (U_Str => Str.U_Str[Index_Set.First <.. Index_Set.Last+1])
    end op "slicing"

    op "*"(Left : Univ_Integer; Right : ZString) -> ZString is
	// Produce specified number of "Right" strings in a row
        return (U_Str => Left * Right.U_Str)
    end op "*"

    op "*"(Left : ZString; Right : Univ_Integer) -> ZString is
	// Produce specified number of "Left" strings in a row
	return Right * Left   // Just pass the buck to other "*"
    end op "*"

    op "|"(Left : ZString; Right : Right_Type is Imageable<>) 
      -> ZString is
        if Right is null then
            return (U_Str => Left.U_Str | "null")
        else
            return (U_Str => Left.U_Str | Right_Type::To_String(Right))
        end if
    end op "|"

    op "|"(Left : Left_Type is Imageable<>; Right : ZString)
      -> ZString is
        if Left is null then
            return (U_Str => "null" | Right.U_Str)
        else
            return (U_Str => Left_Type::To_String(Left) | Right.U_Str)
        end if
    end op "|"

    op "|="(var Left : ZString; Right : Right_Type is Imageable<>) is
        if Right is null then
            Left.U_Str |= "null"
        else
            Left.U_Str |= Right_Type::To_String(Right)
        end if
    end op "|="

    // Operations to convert to/from a ZVector of Univ_Character's
    func To_ZVector(Str : ZString) -> ZVector<Univ_Character> is
        return [for I in 0..<Length(Str) => Str[I]]
    end func To_ZVector

end class PSL::Core::ZString

func PSL::Test::Test_ZString() is
    const U : ZString := "tab\t"
    const T := U[3]
    Println("U = " | U | ", Length(U) = " | Length(U) | ", U[4] = '" | T | "'")
    const X : ZString := "this is a string"
    const Y := X[2]
    {Y == 'i'} // string indexing problem
    const Z := X[5..6]
    {Z == "is"} // string slicing problem, expected 'is', found Z 
    Println("X = " | X | ", X[2] = " | Y | ", X[5..6] = " | Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " | "hello")

    const Seven_Xs :ZString := "x" * 7
    {Seven_Xs == "xxxxxxx"} // Char multiplication check

    Println("Here are seven x's: " | Seven_Xs)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)
end func PSL::Test::Test_ZString

interface PSL::Containers::Slice<Array_Type is Indexable<>> is
  // A sliceable array.
    const First : Array_Type::Index_Type
    const Last : Array_Type::Index_Type

    func Length(S : Slice) -> Univ_Integer
        // Return length of slice (i.e. Last - First + 1)

    op "magnitude"(Slice) -> Univ_Integer is Length
        // Allows use of |...| operator

    op "slicing"(ref A : Array_Type) -> ref Slice
        // Convert an array into a slice covering 1..Length(A)

    op "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice
        // Slice of an array

    op "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice
        // Slice of a slice

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type
        // Index into a slice

    op "index_set"(S : Slice) -> Countable_Range<Array_Type::Index_Type>
end interface PSL::Containers::Slice

class PSL::Containers::Slice is
    ref Arr : Array_Type
  exports
    func Length(S : Slice) -> Univ_Integer is
        // Return length of slice (i.e. Last - First + 1)
        return S.Last - S.First + 1
    end func Length

    op "slicing"(ref A : Array_Type) -> ref Slice is
        // Convert an array into a slice covering whole array
        const A_Bounds := "index_set"(A)
        return (First => A_Bounds.First, Last => A_Bounds.Last, Arr => A)
    end op "slicing"

    op "slicing"(ref A : Array_Type;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of an array
        const A_Bounds := "index_set"(A)
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= A_Bounds.First and then 
            Bounds.Last <= A_Bounds.Last)} //slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => A)
    end op "slicing"

    op "slicing"(ref S : Slice;
      Bounds : Countable_Range<Array_Type::Index_Type>)
      -> ref Slice is
        // Slice of a slice
        {Bounds.First > Bounds.Last or else 
          (Bounds.First >= S.First and then Bounds.Last <= S.Last)}
          // slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => S.Arr)
    end op "slicing"

    op "indexing"(ref S : Slice; Index : Array_Type::Index_Type) 
      -> ref Array_Type::Elem_Type is
        // Index into a slice
        {Index >= S.First and then Index <= S.Last}
          // array index out of bounds
        return S.Arr[Index]
    end op "indexing"
    
    op "index_set"(S : Slice) -> Countable_Range<Array_Type::Index_Type> is
        return S.First .. S.Last
    end op "index_set"
end class PSL::Containers::Slice

interface PSL::Core::Enum<Literals : Vector<Univ_Enumeration>> is
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit == Univ)}
      -> Enum
    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)}

    op "=?"(Left, Right : Enum) -> Ordering
      is import("=?")

    // Functions for Imageable
    func To_String(Val : Enum) -> Univ_String
    func From_String(Str : Univ_String) -> optional Enum

    // Operators for Countable
    op "+"(Left : Univ_Integer; Right : Enum) -> Enum 
      is import("+")
    op "+"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("+")
    op "-"(Left, Right : Enum) -> Univ_Integer 
      is import("-")
    op "-"(Left : Enum; Right : Univ_Integer) -> Enum 
      is import("-")

    // TBD: These should be properties some day (e.g. Color#first).
    func First()->Enum
    func Last()->Enum
    func Range()->Countable_Range<Enum> is "[..]" in Countable_Range<Enum>

    op "[..]"() -> Countable_Range<Enum> is in Countable_Range<Enum>

    func Hash(Val : Enum) -> Univ_Integer
      is import(#identity)

    op ".."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "<.."(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "<..<"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>
    op "|"(Left, Right : Enum) -> Countable_Set<Enum>
      is in Countable_Set<Enum>

    func Min(Left, Right : optional Enum) -> optional Enum
      is import(#min)
    func Max(Left, Right : optional Enum) -> optional Enum
      is import(#max)
end interface PSL::Core::Enum

class PSL::Core::Enum is
    const Value : Univ_Integer
  exports
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some Lit of Literals => Lit == Univ)}
      -> Enum is
        for I in 1 .. |Literals| loop
            if Literals[I] == Univ then
                return (Value => I-1)
            end if
        end loop
	{*bad_enum_literal* #false}
        return null
    end op "from_univ"

    op "to_univ"(Val : optional Enum) -> Result : optional Univ_Enumeration
      {Result is null or else (for some Lit of Literals => Lit == Result)} is
	if Val is null then
	    return null
	else
	    return Literals[Val.Value+1]
	end if
    end op "to_univ"

    // Functions for Imageable
    func To_String(Val : Enum) -> Univ_String is
	return Univ_Enumeration::To_String([[Val]])
    end func To_String

    func From_String(Str : Univ_String) -> optional Enum is
	return Univ_Enumeration::From_String(Str)
    end func From_String

    func First()->Enum is
        return (Value => 0)
    end func First

    func Last()->Enum is
        return (Value => |Literals| - 1)
    end func Last

end class PSL::Core::Enum

func PSL::Test::Test_Enum() is
    type Color is Enum< [#red, #green, #blue] >
    type Day_Of_Week is 
       Enum< [#Monday, #Tuesday, #Wednesday, #Thursday, 
        #Friday, #Saturday, #Sunday] >

    for C : Color in Color::First() .. Color::Last() forward loop
        Println("Next color = " | C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " | C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " | D3)
    end loop

    {#Monday in Day_Of_Week}

end func PSL::Test::Test_Enum

interface PSL::Containers::Map
  <Key_Type is Hashable<>; Value_Type is Assignable<>> is
  // A hashed-map module
    type Pair is Key_Value<Key_Type, Value_Type>

    op "[]"() -> Map

    op "|="(var Left : Map; Right : Pair)
	// Add Key=>Value to Map, replacing pre-existing mapping
	// for Key, if any.

    op "|"(Left : Map; Right : Pair) -> Map
	// Add Key=>Value to Map, replacing pre-existing mapping
	// for Key, if any in result.

    op "<|="(var Left : Map; var Right : optional Pair)
	// Move Key/Value pair into map, leaving Right null

    op "<|="(var Left : Map; var Right : Map)
	// Move key/value pairs from Right into Left, leaving Right empty,
	// replacing any pre-existing entries with the same key.

    op "+="(var Left : Map; Right : Pair) is "|="
	// A synonym for adding a key=>value pair

    op "in"(Left : Key_Type; Right : Map) -> Boolean
	// Return True if given key has a mapping in the Map

    op "-="(var M : Map; Key : Key_Type)   // aka Exclude
	// Remove mapping for Right, if present

    op "index_set"(M : Map) -> Set<Key_Type>
	// Return set of keys with mappings

    func Keys(M : Map) -> Set<Key_Type> is "index_set"

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type
	// Used for references to M[Key]; requires the Key to be in M.

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type
	// Used for assignments to M[Key]; Key is added to M if not present

    func Remove_Any(var M : Map) -> optional Pair
	// Remove one mapping from the Map.  Return null if Map is empty

    func Count(M : Map) -> Univ_Integer
	// Number of mappings in the table

    op "magnitude"(Map) -> Univ_Integer is Count

    func Is_Empty(M : Map) -> Boolean
	// Return True if no mappings in the table

    func Dump_Statistics(M : Map)
      // A debugging routine to show bucket sizes of Map

end interface PSL::Containers::Map

class PSL::Containers::Map is
  // A hashed-map module

    var Data : Basic_Map<Key_Value<Key_Type, Value_Type>>

  exports
    op "[]"() -> Map is
        return (Data => [])
    end op "[]"

    op "|"(Left : Map; Right : Pair) -> Result : Map is
	// Add Key=>Value to Map, replacing pre-existing mapping
	// for Key, if any in result.
        Result := Left
        Result.Data |= Right
    end op "|"

    op "|="(var Left : Map; Right : Pair) is
	// Add Key=>Value to Map, replacing pre-existing mapping
	// for Key, if any.
	Left.Data |= Right
    end op "|="

    op "<|="(var Left : Map; var Right : optional Pair) is
	// Move Key/Value pair into map, leaving Right null
	Left.Data <|= Right
    end op "<|="

    op "<|="(var Left : Map; var Right : Map) is
	// Move key/value pairs from Right into Left, leaving Right empty,
	// replacing any pre-existing entries with the same key.
	loop
	    var Right_Elem for Left := Remove_Any(Right)
	    if Right_Elem is null then
		return   // All done
	    end if

	    Left.Data <|= Right_Elem
	end loop
    end op "<|="

    op "in"(Left : Key_Type; Right : Map) -> Boolean is
	return Left in Right.Data
    end op "in"

    op "-="(var M : Map; Key : Key_Type) is
      // Remove the given key from the Map, if present
	M.Data -= Key
    end op "-="
   
    op "index_set"(M : Map) -> Result : Set<Key_Type> is
	// Return set of keys with non-null mappings
        if M.Data is null then
            return []
        else
           return "index_set"(M.Data)
        end if
    end op "index_set"

    op "indexing"(ref M : Map; Key : Key_Type) {Key in M} -> ref Value_Type is
	// Used for references to M[Key]; requires the Key to be in M.
	return M.Data[Key].Value
    end op "indexing"

    op "var_indexing"(ref var M : Map; Key : Key_Type) 
      -> ref var optional Value_Type is
	// Used for assignments to M[Key]; Key is added to M if not present
	return "var_indexing"(M.Data, Key).Value
    end op "var_indexing"

    func Count(M : Map) -> Univ_Integer is
	return Count(M.Data)
    end func Count

    func Is_Empty(M : Map) -> Boolean is
	// Return True if no mappings in the table
	return Is_Empty(M.Data)
    end func Is_Empty

    func Remove_Any(var M : Map) -> Result : optional Pair is
	return Remove_Any(M.Data)
    end func Remove_Any

    func Dump_Statistics(M : Map) is
      // A debugging routine to show bucket sizes of Map
	Dump_Statistics(M.Data)
    end func Dump_Statistics

end class PSL::Containers::Map

func PSL::Test::Test_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    type Enum_String_Map is Map<Univ_Enumeration, Univ_String>

    var M : Enum_String_Map := [X => Y, A => B]

    Println("Count = " | Count(M))

    for each [K => V] of M loop
	Println("Mapping " | K | " => " | V)
	Println(K | " in M = " | (K in M))
    end loop

    Println("#xy in M = " | (#xy in M))

    M |= [X => null]

    Println("Count after deletion = " | Count(M))

    for each [K => V] of M loop
	Println("Mapping " | K | " => " | V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " | Count(M))

    for each [K => V] of M loop
	Println("Mapping " | K | " => " | V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " | Count(M))

    for each [K => V] of M loop
	Println("Mapping " | K | " => " | V)
    end loop

    M -= A

    Println("Count after deletion = " | Count(M))

    for each [K => V] of M loop
	Println("Mapping " | K | " => " | V)
    end loop

    var Ran := Random::Start(Hash(A))
    var MUI : Map<Univ_Integer, Univ_Integer> := []

    Println("Adding 100 random pairings to Map.")
    for I in 1..100 loop
	const Key := Next(Ran) mod 100
	const Value := Next(Ran) mod 100
	MUI[Key] := Value
    end loop
    Println("Map is now of count = " | Count(MUI))

    for each [K => V] of MUI loop
	Println("Mapping " | K | " => " | V)
	Println("MUI[" | K | "] = " | MUI[K])
    end loop

    for (Pair in MUI; I in 1..60 forward) loop
	Print(" [" | Pair.Key | " => " | Pair.Value | "]")
	if I mod 5 == 0 then
	    Print('\n')
	end if
    end loop

    if Count(MUI) > 60 then
	Println(" ...")
    elsif Count(MUI) mod 5 != 0 then
	Print('\n')
    end if

end func PSL::Test::Test_Map

interface PSL::Containers::Two_Way_Map
  <Key_Type is Imageable<>; Value_Type is Imageable<>>   // TBD: use Hashable
  extends Forward : Map<Key_Type, Value_Type> is
    type Pair2 is Key_Value<Key_Type, Value_Type>

    op "[]"() -> Two_Way_Map

    op "|="(var Left : Two_Way_Map; Right : Pair2)
	// Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
	// for Key, if any.

    op "|"(Left : Two_Way_Map; Right : Pair2) -> Two_Way_Map
	// Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
	// for Key, if any in result.

    op "<|="(var Left : Two_Way_Map; var Right : optional Pair2)
	// Move Key/Value pair into Two_Way_map, leaving Right null

    op "<|="(var Left : Two_Way_Map; var Right : Two_Way_Map)
	// Move key/value pairs from Right into Left, leaving Right empty,
	// replacing any pre-existing entries with the same key.

    op "-="(var M : Two_Way_Map; Key : Key_Type)   // aka Exclude
	// Remove mapping for Right, if present

    op "var_indexing"(ref var M : Two_Way_Map; Key : Key_Type) 
      -> ref var optional Value_Type
	// Used for assignments to M[Key]; Key is added to M if not present

    func Key_Of (M : Two_Way_Map; Value : Value_Type) -> optional Key_Type
        // Use reverse mapping to determine key given value

    func Rev_Map (M : Two_Way_Map) -> Map<Value_Type, Key_Type>
        // Return a copy of the reverse map

end interface PSL::Containers::Two_Way_Map

class PSL::Containers::Two_Way_Map is
    var Reverse : Map<Value_Type, Key_Type>
    var Unreversed : Set<Key_Type>  //  Keys not yet in Reverse map

    func Add_Unreversed(var M : Two_Way_Map) is
      //  Add Unreversed Keys into M.Reverse
        while not Is_Empty (M.Unreversed) loop
            var Key := Remove_Any(M.Unreversed)
            M.Reverse |= [M.Forward[Key] => Key]
        end loop
    end func Add_Unreversed

  exports

    op "[]"() -> Two_Way_Map is
        return (Forward => [], Reverse => [], Unreversed => [])
    end op "[]"

    op "|="(var Left : Two_Way_Map; Right : Pair2) is
	// Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
	// for Key, if any.
        Add_Unreversed (Left)
        Left.Forward |= Right
        Left.Reverse |= [Right.Value => Right.Key]
    end op "|="

    op "|"(Left : Two_Way_Map; Right : Pair2) -> Result : Two_Way_Map is
	// Add Key=>Value to Two_Way_Map, replacing pre-existing mapping
	// for Key, if any in result.
        Result := Left
        Add_Unreversed (Result)
        Result |= Right
    end op "|"

    op "<|="(var Left : Two_Way_Map; var Right : optional Pair2) is
	// Move Key/Value pair into Two_Way_map, leaving Right null
        Add_Unreversed (Left)
        Left.Reverse |= [Right.Value => Right.Key]
        Left.Forward <|= Right
    end op "<|="

    op "<|="(var Left : Two_Way_Map; var Right : Two_Way_Map) is
	// Move key/value pairs from Right into Left, leaving Right empty,
	// replacing any pre-existing entries with the same key.
        Add_Unreversed (Left)
        loop
            var KV := Remove_Any(Right)
            if KV is null then
                exit loop
            end if
            Left <|= KV
        end loop
    end op "<|="

    op "-="(var M : Two_Way_Map; Key : Key_Type) is   // aka Exclude
	// Remove mapping for Right, if present
        Add_Unreversed (M)
        if Key in M.Forward then
           M.Reverse -= M.Forward[Key]
           M.Forward -= Key
        end if
    end op "-="

    op "var_indexing"(ref var M : Two_Way_Map; Key : Key_Type) 
      -> ref var optional Value_Type is
	// Used for assignments to M[Key]; Key is added to M if not present
        Add_Unreversed (M)
        if Key not in M then
            //  Don't have value of Key so can't add to M.Reverse yet
            M.Unreversed |= Key
        end if
	return "var_indexing"(M.Forward, Key)
    end op "var_indexing"

    func Key_Of (M : Two_Way_Map; Value : Value_Type) -> optional Key_Type is
        // Use reverse mapping to determine key given value
        if Value in M.Reverse then
           // Found in reverse mapping
           return M.Reverse[Value]
        else
           // Search through Unreversed keys
           for K in M.Unreversed loop
               if M.Forward[K] == Value then
                   return K
               end if
           end loop
           // Not there
           return null
        end if
    end func Key_Of

    func Rev_Map (M : Two_Way_Map) -> Result : Map<Value_Type, Key_Type> is
        // Return a copy of the reverse map, after adding the unreversed keys
        var Copy for Result := M;
        Add_Unreversed (Copy)
        
        Result <== Copy.Reverse
        Copy := null
    end func Rev_Map

end class PSL::Containers::Two_Way_Map

interface PSL::Core::Float<Digits : Univ_Integer := 15> is
  // A floating point type that provides at least the
  // given number of digits of precision.

    op "from_univ"(Univ : Univ_Real) -> Float
      is import(#identity)

    op "to_univ"(Val : Float) -> Univ_Real
      is import(#identity)

    op "+"(Right : Float) -> Float
      is import(#identity)

    op "-"(Right : Float) -> Float
      is import(#real_negate)

    op "abs"(Right : Float) -> Float
      is import(#real_abs)

    op "magnitude"(Float) -> Float is "abs"

    op "+"(Left, Right : Float) -> Result : Float 
      is import(#real_add)

    op "-"(Left, Right : Float) -> Result : Float
      is import(#real_subtract)

    op "*"(Left, Right : Float) -> Result : Float 
      is import(#real_multiply)

    op "*"(Left : Float; Right : Univ_Integer) -> Result : Float 
      is import(#real_int_multiply)

    op "*"(Left : Univ_Integer; Right : Float) -> Result : Float

    op "/"(Left, Right : Float) -> Result : Float
      is import(#real_divide)

    op "/"(Left : Float; Right : Univ_Integer) -> Result : Float
      is import(#real_int_divide)

    op "**"(Left : Float; Right : Univ_Integer) -> Float
      is import(#real_exp)

    op "+="(var Left : Float; Right : Float) 
      is import(#real_assign_add)

    op "-="(var Left : Float; Right : Float) 
      is import(#real_assign_subtract)

    op "*="(var Left : Float; Right : Float) 
      is import(#real_assign_multiply)

    op "/="(var Left : Float; Right : Float) 
      is import(#real_assign_divide)

    op "**="(var Left : Float; Right : Univ_Integer) 
      is import(#real_assign_exp)


    op "=?"(Left, Right : Float) -> Ordering
      is import(#real_compare)

    func Min(Left, Right : optional Float) -> optional Float
      is import(#real_min)
    func Max(Left, Right : optional Float) -> optional Float
      is import(#real_max)

    func Hash(Val : Float) -> Univ_Integer
      is import(#identity)

    func Round_To_Int(Val : Float) -> Univ_Integer
      is import(#round_to_int)

    func Int_To_Float(Int : Univ_Integer) -> Float
      is import(#int_to_real)

    func To_String(Val : Float) -> Univ_String
      is import(#to_string_real)

    func From_String(Str : Univ_String) -> optional Float
      is import(#from_string_real)

    func Print(X : Float) is import(#print_real)
    func Println(X : Float) is (Println(To_String(X)))

    op "in"(Left : Float; Right : Ordered_Set<Float>) -> Boolean
      is in Ordered_Set<Float>
	// "in" defined in Ordered_Set

    
end interface PSL::Core::Float

class PSL::Core::Float is
    const Value : Univ_Real
  exports
    op "*"(Left : Univ_Integer; Right : Float) -> Result : Float is
        // Hand off to built-in real*int op
        return Right * Left
    end op "*"
end class PSL::Core::Float
    
func PSL::Test::Test_Float() is
    type My_Float is Float<Digits => 8>

    var X : My_Float := 3.5
    var Y : My_Float := 5.22
    var Z : My_Float := X + Y

    Println("X = " | X | ", Y = " | Y | ", X + Y = " | Z)
    var Teeny := 0.000023
    Println("Teeny = " | Teeny)
    var Small := 0.005
    Println("Small = " | Small)
    var Medium := 235.123
    Println("Medium = " | Medium)
    var Big := 11.0**5
    Println("Big = " | Big)
    var Huge := 13.0**15
    Println("Huge = " | Huge)

    var X2 : My_Float := 3.5 * 2

    Println("X * 2 = " | X * 2 | ", 2 * X = " | 2 * X | ", X2 = " | X2)
    Println("X / 2 = " | X / 2 )

    if X in 1.5 ..< 3.6 then
	Println("X *is* in 1.5 ..< 3.6")
    else
	Println("X *not* in 1.5 ..< 3.6??")
    end if

    Println("X in 1.5 ..< 3.5 = " | (X in 1.5 ..< 3.5) )
end func PSL::Test::Test_Float

interface PSL::Core::Fixed<Delta : Univ_Real> is
  // Fixed point types, represented as an integer
  // multiple of the given Delta
    op "from_univ"(Univ : Univ_Real) -> Fixed
    op "to_univ"(Val : optional Fixed) -> optional Univ_Real

    op "+"(Right : Fixed) -> Fixed
      is import(#identity)

    op "-"(Right : Fixed) -> Fixed
      is import(#negate)

    op "abs"(Right : Fixed) -> Fixed
      is import("abs")

    op "magnitude"(Fixed) -> Fixed is "abs"

    op "+"(Left, Right : Fixed) -> Fixed
      is import("+")
    op "-"(Left, Right : Fixed) -> Fixed
      is import("-")
    op "*"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_mul)
    op "*"(Left : Univ_Real; Right : Fixed) -> Fixed
      is import(#real_fixed_mul)
    op "*"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("*")
    op "*"(Left : Univ_Integer; Right : Fixed) -> Fixed
      is import("*")
    op "/"(Left : Fixed; Right : Univ_Real) -> Fixed
      is import(#fixed_real_div)
    op "/"(Left : Fixed; Right : Univ_Integer) -> Fixed
      is import("/")

    op "+="(var Left : Fixed; Right : Fixed) 
      is import("+=")

    op "-="(var Left : Fixed; Right : Fixed) 
      is import("-=")

    op "*="(var Left : Fixed; Right : Fixed) 
      is import("*=")

    op "/="(var Left : Fixed; Right : Univ_Integer) 
      is import("/=")

    op "/="(var Left : Fixed; Right : Univ_Real)

    op "=?"(Left, Right : Fixed) -> Ordering
      is import("=?")

    func Min(Left, Right : optional Fixed) -> optional Fixed
      is import(#min)
    func Max(Left, Right : optional Fixed) -> optional Fixed
      is import(#max)

    func Hash(Val : Fixed) -> Univ_Integer
      is import(#identity)

    func Round_To_Int(Val : Fixed) -> Univ_Integer

    func To_String(Val : Fixed) -> Univ_String

    func From_String(Str : Univ_String) -> optional Fixed

    func Print(X : Fixed)
    func Println(X : Fixed) is (Println(To_String(X)))

    op "in"(Left : Fixed; Right : Ordered_Set<Fixed>) 
      -> Boolean is in Ordered_Set<Fixed>
    
end interface PSL::Core::Fixed

class PSL::Core::Fixed is
    const Value : Univ_Integer

  exports
    op "from_univ"(Univ : Univ_Real) -> Fixed is
	return (Value => Univ_Real::Round_To_Int(Univ/Delta))
    end op "from_univ"

    op "to_univ"(Val : optional Fixed) -> optional Univ_Real is
	if Val is null then
	    return null
	else
	    return Delta * Int_To_Real(Val.Value)
	end if
    end op "to_univ"

    op "/="(var Left : Fixed; Right : Univ_Real) is
	Left := Left / Right
    end op "/="

    func Print(X : Fixed) is
	var Val : Univ_Real := [[X]]
	Print(Val)
    end func Print

    func To_String(Val : Fixed) -> Univ_String is
	return Univ_Real::To_String([[Val]])
    end func To_String

    func From_String(Str : Univ_String) -> optional Fixed is
	return Univ_Real::From_String(Str)
    end func From_String

    func Round_To_Int(Val : Fixed) -> Univ_Integer is
	return Univ_Real::Round_To_Int([[Val]])
    end func Round_To_Int

end class PSL::Core::Fixed

func PSL::Test::Test_Fixed(X : Univ_Real) is
    type My_Fixed is Fixed<Delta => 1.0E-6>

    var XTI : My_Fixed := X
    const Minute : My_Fixed := 60.0
    Println("X = " | XTI)
    Println("X * 2 = " | (XTI*2))
    Println("X + X = " | (XTI + XTI))
    Println("X - X = " | (XTI - XTI))
    Println("X / 2 = " | (XTI / 2))
    Println("X / 2.0 = " | (XTI / 2.0))
    Println("X * 3.0 = " | (XTI * 3.0))
    Println("5.0 * X = " | (5.0 * XTI))
    Println("-5.0 * X = " | (-5.0 * XTI))
    Println("-5.0 = " | -5.0)
    Println("Minute = " | Minute)
    Println("-5.0*Minute = " | -5.0*Minute)

    Println("Round_To_Int(X) = " | Round_To_Int(XTI))

    const Rng : Ordered_Set<My_Fixed> := 1.0 ..< 5.0

    Print("Rng = ")
    const Open_Ind : Map<Boolean, Univ_String> := [#false => "", #true => "<"]
    for IV in Rng forward loop
	if IV.Low != IV.High then
	    Print(IV.Low | Open_Ind[IV.Low_Is_Open] | ".." | 
	      Open_Ind[IV.High_Is_Open] | IV.High | " ")
	else
            Print(IV.Low | " ")
	end if
    end loop
    Print('\n')

    Println("X = " | XTI)
    Println("X in Rng = " | (XTI in Rng))

    if XTI in 1.0 ..< 5.0 then
	Println("X in 1.0 ..< 5.0")
    else
	Println("X not in 1.0 ..< 5.0")
    end if

    Println("X in 1.0 ..< 5.0 = " | (XTI in 1.0 ..< 5.0))

end func PSL::Test::Test_Fixed

interface PSL::Containers::Array
  <Elem_Type is Assignable<>; Indexed_By is Countable<>> 
  implements Indexable<Elem_Type, Indexed_By> is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Array

    func Length(Arr : Array) -> Univ_Integer
    op "magnitude"(Array) -> Univ_Integer is Length

    func Bounds(Arr : Array) -> Countable_Range<Indexed_By>

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type
    op "index_set"(Arr : Array) -> Countable_Range<Indexed_By> is Bounds
    op "<|="(var Left : Array; var Right : optional Elem_Type)
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) -> Array
    op "[]"() -> Array
end interface PSL::Containers::Array

class PSL::Containers::Array is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    type Elem_Array is Basic_Array<Elem_Type>
    var Data : Elem_Array
    const Bounds : Countable_Range<Indexed_By>
  exports

    func Create(Bounds : Countable_Range<Indexed_By>;
      Initial_Value : optional Elem_Type)
      -> Array is
	return (Data => Create(Length(Bounds), Initial_Value),
	  Bounds => Bounds)
    end func Create

    func Length(Arr : Array) -> Univ_Integer is
	return Length(Arr.Data)
    end func Length

    func Bounds(Arr : Array) -> Countable_Range<Indexed_By> is
	return Arr.Bounds
    end func Bounds

    op "indexing"(ref Arr : Array; Index : Indexed_By) -> ref Elem_Type is
	return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array; Index : Indexed_By) 
      -> ref var Elem_Type is
	if Length(Arr) == 0 then
	    // Create a one-element array
	    Arr := (Data => Create(1, null),
	      Bounds => Index .. Index)
	elsif Index < Arr.Bounds.First then
	    // Extend below
	    Arr := (Data => 
	      Elem_Array::Create(Arr.Bounds.First - Index, null) | Arr.Data,
	      Bounds => Index .. Arr.Bounds.Last)
	elsif Index > Arr.Bounds.Last then
	    // Extend above
	    Arr := (Data => 
	      Arr.Data | Elem_Array::Create(Index - Arr.Bounds.Last, null),
	      Bounds => Arr.Bounds.First .. Index)
	end if
	return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end op "var_indexing"

    op "<|="(var Left : Array; var Right : optional Elem_Type) is
	// Add Right onto Array
	if Length(Left) == 0 then
	    Left := (Data => Create(1, null),
	      Bounds => Indexed_By::First() .. Indexed_By::First())
	    Left[Indexed_By::First()] <== Right
	else
	    Left[Left.Bounds.Last + 1] <== Right
	end if
    end op "<|="
    
    op "|"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      -> Result : Array is
	Result := Left
	Result[Right.Key] := Right.Value
    end op "|"

    op "[]"() -> Result : Array is
        const First := Indexed_By::First()
	return (Data => Create(0, null), Bounds => First + 1 .. First)
	    // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Array

func PSL::Test::Test_Array() is
    type Color is Enum< [#red, #green, #blue] >
    type RCB is Array<Integer<Range => 0..0xFF>, Indexed_By => Color>

    const Red : RCB := [#red => 0x33, #green => 0, #blue => 0]
    const Blue : RCB := [#red => 0, #green => 0, #blue => 0x33]
    const Yellow : RCB := [0, 0x33, 0x33]
    const White : RCB := [0xFF, 0xFF, 0xFF]
    
    const RCBs : Vector<RCB> := [Red, Blue, Yellow, White]

    for each C of RCBs forward loop
	Println("#red => " | C[#red] | ", #green => " | C[#green] |
	  ", #blue => " | C[#blue])
    end loop
end func PSL::Test::Test_Array

interface PSL::Containers::Index_Pair
  <Index1_Type is Countable<>; Index2_Type is Countable<>> is
  // Two countable indices which can be combined to form an 2D array index
    const Index1 : Index1_Type
    const Index2 : Index2_Type

    func Nth_Pair
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       N : Univ_Integer) -> optional Index_Pair
      // Return Nth Pair given bounds for each of 2 index types
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2)
      // presuming second index varies fastest.
      // Return null if N out of range.

    func Pair_Position
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       Pair : Index_Pair) -> optional Univ_Integer
      // Return position of Pair within bounds
      // presuming Pair.Index1 in Bounds1 and Pair.Index2 in Bounds2
      // and second index varies fastest.
      // Return null if Pair out of range.

end interface PSL::Containers::Index_Pair

class PSL::Containers::Index_Pair is
  exports
    func Nth_Pair
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       N : Univ_Integer) -> optional Index_Pair is
      // Return Nth Pair given bounds for each of 2 index types
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2).
      // Return null if N out of range.
        const Len2 := Length (Bounds2)
        if N <= 0 or else N > Length(Bounds1) * Len2 then
            return null
        else
            const I1 := (N-1) / Len2
            const I2 := (N-1) rem Len2
            return (Index1 => Bounds1.First + I1,
                    Index2 => Bounds2.First + I2)
        end if
    end func Nth_Pair

    func Pair_Position
      (Bounds1 : Countable_Range<Index1_Type>;
       Bounds2 : Countable_Range<Index2_Type>;
       Pair : Index_Pair) -> optional Univ_Integer is
      // Return position of Pair within bounds (starting at 1)
      // presuming Pair.Index1 in Bounds1 and Pair.Index2 in Bounds2
      // and second index varies fastest.
      // Return null if Pair out of range.
        if Pair.Index1 not in Bounds1 or else Pair.Index2 not in Bounds2 then
            return null
        else
            return (Pair.Index1-Bounds1.First) * Length(Bounds2) + 
              (Pair.Index2-Bounds2.First) + 1
        end if
    end func Pair_Position

end class PSL::Containers::Index_Pair

interface PSL::Containers::Index_Pair_Set<Pair is Index_Pair<>> is
  // Set of index pairs
    func Create(Bounds1 : Countable_Range<Pair::Index1_Type>;
                Bounds2 : Countable_Range<Pair::Index2_Type>)
      -> Index_Pair_Set

    op "[]"() -> Index_Pair_Set

    func Count(Index_Pair_Set) -> Univ_Integer

    func Is_Empty(Index_Pair_Set) -> Boolean

    func First(Index_Pair_Set)
      -> optional Pair
    func Last(Index_Pair_Set)
      -> optional Pair
    
    func Remove_First(var Index_Pair_Set)
      -> optional Pair
    func Remove_Last(var Index_Pair_Set)
      -> optional Pair
    func Remove_Any(var Index_Pair_Set)
      -> optional Pair
end interface PSL::Containers::Index_Pair_Set

class PSL::Containers::Index_Pair_Set is
  // Set of index pairs
    const Bounds1 : Countable_Range<Pair::Index1_Type>
    const Bounds2 : Countable_Range<Pair::Index2_Type>
    var First : Univ_Integer
    var Last : Univ_Integer

    func Nth_Pair(Index_Pair_Set; N : Univ_Integer) -> Pair is
      // Return Nth Pair of original Index_Pair_Set
      // when N goes from 1 to Length(Bounds1) * Length(Bounds2).
      // Return null if N out of range.
        return Nth_Pair(Index_Pair_Set.Bounds1, Index_Pair_Set.Bounds2, N)
    end func Nth_Pair

  exports
    func Create(Bounds1 : Countable_Range<Pair::Index1_Type>;
                Bounds2 : Countable_Range<Pair::Index2_Type>)
      -> Index_Pair_Set is
        return (Bounds1 => Bounds1, Bounds2 => Bounds2,
                First => 1, Last => Length(Bounds1) * Length(Bounds2))
    end func Create

    op "[]"() -> Index_Pair_Set is
        return
          (Bounds1 =>
             Pair::Index1_Type::First()+1 .. Pair::Index1_Type::First(),
           Bounds2 =>
             Pair::Index2_Type::First()+1 .. Pair::Index2_Type::First(),
           First => 1,
           Last => 0)
    end op "[]"

    func Count(Index_Pair_Set) -> Univ_Integer is
        return Index_Pair_Set.Last - Index_Pair_Set.First + 1
    end func Count

    func Is_Empty(Index_Pair_Set) -> Boolean is
        return Index_Pair_Set.First > Index_Pair_Set.Last
    end func Is_Empty

    func First(Index_Pair_Set)
      -> optional Pair is
        return Nth_Pair(Index_Pair_Set, Index_Pair_Set.First)
    end func First

    func Last(Index_Pair_Set)
      -> optional Pair is
        return Nth_Pair(Index_Pair_Set, Index_Pair_Set.Last)
    end func Last

    func Remove_First(var Index_Pair_Set)
      -> Result : optional Pair is
        if Is_Empty(Index_Pair_Set) then
            Result := null
        else
            Result := Nth_Pair(Index_Pair_Set, Index_Pair_Set.First)
            Index_Pair_Set.First += 1
        end if
    end func Remove_First

    func Remove_Last(var Index_Pair_Set)
      -> Result : optional Pair is
        if Is_Empty(Index_Pair_Set) then
            Result := null
        else
            Result := Nth_Pair(Index_Pair_Set, Index_Pair_Set.Last)
            Index_Pair_Set.Last -= 1
        end if
    end func Remove_Last

    func Remove_Any(var Index_Pair_Set)
      -> optional Pair is
        if Count(Index_Pair_Set) mod 2 == 1 then
            return Remove_First(Index_Pair_Set)
        else
            return Remove_Last(Index_Pair_Set)
        end if
    end func Remove_Any

end class PSL::Containers::Index_Pair_Set

interface PSL::Containers::Array2D
  <Elem_Type is Assignable<>; Index1 is Countable<>; Index2 is Countable<>> is
  // A 2-D array abstraction where the index types are not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    func Create(Bounds1 : Countable_Range<Index1>;
      Bounds2 : Countable_Range<Index2>;
      Initial_Value : optional Elem_Type)
      -> Array2D

    type Indices is Index_Pair<Index1, Index2>
    type Set_Of_Indices is Index_Pair_Set<Indices>

    func Length1(Arr : Array2D) -> Univ_Integer
    func Length2(Arr : Array2D) -> Univ_Integer

    func Bounds1(Arr : Array2D) -> Countable_Range<Index1>
    func Bounds2(Arr : Array2D) -> Countable_Range<Index2>

    // Indexing operations using an index pair
    op "indexing"(ref Arr : Array2D; Indices) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array2D; Indices)
      -> ref var Elem_Type

    // Indexing operations using two individual indices
    op "indexing"(ref Arr : Array2D; Index1; Index2) -> ref Elem_Type
    op "var_indexing"(ref var Arr : Array2D; Index1; Index2)
      -> ref var Elem_Type

    // Set of index pairs that cover the 2D array.
    op "index_set"(Arr : Array2D) -> Set_Of_Indices

    op "[]"() -> Array2D
end interface PSL::Containers::Array2D

class PSL::Containers::Array2D is
  // An array abstraction where the index type is not necessarily
  // Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    type Elem_Array is Basic_Array<optional Elem_Type>
    var Data : Elem_Array
    const Bounds1 : Countable_Range<Index1>
    const Bounds2 : Countable_Range<Index2>
  exports

    func Create(Bounds1 : Countable_Range<Index1>;
      Bounds2 : Countable_Range<Index2>;
      Initial_Value : optional Elem_Type)
      -> Array2D is
	return
          (Data => Create(Length(Bounds1) * Length(Bounds2), Initial_Value),
	   Bounds1 => Bounds1, Bounds2 => Bounds2)
    end func Create

    func Length1(Arr : Array2D) -> Univ_Integer is
	return Length(Arr.Bounds1)
    end func Length1

    func Length2(Arr : Array2D) -> Univ_Integer is
	return Length(Arr.Bounds2)
    end func Length2

    func Bounds1(Arr : Array2D) -> Countable_Range<Index1> is (Arr.Bounds1)
    func Bounds2(Arr : Array2D) -> Countable_Range<Index2> is (Arr.Bounds2)

    // Indexing operations using an index pair
    op "indexing"(ref Arr : Array2D; Indices) -> ref Elem_Type is
        {> Indices.Index1 in Arr.Bounds1; Indices.Index2 in Arr.Bounds2 <}
	return Arr.Data[Pair_Position(Arr.Bounds1, Arr.Bounds2, Indices)]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array2D; Indices)
      -> ref var Elem_Type is
        return "var_indexing"(Arr, Indices.Index1, Indices.Index2)
    end op "var_indexing"

    // Indexing operations using two individual indices
    op "indexing"(ref Arr : Array2D; Index1; Index2) -> ref Elem_Type is
        {> Index1 in Arr.Bounds1; Index2 in Arr.Bounds2 <}
	return Arr.Data
          [Indices::Pair_Position(Arr.Bounds1, Arr.Bounds2, (Index1, Index2))]
    end op "indexing"

    op "var_indexing"(ref var Arr : Array2D; Index1; Index2)
      -> ref var Elem_Type is
        if Index1 not in Arr.Bounds1 or else Index2 not in Arr.Bounds2 then
            // Extend array to include Index1 and Index2
            var Old_Arr <== Arr
            Arr := Create
              (Bounds1 => Min(Old_Arr.Bounds1.First, Index1) ..
                 Max(Old_Arr.Bounds1.Last, Index1),
               Bounds2 => Min(Old_Arr.Bounds2.First, Index2) ..
                 Max(Old_Arr.Bounds2.Last, Index2),
               Initial_Value => null)

            // Move over old data
            for I in Old_Arr.Bounds1 loop
                for J in Old_Arr.Bounds2 loop
                    // Explicitly use "indexing" to avoid infinite recursion
                    "indexing"(Arr, I, J) <== Old_Arr[I, J]
                end loop
            end loop

            // Reclaim old data space
            Old_Arr := null
        end if

        //  Now return ref to appropriate element
	return "indexing"(Arr, Index1, Index2)
    end op "var_indexing"

    // Set of index pairs that cover the 2D array.
    op "index_set"(Arr : Array2D) -> Set_Of_Indices is
        return Create(Arr.Bounds1, Arr.Bounds2)
    end op "index_set"

    op "[]"() -> Array2D is
	return (Data => Create(0, null),
	  Bounds1 => Index1::First()+1 .. Index1::First(),
          Bounds2 => Index2::First()+1 .. Index2::First())
	    // Bounds not meaningful when empty
    end op "[]"

end class PSL::Containers::Array2D

func PSL::Test::Test_Array2D() is
    type Shade is Enum< [#white, #black] >
    type Chess_Board is Array2D<Shade,
      Index1 => Integer<1..8>, Index2 => Integer<1..8>>

    const Board_Indices : Chess_Board::Set_Of_Indices := Create(1..8, 1..8)
    var CB : Chess_Board := [for Ix in Board_Indices =>
      (if (Ix.Index1 - Ix.Index2) mod 2 == 0 then #white else #black)]

    for each [Ix => C] of CB forward loop
	Println("CB[" | Ix.Index1 | ", " | Ix.Index2 | "] = " | C)

        {> CB[Ix.Index1, Ix.Index2] == C <}
    end loop
end func PSL::Test::Test_Array2D

interface PSL::Core::Time<> is
  // Time in nanoseconds since Jan 1, 1970

    type Time_Interval is new
      Fixed<Delta => 1.0E-9>

    const Second : Time_Interval := 1.0
    const Millisecond : Time_Interval := 1.0/1000
    const Microsecond : Time_Interval := 1.0/10**6
    const Nanosecond : Time_Interval := 1.0/10**9

    const Minute : Time_Interval := 60.0
    const Hour : Time_Interval := 60 * Minute
    const Day : Time_Interval := 24 * Hour

    type Month_Enum is Enum< 
       [#Jan, #Feb, #Mar, #Apr, #May, #Jun,
        #Jul, #Aug, #Sep, #Oct, #Nov, #Dec] >

    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time

    func Zero() -> Time

    op "+"(Left : Time; Right : Time_Interval) -> Time
      is import("+")
    op "+"(Left : Time_Interval; Right : Time) -> Time
      is import("+")
    op "-"(Left : Time; Right : Time_Interval) -> Time
      is import("-")
    op "-"(Left, Right : Time) -> Time_Interval
      is import("-")

    op "=?"(Left, Right : Time) -> Ordering
      is import("=?")

    func Min(Left, Right : optional Time) -> optional Time
      is import(#min)
    func Max(Left, Right : optional Time) -> optional Time
      is import(#max)

    func Seconds_Since_1970(Time) -> Time_Interval
      is import(#identity)

end interface PSL::Core::Time

class PSL::Core::Time is
    const Since_1970 : Time_Interval

    type Year_Kind is Enum< [#normal, #leap] >

    const Month_Base : Array<Array<Univ_Integer, Indexed_By => Year_Kind>,
      Indexed_By => Month_Enum> := 
	[#Jan => [0, 0], #Feb => [31, 31], #Mar => [59, 60], #Apr => [90, 91],
         #May => [120, 121], #Jun => [151, 152], #Jul => [181, 182],
         #Aug => [212, 213], #Sep => [243, 244], #Oct => [273, 274],
         #Nov => [304, 305], #Dec => [334, 335]]

    func Kind_Of_Year(Year : Univ_Integer) -> Year_Kind is
	if Year mod 4 == 0 and then
	  (Year mod 100 != 0 or else Year mod 400 == 0) then
	    // Every 100 years leap year is omitted, 
	    // except for multiples of 400 which *are* leap years.
	    return #leap
	else
	    return #normal
	end if
    end func Kind_Of_Year

    func Leaps_Before(Year : Univ_Integer) -> Univ_Integer is
	// Number of leap years before this year, starting from 1970
	if Year < 2101 then
	    return (Year-1969)/4
	else
	    // Every 100 years leap year is omitted, 
	    // except for multiples of 400 which *are* leap years.
	    return (Year-1969)/4 - (Year-2001)/100
	end if
    end func Leaps_Before

  exports
    func Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      {Year in 1970 .. 2399; Day_Of_Month in 1..31}
      {Time_Zone in -12.0*Hour .. +12.0*Hour; Time_Of_Day in 0.0 .. 86400.0}
      -> Time is
	// Determine number of nanos since Jan 1, 1970
	const Kind := Kind_Of_Year(1970)
	const Base := Month_Base[Month][Kind]

	return (Since_1970 => 
	  (Year-1970) * (365*Day) + 
	  (Leaps_Before(Year) + Base + Day_Of_Month)*Day +
	  Time_Of_Day - Time_Zone)
    end func Create

    func Zero() -> Time is
	return (Since_1970 => 0.0)
    end func Zero

end class PSL::Core::Time

func PSL::Test::Test_Time(X : Univ_Real) is
    var XTI : Time::Time_Interval := X
    const Local_Minute : Time::Time_Interval := 60.0
    Println("X = " | XTI)
    Println("X * 2 = " | XTI*2)
    Println("X + X = " | (XTI + XTI))
    Println("X - X = " | (XTI - XTI))
    Println("X / 2 = " | (XTI / 2))
    Println("X / 2.0 = " | (XTI / 2.0))
    Println("X * 3.0 = " | (XTI * 3.0))
    Println("5.0 * X = " | (5.0 * XTI))
    Println("-5.0 * X = " | (-5.0 * XTI))
    Println("-5.0 = " | -5.0)
    Println("Local_Minute = " | Local_Minute)
    Println("-5.0*Local_Minute = " | (-5.0*Local_Minute))
    Println("Time::Minute = " | Time::Minute)
    Println("-5.0*Time::Minute = " | (-5.0*Time::Minute))
    Println("Time::Hour = " | Time::Hour )
    Println("-5.0*Time::Hour = " | (-5.0*Time::Hour))

    var T : Time := Create(Year => 2011, Month => #Oct, Day_Of_Month => 18,
      Time_Of_Day => 10*Time::Hour + 5*Time::Minute,
      Time_Zone => -5.0*Time::Hour)

    Println("18-Oct-2011 = " | ( T - Zero() ))
    Println("X = " | XTI )
    Println("18-Oct-2011 - X = " | ( (T - XTI) - Zero() ) )

end func PSL::Test::Test_Time
     
concurrent interface PSL::Core::Clock<> is
    // A module that provides access to a wall clock and
    // to other timers, and an ability to delay the caller
    // for a given amount of time, or until a specified time
    // in the future.
    
    func Create() -> Clock
	// Create a clock, which corresponds to the current wall clock time

    func Create(Now : Time) -> Clock
	// Create a clock, where Now() returns the given time when created

    func Now(locked C : Clock) -> Time
	// Return current reading of clock

    func Now() -> Time
	// Return current reading of wall clock

    queued func Delay(C : Clock; Until : Time)
	// Wait until the given clock reads >= Until

    queued func Delay(Until : Time)
	// Wait until the wall clock reads >= Until

    queued func Delay(C : Clock; For : Time::Time_Interval)
	// Wait until the given clock reads "Now(C) + For"

    queued func Delay(For : Time::Time_Interval)
	// Wait until the wall clock reads "Now() + For"

    func Set(locked var C : Clock; To : Time)
	// Update clock so it reads the given time
end interface PSL::Core::Clock

concurrent class PSL::Core::Clock is

    var Timer_Delta : Time::Time_Interval
	// Amount to be subtracted from Current Time
	// to produce value of timer

    func Current_Time(locked C : Clock) -> Time 
      is import(#clock_current_time)
	// NOTE: Clock parameter is ignored; returns wall clock

    func Wait_For_Delay(queued C : Clock; Until : Time) is 
      import(#clock_delay)
	// Wait until the wall clock reads >= Until
	// NOTE: Clock parameter is ignored

  exports
    func Create() -> Clock is
	// Create a clock, which corresponds to the current wall clock time
	// Println("Create Clock with Delta 0.0")
	return (Timer_Delta => 0.0)
    end func Create

    func Create(Now : Time) -> Result : Clock is
	// Create a clock, where Now() returns the given time when created
	const Delta := Current_Time(Create()) - Now
	// Println("Create Clock with Delta = " | Delta)
	return (Timer_Delta => Current_Time(Create()) - Now)
    end func Create

    func Now(locked C : Clock) -> Result : Time is
	// Return current reading of clock
	Result := Current_Time(C) - C.Timer_Delta
	// Println("Now returning " | Result-Zero())
    end func Now

    func Now() -> Result : Time is
	// Return current reading of wall clock
        var C : Clock := Create()
	Result := Current_Time(C)
	// Println("Now returning " | Result-Zero())
    end func Now

    queued func Delay(C : Clock; Until : Time) is
	// Wait until the given clock reads >= Until
	Wait_For_Delay(C, Until + C.Timer_Delta)
    end func Delay

    queued func Delay(Until : Time) is
	// Wait until the wall clock reads >= Until
        var C : Clock := Create()
	Wait_For_Delay(C, Until)
    end func Delay

    queued func Delay(C : Clock; For : Time::Time_Interval) is
	// Wait until the given clock reads "Now(C) + For"
	// NOTE: Timer_Delta is irrelevant for this one
	// Println("Wait for delay of " | For)
	const Time_Now := Current_Time(C)
	const Until := Time_Now + For
	// Println("Time_Now + " | For | " - Time_Now = " | Until - Time_Now)
	Wait_For_Delay(C, Until)
    end func Delay

    queued func Delay(For : Time::Time_Interval) is
	// Wait until the wall clock reads "Now() + For"
	// NOTE: Timer_Delta is irrelevant for this one
	// Println("Wait for delay of " | For)
        var C : Clock := Create()
	const Time_Now := Current_Time(C)
	const Until := Time_Now + For
	// Println("Time_Now + " | For | " - Time_Now = " | Until - Time_Now)
	Wait_For_Delay(C, Until)
    end func Delay

    func Set(locked var C : Clock; To : Time) is
	// Update clock so it reads the given time
	C.Timer_Delta := Current_Time(C) - To
    end func Set

end class PSL::Core::Clock

func PSL::Test::Test_Clock() is
    var C := Clock::Create()
    const Start := C.Now()
    var Ran := Random::Start (Round_To_Int (Seconds_Since_1970 (Clock::Now())))
    Println("First random number = " | Next(Ran));
    Println("Second random number = " | Next(Ran));
    Println("Third random number = " | Next(Ran));

  then
    Println("About to delay 4.0 seconds")
    C.Delay(4.0)
    Println("Done with delay of 4.0")
  ||
    Println("About to delay 2.0 seconds")
    C.Delay(2.0)
    Println("Done with delay of 2.0")
||    // check that indent of 0 works
    for I in 1..7 loop
	Println("In loop delaying for 1.0")
	C.Delay(1.0)
	Println("Done with delay " | I | " of 1.0")
    end loop
then  // check that indent of 0 works
    Println("Elapsed time: " | (C.Now() - Start))
end func PSL::Test::Test_Clock

concurrent interface PSL::Core::Atomic<Content_Type is Comparable<>> is
    func Create(Initial_Val : Content_Type) -> Atomic
      // Create an atomic object with given initial value

    func Set_Value(locked var A : Atomic; Val : Content_Type)
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually

    func Value(locked A : Atomic) -> Content_Type
      // Return the current value
      // TBD: Use atomic hardware instructions eventually

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Content_Type
      // Set Value(A) to New_Val; Return the prior value.

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) -> Content_Type
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.
end interface PSL::Core::Atomic

concurrent class PSL::Core::Atomic is
    var Value : Content_Type
  exports
    func Create(Initial_Val : Content_Type) -> Atomic is
      // Create an atomic object with given initial value
	return (Value => Initial_Val)
    end func Create

    func Set_Value(locked var A : Atomic; Val : Content_Type) is
      // Atomically set the new value
      // TBD: Use atomic hardware instructions eventually
	A.Value := Val
    end func Set_Value

    func Value(locked A : Atomic) -> Content_Type is
      // Return the current value
      // TBD: Use atomic hardware instructions eventually
	return A.Value
    end func Value

    func Test_And_Set(locked var A : Atomic; New_Val : Content_Type) ->
      Result : Content_Type is
      // Set Value(A) to New_Val; Return the prior value.
	Result := A.Value
	A.Value := New_Val
    end func Test_And_Set

    func Compare_And_Swap(locked var A : Atomic;
      Expected_Val, New_Val : Content_Type) -> Result : Content_Type is
      // If Value(A) == Expected_Val, then set Value(A) to New_Val.
      // In any case, return the prior value.
	Result := A.Value
	if Result == Expected_Val then
	    A.Value := New_Val
	end if
    end func Compare_And_Swap
end class PSL::Core::Atomic

func PSL::Test::Test_Atomic(X, Y : Univ_Integer) is
    type Atomic_Univ is Atomic<Univ_Integer>
    var AX := Atomic_Univ::Create(X)

    Println("Value(X) = " | Value(AX))

    Set_Value(AX, X+1)
    Println("After Set_Value(" | X+1 | "), Value(X) = " | Value(AX))

    const Z := Test_And_Set(AX, Y)
    Println("Test_And_Set(X, " | Y | ") = " | Z)

    const CAS := Compare_And_Swap(AX, Expected_Val => X-1, New_Val => Y-1)
    Println("Compare_And_Swap(X, " | X-1 | ", " | Y-1 | 
      ") = " | CAS | ", Value(X) = " | Value(AX))

    const CAS2 := Compare_And_Swap(AX, Y, Y-2)
    Println("Compare_And_Swap(X, " | Y | ", " | Y-2 | 
      ") = " | CAS2 | ", Value(X) = " | Value(AX))

end func PSL::Test::Test_Atomic

interface PSL::Core::Modular<Modulus : Univ_Integer> is
  // This is an unsigned type whose arithmetic is "modulo" the modulus
    op "from_univ"(Lit : Univ_Integer) -> Modular 
      is import(#integer_from_univ)

    op "to_univ"(Val : Modular) -> Univ_Integer 
      is import(#integer_to_univ)

    op "+"(Right : Modular) -> Modular
      is import(#identity)

    op "-"(Right : Modular) -> Modular

    op "abs"(Right : Modular) -> Modular
      is import(#identity)

    op "magnitude"(Modular) -> Modular is "abs"

    op "+"(Left, Right : Modular) -> Result : Modular

    op "-"(Left, Right : Modular) -> Result : Modular

    op "*"(Left, Right : Modular) -> Result : Modular

    op "/"(Left, Right : Modular) -> Result : Modular
      is import("/")

    op "mod"(Left, Right : Modular) -> Modular
      is import("mod")

    op "rem"(Left, Right : Modular) -> Modular
      is import("rem")

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "+="(var Left : Modular; Right : Modular)

    op "-="(var Left : Modular; Right : Modular)

    op "*="(var Left : Modular; Right : Modular)

    op "/="(var Left : Modular; Right : Modular) 
      is import("/=")

    op "**="(var Left : Modular; Right : Univ_Integer)

    op "=?"(Left, Right : Modular) -> Ordering
      is import("=?")

    op ">>"(Modular; Modular) -> Modular is import(">>")

    op "<<"(Modular; Modular) -> Modular is import("<<")

    op "and"(Left, Right : Modular) -> Modular is import(#bit_and)
    op "or"(Left, Right : Modular) -> Modular
    op "xor"(Left, Right : Modular) -> Modular
    op "not"(M : Modular) -> Modular

    func Min(Left, Right : optional Modular) -> optional Modular
      is import(#min)
    func Max(Left, Right : optional Modular) -> optional Modular
      is import(#max)

    func Hash(Val : Modular) -> Univ_Integer
      is import(#identity)

    func To_String(Val : Modular) -> Univ_String
      is import(#to_string_int)

    func From_String(Str : Univ_String) -> optional Modular

    func Print(X : Modular) is import(#print_int)
    func Println(X : Modular) is (Println(To_String(X)))

    func First() -> Modular

    func Last() -> Modular

    op "[..]"()->Countable_Range<Modular> is in Countable_Range<Modular>

    op ".."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "<.."(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "<..<"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
    op "|"(Left, Right : Modular) -> Countable_Set<Modular>
      is in Countable_Set<Modular>
  implements for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding a Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular

    op "-"(Left, Right : Modular) -> Result : Univ_Integer

end interface PSL::Core::Modular

class PSL::Core::Modular is
    const Content : Univ_Integer;  // So this ends up as a wrapper

    func Bit_Or(Left, Right : Univ_Integer) -> Univ_Integer 
      is import(#bit_or)

    func Bit_Xor(Left, Right : Univ_Integer) -> Univ_Integer 
      is import(#bit_xor)
  exports
    op "-"(Right : Modular) -> Modular is
	return (Content => Modulus - Right.Content)
    end op "-"

    op "+"(Left, Right : Modular) -> Result : Modular is
	return (Content => (Left.Content + Right.Content) mod Modulus)
    end op "+"

    op "-"(Left, Right : Modular) -> Result : Modular is
	return (Content => (Left.Content - Right.Content) mod Modulus)
    end op "-"

    op "*"(Left, Right : Modular) -> Result : Modular is
	return (Content => (Left.Content * Right.Content) mod Modulus)
    end op "*"

    op "**"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
	return (Content => (Left.Content ** Right) mod Modulus)
    end op "**"

    op "+="(var Left : Modular; Right : Modular) is
	Left := (Content => (Left.Content + Right.Content) mod Modulus)
    end op "+="

    op "-="(var Left : Modular; Right : Modular) is
	Left := (Content => (Left.Content - Right.Content) mod Modulus)
    end op "-="

    op "*="(var Left : Modular; Right : Modular) is
	Left := (Content => (Left.Content * Right.Content) mod Modulus)
    end op "*="

    op "**="(var Left : Modular; Right : Univ_Integer) is
	Left := (Content => (Left.Content ** Right) mod Modulus)
    end op "**="

    func From_String(Str : Univ_String) -> optional Modular is
	const Val : Univ_Integer := From_String(Str)
	if Val is null or else Val in 0..<Modulus then
	    return (Content => Val)
	else
	    return null
	end if
    end func From_String

    op "or"(Left, Right : Modular) -> Modular is
	return (Content => Bit_Or(Left.Content, Right.Content) mod Modulus)
    end op "or"

    op "xor"(Left, Right : Modular) -> Modular is
	return (Content => Bit_Xor(Left.Content, Right.Content) mod Modulus)
    end op "xor"

    op "not"(M : Modular) -> Modular is
	return (Content => Modulus - 1 - M.Content)
    end op "not"

    func First() -> Modular is
	return (Content => 0)
    end func First

    func Last() -> Modular is
	return (Content => Modulus-1)
    end func Last

  // implements
  // for Countable
    // These operations are needed so Modular satifies
    // requirements of "Countable" interface, but these
    // operations are not directly callable (if they were callable,
    // we would have ambiguity when adding an Modular to an int-literal).

    op "+"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
	return (Content => (Left.Content + Right) mod Modulus)
    end op "+"

    op "+"(Left : Univ_Integer; Right : Modular) -> Result : Modular is
	return (Content => (Left + Right.Content) mod Modulus)
    end op "+"

    op "-"(Left : Modular; Right : Univ_Integer) -> Result : Modular is
	return (Content => (Left.Content - Right) mod Modulus)
    end op "-"

    op "-"(Left, Right : Modular) -> Result : Univ_Integer is
	return (Left.Content - Right.Content) mod Modulus
    end op "-"
end class PSL::Core::Modular
    
func PSL::Test::Test_Modular() is
    type Mod16 is Modular<16>

    Println("Testing mod 16")
    Println("0xA + 0xA = " | Mod16::0xA + Mod16::0xA)
    Println("0xA or 0x1 = " | (Mod16::0xA or Mod16::0x1))
    Println("0xA xor 0x2 = " | (Mod16::0xA xor Mod16::0x2))
    Println("not 0xA = " | (not Mod16::0xA))
end func PSL::Test::Test_Modular

func Test_Enum() is
    PSL::Test::Test_Enum()
end func Test_Enum

interface PSL::Containers::Discrete_Ordered_Set<Element_Type is Comparable<>> is
  // A set over individual but ordered elements
    op "[]"() -> Discrete_Ordered_Set

    func Singleton(Elem : Element_Type) -> Discrete_Ordered_Set

    op "|"(Left, Right : Element_Type) -> Discrete_Ordered_Set
    op "|"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      -> Discrete_Ordered_Set
    op "|"(Left : Element_Type; Right : Discrete_Ordered_Set) 
      -> Discrete_Ordered_Set
    op "|"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      -> Discrete_Ordered_Set

    op "|="(var Left : Discrete_Ordered_Set; Right : Element_Type)
    op "|="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    op "<|="(var Left : Discrete_Ordered_Set; var Right : optional Element_Type)
        // Move element into set, leaving Right null afterward.

    op "<|="(var Left : Discrete_Ordered_Set; var Right : Discrete_Ordered_Set)
	// Move all elements of Right into Left, leaving Right empty.

    op "-"(Left, Right : Discrete_Ordered_Set) -> Discrete_Ordered_Set
      // Set difference
    op "-"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      -> Discrete_Ordered_Set
      // Remove one element
    op "-="(var S : Discrete_Ordered_Set; Elem : Element_Type)
      // Remove the given element from the set, if present
    op "-="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      // Remove all elements of Right from Left, if present

    op "or"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      -> Discrete_Ordered_Set is "|"   // union
    op "or="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      is "|="

    op "+"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      -> Discrete_Ordered_Set is "|"   // Union
    op "+="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      is "|="
    op "+="(var Left : Discrete_Ordered_Set; Right : Element_Type) is "|="
   
    op "and"(Left, Right : Discrete_Ordered_Set) -> Discrete_Ordered_Set
	// Intersection
    op "and="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    op "xor"(Left, Right : Discrete_Ordered_Set) -> Discrete_Ordered_Set
	// Symmetric difference
    op "xor="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    op "in"(Left : Element_Type; Right : Discrete_Ordered_Set) -> Boolean

    op "=?"(Left, Right : Discrete_Ordered_Set) -> Ordering
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise

    func Count(S : Discrete_Ordered_Set) -> Univ_Integer

    op "magnitude"(Discrete_Ordered_Set) -> Univ_Integer is Count

    func Is_Empty(S : Discrete_Ordered_Set) -> Boolean

    func First(S : Discrete_Ordered_Set) -> optional Element_Type
    func Last(S : Discrete_Ordered_Set) -> optional Element_Type

    func Remove_First(var S : Discrete_Ordered_Set) -> optional Element_Type
	// Remove first element of set (lowest value)

    func Remove_Last(var S : Discrete_Ordered_Set) -> optional Element_Type
	// Remove last element of set (highest value)

    func Remove_Any(var S : Discrete_Ordered_Set) -> optional Element_Type
	// Remove an arbitrary element of set

end interface PSL::Containers::Discrete_Ordered_Set

class PSL::Containers::Discrete_Ordered_Set is

    var Items : optional AA_Tree<Element_Type>

  exports
    op "[]"() -> Discrete_Ordered_Set is
        return (Items => [])
    end op "[]"

    func Singleton(Elem : Element_Type) -> Result : Discrete_Ordered_Set is
	Result := []
	Result.Items |= Elem
    end func Singleton

    op "|"(Left, Right : Element_Type) -> Result : Discrete_Ordered_Set is
        Result := [];
        Result.Items |= Left;
        Result.Items |= Right;
    end op "|"

    op "|"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      -> Result : Discrete_Ordered_Set is
        Result := Left
        Result.Items |= Right
    end op "|"

    op "|"(Left : Element_Type; Right : Discrete_Ordered_Set) 
      -> Discrete_Ordered_Set is
        return Right | Left
    end op "|"

    op "|"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      -> Result : Discrete_Ordered_Set is
        Result := Left
        Result |= Right
    end op "|"

    op "|="(var Left : Discrete_Ordered_Set; Right : Element_Type) is
        Left.Items |= Right;
    end op "|="

    op "<|="(var Left : Discrete_Ordered_Set; var Right : optional Element_Type)
      is
        // Move element into set, leaving Right null afterward.
	Left.Items <|= Right
    end op "<|="

    op "<|="(var Left : Discrete_Ordered_Set; var Right : Discrete_Ordered_Set)
      is
	// Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) == 0 then
            Left.Items <== Right.Items
        else
            // Iterate through the tree
	    loop
		// Extract element from right
		var Elem for Left := Remove_Any(Right.Items)

		if Elem is null then
		    return   // All done
		end if

                Left.Items <|= Elem

            end loop
        end if
    end op "<|="

    op "|="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) is
	// Pass the buck to the "<|=" operation
	var Right_Copy for Left := Right
	Left <|= Right_Copy
    end op "|="

    op "-"(Left, Right : Discrete_Ordered_Set) 
      -> Result : Discrete_Ordered_Set is
      // Set difference
	Result := Left
	Result -= Right
    end op "-"

    op "-"(Left : Discrete_Ordered_Set; Right : Element_Type)
      -> Result : Discrete_Ordered_Set is
      // Remove one element
        Result := Left
        Result -= Right
    end op "-"
        
    op "-="(var S : Discrete_Ordered_Set; Elem : Element_Type) is
      // Remove the given element from the set, if present
	Delete(S.Items, Elem);
    end op "-="

    op "-="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) is
      // Remove all elements of Right from Left, if present
	for Elem in Right loop
	    Left -= Elem
	end loop
    end op "-="

    op "and"(Left, Right : Discrete_Ordered_Set)
      -> Result : Discrete_Ordered_Set is
	// Intersection
	Result := []
	for Elem in Right loop
	    if Elem in Left then
		Result += Elem
	    end if
	end loop
    end op "and"

    op "and="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) is
	// Intersection
	for Elem in Left loop
	    if Elem not in Right then
		Left -= Elem
	    end if
	end loop
    end op "and="

    op "xor"(Left, Right : Discrete_Ordered_Set) 
      -> Result : Discrete_Ordered_Set is
	// Symmetric difference
	Result := Left
	Result xor= Right
    end op "xor"

    op "xor="(var Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) is
	// Symmetric difference
	// Want elements that are only in one of the two inputs
	for Elem in Right loop
	    if Elem in Left then
		Left -= Elem
	    else
		Left += Elem
	    end if
	end loop
    end op "xor="

    op "in"(Left : Element_Type; Right : Discrete_Ordered_Set) -> Boolean is
        return Overlapping(Right.Items, Left) not null
    end op "in"

    op "=?"(Left, Right : Discrete_Ordered_Set) -> Ordering is
	// Return #equal if Left and Right have the same elements
	// Return #less if Left is a proper subset of Right
	// Return #greater if Left is a proper superset of Right
	// Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            // Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                // Left is a superset
                return #greater
            end if
        else
            // Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                // Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end op "=?"

    func Count(S : Discrete_Ordered_Set) -> Result : Univ_Integer is
        // Return count of items in set
        return Count(S.Items);
    end func Count

    func Is_Empty(S : Discrete_Ordered_Set) -> Boolean is
	return Is_Empty(S.Items)
    end func Is_Empty

    func First(S : Discrete_Ordered_Set) -> optional Element_Type is
        return First(S.Items);
    end func First

    func Last(S : Discrete_Ordered_Set) -> optional Element_Type is
        return Last(S.Items);
    end func Last

    func Remove_First(var S : Discrete_Ordered_Set) 
      -> Result : optional Element_Type is
        // Return first element of set
        return Remove_First(S.Items)
    end func Remove_First

    func Remove_Last(var S : Discrete_Ordered_Set) 
      -> Result : optional Element_Type is
        // Remove last element of set
        return Remove_Last(S.Items);
    end func Remove_Last

    func Remove_Any(var S : Discrete_Ordered_Set) -> optional Element_Type is
        // Remove any element of set
        return Remove_Any(S.Items);
    end func Remove_Any

end class PSL::Containers::Discrete_Ordered_Set

interface PSL::Core::Enum_With_Rep
  <Rep_Type is Imageable<>;
   Rep_Map : Two_Way_Map<Univ_Enumeration, Rep_Type>> is
  // An enumeration type specified using a map from literal to value
  // of an underlying representation type.
    op "from_univ"(Univ : Univ_Enumeration) 
      {(for some [Lit => Val] of Rep_Map => Lit == Univ)}
      -> Enum_With_Rep
    op "to_univ"(Val : optional Enum_With_Rep)
      -> Result : optional Univ_Enumeration
      {Result is null or else
        (for some [Lit => Val] of Literals => Lit == Result)}

    // Functions to convert from/to rep
    func From_Rep (Rep : optional Rep_Type) -> optional Enum_With_Rep
    func To_Rep (Val : optional Enum_With_Rep) -> optional Rep_Type

    op "[..]"() -> Discrete_Ordered_Set<Enum_With_Rep>

    op "=?"(Left, Right : Enum_With_Rep) -> Ordering

    // Functions for Imageable
    func To_String(Val : Enum_With_Rep) -> Univ_String
    func From_String(Str : Univ_String) -> optional Enum_With_Rep

    func Hash(Val : Enum_With_Rep) -> Univ_Integer

    func Min(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    func Max(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep

    func Dump_Rev_Map()
end interface PSL::Core::Enum_With_Rep

class PSL::Core::Enum_With_Rep is
    const Rep : Rep_Type
  exports
    op "from_univ"(Univ : Univ_Enumeration) 
      -> Enum_With_Rep is
        return (Rep => Rep_Map[Univ]);
    end op "from_univ"

    op "to_univ"(Val : optional Enum_With_Rep) 
      -> Result : optional Univ_Enumeration is
	if Val is null then
	    return null
	else
            return Key_Of (Rep_Map, Val.Rep)
	end if
    end op "to_univ"

    func From_Rep (Rep : optional Rep_Type) -> optional Enum_With_Rep is
        if Rep is null then
            return null
        else
            return (Rep => Rep)
        end if
    end func From_Rep

    func To_Rep (Val : optional Enum_With_Rep) -> optional Rep_Type is
        if Val is null then
            return null
        else
            return Val.Rep
        end if
    end func To_Rep

    // Functions for Imageable
    func To_String(Val : Enum_With_Rep) -> Univ_String is
        const Enum : optional Univ_Enumeration := [[Val]];
        if Enum not null then
            // use enum image
            return Univ_Enumeration::To_String(Enum);
        else
            // use rep-type To_String
            return Rep_Type::To_String(Val.Rep)
        end if
    end func To_String

    func From_String(Str : Univ_String) -> optional Enum_With_Rep is
        if Str[1] == '#' then
            // Presume is an enum
            return Univ_Enumeration::From_String(Str)
        else
            // Use rep-type From_String
            return (Rep => Rep_Type::From_String(Str))
        end if
    end func From_String

    op "[..]"() -> Discrete_Ordered_Set<Enum_With_Rep> is
        return [for each Rep of Rep_Map => From_Rep(Rep)]
    end op "[..]";

    op "=?"(Left, Right : Enum_With_Rep) -> Ordering is
        return Left.Rep =? Right.Rep
    end op "=?"

    func Hash(Val : Enum_With_Rep) -> Univ_Integer is
        return Hash (Val.Rep)
    end func Hash

    func Min(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep > Left.Rep then
            return Left
        else
            return Right
        end if
    end func Min

    func Max(Left, Right : optional Enum_With_Rep) -> optional Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep < Left.Rep then
            return Left
        else
            return Right
        end if
    end func Max

    func Dump_Rev_Map() is
        const Rev := Rev_Map (Rep_Map)

        for KV in Rev loop
            Println ("[" | KV.Key | " => " | KV.Value | "]")
        end loop
    end func Dump_Rev_Map

end class PSL::Core::Enum_With_Rep

func PSL::Test::Test_Enum_With_Rep() is
    type Color is Enum_With_Rep<Univ_Integer,
               [#red => 1, #green => 3, #blue => 5]>;

    type Day_Of_Week is 
       Enum_With_Rep<Modular<2**7>,
          [#Monday => 1<<1, #Tuesday => 1<<2, #Wednesday => 1<<3,
           #Thursday => 1<<4, #Friday => 1<<5,
            #Saturday => 1<<6, #Sunday => 1<<7]>

    Println ("Dump_Rev_Map():")
    Day_Of_Week::Dump_Rev_Map()

    for C in Color forward loop
        Println("Next color = " | C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " | C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " | D3)
    end loop

    {#Monday in Day_Of_Week}

    for D4 in Day_Of_Week reverse loop
        Println("Prev day of week = " | D4)
    end loop

    for D5 in Day_Of_Week forward loop
        Println("To_Rep(" | D5 | ") = " | To_Rep(D5))
    end loop

    for I in 1..10 forward loop
        Println("Day_Of_Week::From_Rep(" | I | ") = " |
          Day_Of_Week::From_Rep(I))
    end loop

end func PSL::Test::Test_Enum_With_Rep

interface PSL::Core::Enum_Mask
  <Base_Type is Modular<>;
   Rep_Map : Two_Way_Map<Univ_Enumeration, Base_Type>>
  extends PSL::Core::Enum_With_Rep<Base_Type, Rep_Map> is
  // An enumeration type built on a modular type
  // that supports "|" as a way to combine bits into a single value.
    op "|"(Left, Right : Enum_Mask) -> Enum_Mask
       is (From_Rep(To_Rep(Left) or To_Rep(Right)))
end interface PSL::Core::Enum_Mask

concurrent interface PSL::Core::IO<>:
  // Locked versions of the Print, Println and Readln operations
    var Stdout : Standard_Output_Stream
    var Stderr : Standard_Output_Stream

    func Get_IO() -> IO  // Get handle on IO subsystem

    func Print(locked var IO; Univ_String)
    func Println(locked var IO; Univ_String)

    func Print(locked var IO; Val : Val_Type is Imageable<>)
    func Println(locked var IO; Val : Val_Type is Imageable<>)

    func Readln(locked var IO) -> optional Univ_String

end interface PSL::Core::IO

concurrent class PSL::Core::IO:
  exports
    func Get_IO() -> IO:
        return (Stdout => (Channel => #stdout),
                Stderr => (Channel => #stderr));

    func Print(locked var IO; Univ_String):
        Print (Univ_String)

    func Println(locked var IO; Univ_String):
        Println (Univ_String)

    func Print(locked var IO; Val : Val_Type is Imageable<>):
        Print (Val_Type::To_String(Val))

    func Println(locked var IO; Val : Val_Type is Imageable<>):
        Println (Val_Type::To_String(Val))

    func Readln(locked var IO) -> optional Univ_String:
        return Readln()

end class PSL::Core::IO

interface PSL::Containers::Imageable_Vector<Element_Type is Imageable<>>
  extends Vector<Element_Type>
  implements Imageable<> is
  //  A vector which can be easily printed.
  //  Requires element type to itself be Imageable.
    func To_String(Val : Imageable_Vector) -> Univ_String<>

    func From_String(Str : Univ_String<>) -> optional Imageable_Vector
      is (null)  // TBD

    op "=?"(Left, Right : Imageable_Vector) -> Ordering
    func Hash(Val : Imageable_Vector) -> Univ_Integer

    func Print(Val : Imageable_Vector) is (Print(To_String(Val)))
    func Println(Val : Imageable_Vector) is (Println(To_String(Val)))
end interface PSL::Containers::Imageable_Vector

class PSL::Containers::Imageable_Vector is
  exports
    func To_String(Val : Imageable_Vector) -> Result : Univ_String<> is
        Result := "";
        for (each V of Val; Sep := "[" then ", ") forward loop
            Result |= Sep | V;
        end loop
        return Result | "]"
    end func To_String

    op "=?"(Left, Right : Imageable_Vector) -> Ordering is
        for I in 1 .. Min(|Left|, |Right|) forward loop
            const Result := Left[I] =? Right[I]
            if Result != #equal then
                //  First mismatch determines result
                return Result
            end if
        end loop
        //  Prefixes match, result determined by length comparison
        return |Left| =? |Right|
    end op "=?"

    func Hash(Val : Imageable_Vector) -> Univ_Integer is
        if |Val| == 0 then
            return 0
        else
            //  Hash first and last
            return Hash(Val[1])*7 + Hash(Val[|Val|])
        end if
    end func Hash
end class PSL::Containers::Imageable_Vector

//  Tuple types

interface PSL::Containers::Pair<T1 is Assignable<>; T2 is Assignable<>> is
   const First  : T1;
   const Second : T2;
end interface PSL::Containers::Pair;

interface PSL::Containers::Triple<T1 is Assignable<>; T2 is Assignable<>;
                                  T3 is Assignable<>> is
   const First  : T1;
   const Second : T2;
   const Third  : T3;
end interface PSL::Containers::Triple;

interface PSL::Containers::Quad<T1 is Assignable<>; T2 is Assignable<>;
                                T3 is Assignable<>; T4 is Assignable<>> is
   const First  : T1;
   const Second : T2;
   const Third  : T3;
   const Fourth : T4;
end interface PSL::Containers::Quad;

func PSL::Test::Test_IO (X, Y : Univ_String; Z : Univ_Integer):
    var IO := IO::Get_IO()
    const Pi := 3.141592653589793
    const True := Boolean::#true

    IO.Print ("Pi = ")
    IO.Print (Pi)
    IO.Print (", True prints as ")
    IO.Print (True)
    IO.Print ('\n')
    IO.Print ("X = \"" | X | '"')
    IO.Print (", Y = \"" | Y | '"')
    IO.Println (", Z = " | Z )
    IO.Print ("Give me somethin: ")
    var Input := IO.Readln()
    IO.Println ("You gave me: \"" | Input | '"')

    IO.Stderr.Println ("This is going to standard error output");
    IO.Stdout.Println ("This is going to standard output");
    IO.Stdout.Println ("About to flush stderr and stdout");
    IO.Stderr.Flush ()
    IO.Stdout.Flush ()

    const Vec : Imageable_Vector<Univ_Integer> := [1, 3, 5, 7, 9]
    IO.Println ("About to print out imageable vector")
    IO.Print (Vec); IO.Print('\n')
end func PSL::Test::Test_IO
    
import PSL::Test::Test_IO

func Test_IO (X, Y : Univ_String; Z : Univ_Integer):
    PSL::Test::Test_IO (X, Y, Z)
end func Test_IO

interface PSL::Core::Output_Stream<> is
  // Output stream interface; all operations
  // expressed in terms of Univ_String print and close
    abstract func Print(var Output_Stream; Univ_String)
    abstract func Close(var optional Output_Stream)

    func Println(var Output_Stream+; Univ_String)

    func Print(var Output_Stream+; Val : Val_Type is Imageable<>)

    func Println(var Output_Stream+; Val : Val_Type is Imageable<>)

end interface PSL::Core::Output_Stream

class PSL::Core::Output_Stream is
  // Output stream interface; all operations
  // expressed in terms of Univ_String print
  exports
    func Println(var Output_Stream+; Univ_String):
        Output_Stream.Print(Univ_String)
        Output_Stream.Print("\n")

    func Print(var Output_Stream+; Val : Val_Type is Imageable<>):
        Output_Stream.Print (Val_Type::To_String(Val))

    func Println(var Output_Stream+; Val : Val_Type is Imageable<>):
        Output_Stream.Print (Val_Type::To_String(Val))
        Output_Stream.Print("\n")

end class PSL::Core::Output_Stream

abstract interface PSL::Core::Input_Stream<> is
    func Readln(var Input_Stream) -> optional Univ_String
    func Close(var optional Input_Stream)
end interface PSL::Core::Input_Stream

interface PSL::Core::File_Output_Stream<> extends Output_Stream<> is
    func Create(var IO; Name : Univ_String) -> optional File_Output_Stream
      is import(#create_output_file)
    func Append(var IO; Name : Univ_String) -> optional File_Output_Stream
      is import(#append_output_file)
    func Close(var optional File_Output_Stream)
      is import(#close_output_file)

    func Print(var File_Output_Stream; Univ_String)
      is import(#print_to_file)
end interface PSL::Core::File_Output_Stream

class PSL::Core::File_Output_Stream is
    const Name : Univ_String
    const Index : Univ_Integer
  exports
end class PSL::Core::File_Output_Stream

interface PSL::Core::File_Input_Stream<> extends Input_Stream is
    func Open(var IO; Name : Univ_String) -> optional File_Input_Stream
      is import(#open_input_file)
    func Close(var optional File_Input_Stream)
      is import(#close_input_file)
    func Readln(var File_Input_Stream) -> optional Univ_String
      is import(#read_from_file)
end interface PSL::Core::File_Input_Stream

class PSL::Core::File_Input_Stream is
    const Name : Univ_String;
    const Index : Univ_Integer
  exports
end class PSL::Core::File_Input_Stream

interface PSL::Core::Standard_Output_Stream<> extends Output_Stream is
  //  Output stream for one of the "standard" output channels
    type Output_Channel_Enum is Enum<[#stdout, #stderr]>
    const Channel : Output_Channel_Enum

    func Print(var Standard_Output_Stream; Univ_String)
      is import(#print_to_standard_file)

    func Flush(var Standard_Output_Stream)
      is import(#flush_standard_file)

    func Close(var optional Standard_Output_Stream)
      is Flush
end interface PSL::Core::Standard_Output_Stream

func PSL::Test::Test_File (Name, X, Y : Univ_String; Z : Univ_Integer):
    var IO := IO::Get_IO()
    var File := File_Output_Stream::Create(IO, Name);
    const Pi := 3.14159265389793
    const True := Boolean::#true

    IO.Println ("Writing to file: " | Name)

    File.Print ("Pi = ")
    Output_Stream::Print (File, Pi)
    File.Print (", True prints as ")
    Print (File, True)
    Print (File, '\n')
    File.Print ("X = \"" | X | '"')
    Println (File, ", Y = \"" | Y | '"')
    IO.Print ("Give me somethin: ")
    var Inp := IO.Readln()
    IO.Println ("You gave me: \"" | Inp | '"')
    File.Println ("User input = \"" | Inp | '"')
    File.Close();

    var Inp_File := File_Input_Stream::Open(IO, Name)
    IO.Println ("Contents of file " | Name)
    loop
        const Line := Inp_File.Readln()
        if Line is null then
            exit loop
        end if
        IO.Println(Line)
    end loop

    IO.Println("All done")

end func PSL::Test::Test_File

interface PSL::Short_Names<> is
   type Int is Univ_Integer<>
   type Char is Univ_Character<>
   type String is Univ_String<>
   type Real is Univ_Real<>
   type Bool is Boolean<>
   interface Arr<Element_Type is Assignable<>> extends Basic_Array<Element_Type> is
   end interface Arr
end interface PSL::Short_Names
