-- Ada202X Prototype Standard Library

-- Copyright (C) 2011-2019, AdaCore, New York, NY
-- To be used only for Personal, Academic, or Evaluation Purposes
-- Not for Commercial Production Use.

package A2X is
end A2X

with A2X.*
package A2X.Core is
end A2X.Core

package A2X.Core.Any is
    type Any is abstract limited null record;
end A2X.Core.Any

package A2X.Core.Assignable is
    type Assignable is abstract null record;

end A2X.Core.Assignable

package A2X.Containers is
end A2X.Containers

package A2X.Test is
end A2X.Test

package A2X.Core.Imageable is
    type Imageable is abstract private;

    abstract function Image(Val : Imageable) return Univ_String

    abstract function Value(Str : Univ_String) return Imageable

    -- NOTE: We include Hashable<> operations here
    --       so that Set<Imageable'Class> works nicely.
    --       Clearly if something is Imageable it is possible
    --       to implement "=?" and Hash using the string image,
    --       so we might as well requires these operations too.

    abstract function "=?"(Left, Right : Imageable) return Ordering
    abstract function Hash(Val : Imageable) return Univ_Integer
end A2X.Core.Imageable

generic
    type Element_Type is new Countable_Base
package A2X.Containers.Countable_Set is

    type Countable_Set is private

    function "[]"() return Countable_Set

    function Singleton(Elem : Element_Type) return Countable_Set

    function ".."(Left, Right : Element_Type) return Countable_Set
    function "<.."(Left, Right : Element_Type) return Countable_Set
    function "..<"(Left, Right : Element_Type) return Countable_Set
    function "<..<"(Left, Right : Element_Type) return Countable_Set

    function "&"(Left, Right : Element_Type) return Countable_Set
    function "&"(Left : Countable_Set; Right : Element_Type) return Countable_Set
    function "&"(Left : Element_Type; Right : Countable_Set) return Countable_Set
    function "&"(Left : Countable_Set; Right : Countable_Set) return Countable_Set

    procedure "&="(Left : in out Countable_Set; Right : Element_Type)
    procedure "&="(Left : in out Countable_Set; Right : Countable_Set)

    procedure "<|="(Left : in out Countable_Set; Right : in out Element_Type)
        -- Move element into set, leaving Right null afterward.

    procedure "<|="(Left : in out Countable_Set; Right : in out Countable_Set)
        -- Move all elements of Right into Left, leaving Right empty.

    function "-"(Left, Right : Countable_Set) return Countable_Set
      -- Set difference
    function "-"(Left : Countable_Set; Right : Element_Type) return Countable_Set
      -- Remove one element
    procedure "-="(S : in out Countable_Set; Elem : Element_Type)
      -- Remove the given element from the set, if present
    procedure "-="(Left : in out Countable_Set; Right : Countable_Set)
      -- Remove all elements of Right from Left, if present

    function "or"(Left : Countable_Set; Right : Countable_Set) 
      return Countable_Set is "&"   -- union
    procedure "or="(Left : in out Countable_Set; Right : Countable_Set) is "&="

    function "+"(Left : Countable_Set; Right : Countable_Set) 
      return Countable_Set is "&"   -- Union
    procedure "+="(Left : in out Countable_Set; Right : Countable_Set) is "&="
    procedure "+="(Left : in out Countable_Set; Right : Element_Type) is "&="
   
    function "and"(Left, Right : Countable_Set) return Countable_Set
        -- Intersection
    procedure "and="(Left : in out Countable_Set; Right : Countable_Set)

    function "xor"(Left, Right : Countable_Set) return Countable_Set
        -- Symmetric difference
    procedure "xor="(Left : in out Countable_Set; Right : Countable_Set)

    function "in"(Left : Element_Type; Right : Countable_Set) return Boolean

    function "=?"(Left, Right : Countable_Set) return Ordering
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise

    function Count(S : Countable_Set) return Univ_Integer

    function "magnitude"(S : Countable_Set) return Univ_Integer renames Count

    function Is_Empty(S : Countable_Set) return Boolean

    function First(S : Countable_Set) return Element_Type
    function Last(S : Countable_Set) return Element_Type

    function Remove_First(S : in out Countable_Set) return Element_Type
        -- Remove first element of set (lowest value)

    function Remove_Last(S : in out Countable_Set) return Element_Type
        -- Remove last element of set (highest value)

    function Remove_Any(S : in out Countable_Set) return Element_Type
        -- Remove an arbitrary element of set

end A2X.Containers.Countable_Set

package A2X.Core.Univ_Integer is
    type Univ_Integer is private;

    function "+"(Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => #identity;

    function "-"(Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => #negate;

    function "abs"(Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => "abs";

    function "magnitude"(Val : Univ_Integer) return Univ_Integer is "abs"

    function "+"(Left, Right : Univ_Integer) return Univ_Integer 
      with Import, External_Name => "+";

    function "-"(Left, Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => "-";

    function "*"(Left, Right : Univ_Integer) return Univ_Integer 
      with Import, External_Name => "*";

    function "/"(Left, Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => "/";

    function "**"(Left, Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => "**";

    function "mod"(Left, Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => "mod";

    function "rem"(Left, Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => "rem";


    procedure "+="(Left : in out Univ_Integer; Right : Univ_Integer) 
      with Import, External_Name => "+=";

    procedure "-="(Left : in out Univ_Integer; Right : Univ_Integer) 
      with Import, External_Name => "-=";

    procedure "*="(Left : in out Univ_Integer; Right : Univ_Integer) 
      with Import, External_Name => "*=";

    procedure "/="(Left : in out Univ_Integer; Right : Univ_Integer) 
      with Import, External_Name => "/=";

    procedure "**="(Left : in out Univ_Integer; Right : Univ_Integer) 
      with Import, External_Name => "**=";


    function "=?"(Left, Right : Univ_Integer) return Ordering
      with Import, External_Name => "=?";

    function Min(Left, Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => #min;
    function Max(Left, Right : Univ_Integer) return Univ_Integer
      with Import, External_Name => #max;

    function Hash(Val : Univ_Integer) return Univ_Integer
      with Import, External_Name => #identity;

    procedure Print(X : Univ_Integer) with Import, External_Name => #print_int;

    procedure Put(X : Univ_Integer) is Print

    function Image(Val : Univ_Integer) return Univ_String
      with Import, External_Name => #to_string_int;

    function Value(Str : Univ_String) return Univ_Integer
      with Import, External_Name => #from_string_int;

    function First() return Univ_Integer
      with Import, External_Name => #univ_integer_first;

    function Last() return Univ_Integer
      with Import, External_Name => #univ_integer_last;

end A2X.Core.Univ_Integer

generic
    type Elem_Type is new Assignable;
    type Index_Type is new Countable;
package A2X.Core.Indexable is
    -- An indexable container
    type Indexable is abstract private

    abstract function "indexing"(A : aliased in out Indexable; Index : Index_Type)
      return access Elem_Type
    abstract function Length(A : Indexable) return Univ_Integer
    function "magnitude"(A : Indexable) return Univ_Integer renames Length
    abstract function "index_set"(A : Indexable) return Countable_Set<Index_Type>
    function Bounds(A : Indexable) return Countable_Set<Index_Type>
      renames "index_set"
end A2X.Core.Indexable

generic
    type Element_Type is new Assignable  -- tbd "is private"
package A2X.Containers.Basic_Array is
  -- Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
    type Basic_Array is private;

    function Create(Length : Univ_Integer; Val : Element_Type)
      return Basic_Array 
      with Import, External_Name => #basic_array_create;
    function "[]"() return Basic_Array is (Create(0, null))
    function "indexing"(V : aliased in out Basic_Array; Index : Univ_Integer) return 
      access Element_Type with Import, External_Name => #basic_array_indexing;
    function "var_indexing"(V : aliased in out Basic_Array; Index : Univ_Integer) return 
      access Element_Type with Import, External_Name => #basic_array_indexing;
    function Length(V : Basic_Array) return Univ_Integer
      with Import, External_Name => #basic_array_length;
    function "magnitude"(V : Basic_Array) return Univ_Integer is Length
    function "&"(Left, Right : Basic_Array) return Basic_Array
    function "&"(Left, Right : Basic_Array) return Basic_Array is "&"
    function "index_set"(A : Basic_Array) return Countable_Set<Univ_Integer>
    procedure "<|="(Left : in out Basic_Array; Right : in out Element_Type)
end A2X.Containers.Basic_Array

package body A2X.Containers.Basic_Array is
  -- Builtin array type, not extendable, indexed by Univ_Integer, 1..Length
    function "&"(Left, Right : Basic_Array) return Basic_Array is
        Left_Len : constant Univ_Integer := Length(Left)

    begin
        if Left_Len = 0 then
            return Right
        end if

        return Result : Basic_Array := Create(Left_Len + Length(Right), null)
          do

           -- Copy the Left elements
           for I in 1..Left_Len parallel loop
               Result[I] := Left[I]
           end loop

           -- Copy the Right elements
           
           for J in 1..Length(Right) parallel loop
               Result[Left_Len + J] := Right[J]
           end loop
        end return;
    exception
        when others =>
           null
    end "&"
            
    function "index_set"(A : Basic_Array) return Countable_Set<Univ_Integer> is
        return 1..Length(A)
    end "index_set"

    procedure "<|="(Left : in out Basic_Array; Right : in out Element_Type) is
        Left_Len : constant := |Left|
        a_loop: declare
           Result : Basic_Array for Left := Create(Left_Len+1, null)

        begin
           for I in 1 .. Left_Len parallel loop
               Result[I] <== Left[I]
           end loop

           Result[Left_Len+1] <== Right

           Left <== Result
        end a_loop
    end "<|="
end A2X.Containers.Basic_Array

procedure A2X.Test.Test_Basic_Array() is
    var A : Basic_Array<Univ_Integer<>> := Create(3, 7)
    A[1] := 42
    A[2] += 6
    A[3] += A[2]
    Print("The answer is: " & (A[1] + A[2] + A[3]) & "\n")
    Print("Length(A) = " & Length(A) & "\n")

    var B := A | A
    Print("Length(B) = " & Length(B) & ", B[5] = " & B[5] & "\n")
    for I in 1..Length(B) forward loop
        Print("B[" & I & "] = " & B[I] & ", ")
    end loop
    Print("\n")
end A2X.Test.Test_Basic_Array
    
generic
    type Element_Type is new Assignable  -- tbd: is private
package A2X.Core.Vector is
  -- Extendable vector, indexed by Univ_Integer, 1..Length
    type Vector is new Indexable<Element_Type, Univ_Integer> with private

    function "[]"() return Vector
    function Create(Length : Univ_Integer; Initial_Value : Element_Type)
      return Vector with Pre => Length >= 0;
    function "indexing"(V : aliased in out Vector; Index : Univ_Integer) return 
      access Element_Type
    function "index_set"(V : Vector) return Countable_Set<Univ_Integer>
    function "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      return Vector  -- a "read-only" slice
    procedure "&="(V : in out Vector; Elem : Element_Type)
    function "&"(Left, Right : Vector) return Vector
    function "&"(Left : Vector; Right : Element_Type) return Vector
    function Length(V : Vector) return Univ_Integer
    function "magnitude"(Vector) return Univ_Integer is Length
end A2X.Core.Vector
    
package body A2X.Core.Vector is
  -- Extendable vector, indexed by Univ_Integer, 1..Length
    Debug : constant Boolean := #False;
    Initial_Size : constant := 4
    Leaf_Vec_Capacity : constant := 256
    Vec_Of_Vec_Length : constant := 256
    Subvec_Capacity : constant Basic_Array<Univ_Integer> :=
      -- Capacity of each subvec at given level
      [Leaf_Vec_Capacity,
       Vec_Of_Vec_Length * Leaf_Vec_Capacity,
       Vec_Of_Vec_Length ** 2 * Leaf_Vec_Capacity]
    Ordinal : constant Basic_Array<Univ_String> :=
      ["th","st","nd","rd","th","th","th","th","th","th"]

    type Vector 
       (Level : Univ_Integer) --  Level = 0 means only Data array
    is record       
       Count       : Univ_Integer := 0;  --  Overall count
       Width       : Univ_Integer := 0;  --  Num Subvecs in use;
                                         --  is 0 if level = 0
       Data        : access Basic_Array<optional Element_Type> := null;
       Subvecs     : access Basic_Array<optional Vector> := null;
    end record;

    procedure Expand_Count(V : in out Vector; Amount : Univ_Integer := 1) is
        -- Expand count by "Amount"
        pragma Assert (Amount > 0);
        --Rep_Ok(V, 1)
        New_Count : constant := V.Count + Amount;

        loop
            var Next_Count := New_Count

            if V.Level = 0 then
                --  A single Basic_Array of elements
                Next_Count := Min (New_Count, Leaf_Vec_Capacity)
                if V.Data is null then
                    --  Very first element
                    if Debug then
                        Println("Very first element");
                    end if;
                    V.Data := Create(Max(Initial_Size, Next_Count), null)
                    --Rep_Ok(V, 5555);
                elsif V.Count = Length(V.Data) or New_Count > Length(V.Data)
                then
                    --  Double the size if below capacity, else add a level
                    if V.Count < Leaf_Vec_Capacity then
                        -- Double the size (up to the max)
                        if Debug then
                            Println("Doubling Data, V.Count was " | V.Count)
                        end if
                        var Old_Data <== V.Data
                        V.Data := Create(Min (Max (2*V.Count, Next_Count),
                                              Leaf_Vec_Capacity), null)
                        for I in 1..V.Count loop
                            V.Data[I] <== Old_Data[I]
                        end loop
                        Old_Data := null
                        --Rep_Ok(V, 6666);
                    else
                        -- Reached maximum, add one level
                        pragma Assert (Next_Count = V.Count);
                        --Rep_Ok(V, 3333);
                        if Debug then
                            Println("Adding second level, V.Count was " |
                              V.Count)
                        end if;
                        var Old_V <== V
                        V := (Level => 1,
                              Count => Next_Count,
                              Width => 2,
                              Subvecs => Create (Vec_Of_Vec_Length, null),
                              Data => null)
                        V.Subvecs[1] <== Old_V
                        V.Subvecs[2] :=
                          (Level => 0, Count => 0, Width => 0,
                           Subvecs => null,
                           Data => Create(Leaf_Vec_Capacity, null));
                        --  Will loop around to extend this two-level structure
                        --Rep_Ok(V, 4444);
                    end if;
                else
                    if Debug then
                        Println(Next_Count | ", " | New_Count);
                    end if;
                end if
            else
                --  Multi-level structure, expand last subvec or add another
                if V.Width > 0 and then
                    V.Subvecs[V.Width].Count < Subvec_Capacity[V.Level]
                then
                    --  Can expand this subvec up to its capacity
                    if Debug then
                        Println("Expand Subvec " | V.Width |
                          ", V.Count was " | V.Count)
                    end if;
                    Last_Subvec renames V.Subvecs[V.Width]
                    Subvec_Increase : constant := Min (New_Count - V.Count,
                      Subvec_Capacity[V.Level] - Last_Subvec.Count)
                    Expand_Count (Last_Subvec, Subvec_Increase);
                    --  Compute next value for V.Count
                    Next_Count := V.Count + Subvec_Increase;
                    --Rep_Ok(V, 7777);
                elsif V.Width < Vec_Of_Vec_Length then
                    --  Add another subvec
                    V.Width += 1
                    if V.Level = 1 then
                        --  Add another leaf vec
                        --  Compute amount in this new leaf vec
                        Amount_In_New_Leaf : constant := Min (Leaf_Vec_Capacity,
                          New_Count - V.Count)

                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " leaf vec, V.Count was " | V.Count |
                                ", adding " | Amount_In_New_Leaf |
                                " in new leaf")
                        end if;

                        V.Subvecs[V.Width] :=
                          (Level => 0, Count => Amount_In_New_Leaf,
                           Width => 0, Subvecs => null,
                           Data => Create(Leaf_Vec_Capacity, null))

                        --  Compute total count of vector
                        Next_Count := V.Count + Amount_In_New_Leaf
                        --Rep_Ok(V, 8888);
                    else
                        --  Add another multi-level subvec
                        if Debug then
                            Println("Add " | V.Width |
                                Ordinal[V.Width mod 10+1] |
                                " level " | V.Level-1 |
                                " sub vec, V.Count was " | V.Count)
                        end if;
                        V.Subvecs[V.Width] :=
                          (Level => V.Level-1,
                           Count => 0,
                           Width => 0,
                           Subvecs => Create(Vec_Of_Vec_Length, null),
                           Data => null)
                        --Rep_Ok(V, 9999);

                        --  Count not increased yet
                        Next_Count := V.Count
                    end if
                else
                    --  Must add another level
                    if Debug then
                        Println("Adding another level, V.Level was " |
                          V.Level | ", V.Count was " | V.Count |
                          ", Next_Count = " | Next_Count)
                    end if;
                    var Old_V <== V
                    V := (Level => Old_V.Level+1,
                          Count => Old_V.Count,
                          Width => 1,
                          Subvecs => Create (Vec_Of_Vec_Length, null),
                          Data => null)
                    V.Subvecs[1] <== Old_V

                    --  Count not increased yet
                    Next_Count := V.Count
                    --  Will loop around to extend this multi-level structure
                end if
            end if
            --Rep_Ok(V, 1212);
            V.Count := Next_Count
            --Rep_Ok(V, 2323);
            if Next_Count = New_Count then
                exit loop
            end if
            if Debug then
                Println("Trying again, Next_Count = " | Next_Count |
                  ", New_Count = " | New_Count)
                Println("V.Level = " | V.Level | ", V.Width = " | V.Width);
            end if;
            --Rep_Ok(V, 2);
        end loop
        --Rep_Ok(V, 2222);
    end Expand_Count;

    function "[]"() return Vector is
        return (Level => 0, Count => 0, Width => 0,
                Data => null, Subvecs => null)
    end "[]"

    function Create(Length : Univ_Integer; Initial_Value : Element_Type)
        return Vector is

        if Length <= Leaf_Vec_Capacity then
            return (Level => 0, Width => 0,
                    Count => Length, Subvecs => null,
                    Data => Create (Length, Initial_Value))
        else
            More_Needed : constant := Length - Leaf_Vec_Capacity;

            var Result : Vector :=
                (Level => 0, Count => Leaf_Vec_Capacity,
                 Width => 0, Subvecs => null,
                 Data => Create (Leaf_Vec_Capacity, Initial_Value))
            Result.Expand_Count(More_Needed);
            if Initial_Value not null then
                for I in 1 .. More_Needed loop
                    Result[Leaf_Vec_Capacity + I] := Initial_Value
                end loop
            end if;
            --Rep_Ok(Result, 3);
            return Result;
        end if;

    end Create

    function Length(V : Vector) return Univ_Integer is
        --Rep_Ok(V, 4);
        return V.Count
    end Length

    function "indexing"(V : aliased in out Vector; Index : Univ_Integer) return 
      access Element_Type is
        --Rep_Ok(V, 5);
        if Index not in 1 .. V.Count then
           --var IO := IO::Get_IO();
           --IO.Stderr.Println( ...
           Println("Vector index " | Index | " out of bounds 1 .. " |
             V.Count)
           pragma Assert (Index in 1..V.Count, "vector_index_out_of_bounds");
        end if
        if V.Level = 0 then
            --  Simple case
            return V.Data[Index]
        else
           Subvec_Size : constant := Subvec_Capacity[V.Level]
           Which_Subvec : constant := (Index-1) / Subvec_Size + 1
           Subvec_Index : constant := (Index-1) mod Subvec_Size + 1
           --  Recurse with appropriate subvec
           return V.Subvecs[Which_Subvec][Subvec_Index]
        end if;
    end "indexing"

    function "slicing"(V : Vector; Index_Set : Countable_Range<Univ_Integer>)
      return Vector is
      -- a "read-only" slice
        --Rep_Ok(V, 6);
        return [for I in Index_Set => V[I]]
    end "slicing"

    function "index_set"(V : Vector) return Countable_Set<Univ_Integer> is
        --Rep_Ok(V, 7);
        return 1..Length(V)
    end "index_set"

    procedure "<|="(V : in out Vector; Elem : in out Element_Type) is
        --Rep_Ok(V, 8);
        Expand_Count(V, Amount => 1)
        --Rep_Ok(V, 9);
        V[V.Count] <== Elem
        --Rep_Ok(V, 10);
    end "<|="

    procedure "&="(V : in out Vector; Elem : Element_Type) is
        --Rep_Ok(V, 11);
        Expand_Count(V, Amount => 1)
        --Rep_Ok(V, 12);
        V[V.Count] := Elem
        --Rep_Ok(V, 13);
    end "&="
    
    procedure "&="(V : in out Vector; Right : Vector) is
        --Rep_Ok(V, 14);
        Orig_Count : constant := V.Count
        if Orig_Count = 0 then
            -- Just copy right
            V := Right;
        elsif Right.Count > 0 then
            -- Grow V, and then copy in Right
            Expand_Count(V, Right.Count)
            for I in 1..Right.Count loop
                --Rep_Ok(V, 15);
                if Debug then
                    Println(V.Level | ", " | V.Count | ", " | V.Width);
                end if;
                V[I+Orig_Count] := Right[I]
                --Rep_Ok(V, 16);
            end loop
        end if
        --Rep_Ok(V, 17);
    end "&="

    function "&"(Left, Right : Vector) return Vector is
        --Rep_Ok(Left, 18);
        --Rep_Ok(Right, 19);
        -- Copy left into result, and then add in the Right elements
    begin
        if Left.Count = 0 then
            -- Left is null Vector; result is determined by Right
            return Right
        else
            -- Start with Left
            return Result : Vector := Left do
               --Rep_Ok(Result, 20);
               Result |= Right
            end return;
        end if
        --Rep_Ok(Result, 21);
    end "&"

    function "&"(Left : Vector; Right : Element_Type) return Vector is
        --Rep_Ok(Left, 22);
        return Result : Vector := Left do
           --Rep_Ok(Result, 23);
           Result |= Right
        end return;
        --Rep_Ok(Result, 24);
    end "&"

end A2X.Core.Vector

procedure A2X.Test.Test_Vector() is
    var V : Vector<Univ_Integer> := []
    var U : Vector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " & V[1] & ", " & V[2])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 1..Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    Println("\"indexing\"(V, 12) := 33;")
    "indexing"(V, 12) := 33
    for I in 1..Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    Slice : constant := V[3..7]
    Println("Slice := V[3..7]")
    for I in 1..Length(Slice) forward loop
        Println("Slice[" & I & "] = " & Slice[I])
    end loop
end A2X.Test.Test_Vector

generic
    type Bound_Type is new Countable
package A2X.Core.Countable_Range is
    -- Simple contiguous Countable_Range of integers (i.e. an interval)
    type Countable_Range is record
       First : constant : Bound_Type
       Last : constant : Bound_Type
    end record Countable_Range

    function ".."(Left, Right : Bound_Type) return Countable_Range
    function "<.."(Left, Right : Bound_Type) return Countable_Range
    function "..<"(Left, Right : Bound_Type) return Countable_Range
    function "<..<"(Left, Right : Bound_Type) return Countable_Range
    function "in"(Val : Bound_Type; Int : Countable_Range) return Boolean
    function Length(R : Countable_Range) return Univ_Integer
    function "magnitude"(Countable_Range) return Univ_Integer is Length
    function "[..]"() return Countable_Range
    function "[]"() return Countable_Range
    function Singleton(Bound : Bound_Type) return Countable_Range

    function Remove_First(S : in out Countable_Range) return Bound_Type
    function Remove_Last(S : in out Countable_Range) return Bound_Type
    function Remove_Any(S : in out Countable_Range) return Bound_Type
end A2X.Core.Countable_Range

package body A2X.Core.Countable_Range is
    function ".."(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left, Last => Right)
    end ".."

    function "<.."(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left+1, Last => Right)
    end "<.."

    function "..<"(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left, Last => Right-1)
    end "..<"

    function "<..<"(Left, Right : Bound_Type) return Countable_Range is
        return (First => Left+1, Last => Right-1)
    end "<..<"

    function "in"(Val : Bound_Type; Int : Countable_Range) return Boolean is
        return Val >= Int.First and then Val <= Int.Last
    end "in"

    function Length(R : Countable_Range) return Univ_Integer is
        return R.Last - R.First + 1
    end Length

    function "[]"() return Countable_Range is
        return Bound_Type'First()+1 .. Bound_Type'First()
    end "[]"

    function "[..]"() return Countable_Range is
        return Bound_Type'First() .. Bound_Type'Last()
    end "[..]"

    function Singleton(Bound : Bound_Type) return Countable_Range is
        return Bound .. Bound
    end Singleton

    function Remove_First(S : in out Countable_Range) 
      return Bound_Type is
        if S.First <= S.Last then
            return Result : Bound_Type := S.First do
               S := (First => S.First+1, Last => S.Last)
            end return;
        else
            return null
        end if
    end Remove_First
  
    function Remove_Last(S : in out Countable_Range) 
      return Bound_Type is
        if S.First <= S.Last then
            return Result : Bound_Type := S.Last do
               S := (First => S.First, Last => S.Last-1)
            end return;
        else
            return null
        end if
    end Remove_Last

    function Remove_Any(S : in out Countable_Range) 
      return Bound_Type is
        if S.First <= S.Last then
            if (S.Last - S.First) mod 2 = 0 then
                return Remove_First(S)
            else
                return Remove_Last(S)
            end if
        else
            return null
        end if
    end Remove_Any

end A2X.Core.Countable_Range

package A2X.Core.Univ_Character is
    type Univ_Character is private;

    procedure Print(C : Univ_Character) with Import, External_Name => #print_char;
    procedure Put(C : Univ_Character) is Print

    function "+"(Left : Univ_Character; Right : Univ_Integer) return Univ_Character
      with Import, External_Name => "+";
    function "+"(Left : Univ_Integer; Right : Univ_Character) return Univ_Character
      with Import, External_Name => "+";

    function "-"(Left : Univ_Character; Right : Univ_Integer) return Univ_Character
      with Import, External_Name => "-";
    function "-"(Left, Right : Univ_Character) return Univ_Integer
      with Import, External_Name => "-";

    function "*"(Left : Univ_Integer; Right : Univ_Character) return Univ_String
      -- Produce specified number of "Right" chars in a row
    function "*"(Left : Univ_Character; Right : Univ_Integer) return Univ_String
      -- Produce specified number of "Left" chars in a row

    function "=?"(Left, Right : Univ_Character) return Ordering
      with Import, External_Name => "=?";

    function Image(Val : Univ_Character) return Univ_String
      with Import, External_Name => #to_string_char;

    function Value(Str : Univ_String) return Univ_Character
      with Import, External_Name => #from_string_char;

    function Hash(Val : Univ_Character) return Univ_Integer
      with Import, External_Name => #identity;

    function First() return Univ_Character
    function Last() return Univ_Character

    function Min(Left, Right : Univ_Character) return Univ_Character
      with Import, External_Name => #min;
    function Max(Left, Right : Univ_Character) return Univ_Character
      with Import, External_Name => #max;

    function ".."(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    function "<.."(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    function "..<"(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    function "<..<"(Left, Right : Univ_Character)
      return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
    function "&"(Left, Right : Univ_Character) return Countable_Set<Univ_Character>
      is of Countable_Set<Univ_Character>
end A2X.Core.Univ_Character
    
package A2X.Core.Univ_String is
    type Univ_String is private;
    procedure Print(Univ_String) with Import, External_Name => #print_string;
    procedure Println(Univ_String) with Import, External_Name => #println_string;
    function Readln() return Univ_String with Import, External_Name => #read_string;

    --  Text_IO-ish equivalents
    procedure Put(Univ_String) is Print
    procedure Put_Line(Univ_String) is Println
    procedure New_Line() is (Put("\n"))
    function Get_Line() return Univ_String with Import, External_Name => #read_string;

    function "*"(Left : Univ_Integer; Right : Univ_String) return Univ_String
     -- Produce specified number of "Right" strings in a row
    function "*"(Left : Univ_String; Right : Univ_Integer) return Univ_String
     -- Produce specified number of "Left" strings in a row

    function "&"(Left, Right : Univ_String) return Univ_String 
      with Import, External_Name => #concat_string;

    function "&"(Left, Right : Univ_String) return Univ_String is "&"

    function "=?"(Left, Right : Univ_String) return Ordering
      with Import, External_Name => #string_compare;

    procedure "&="(Left : in out Univ_String; Right : Univ_String)
      with Import, External_Name => #assign_concat_string;

    procedure "&="(Left : in out Univ_String; Right : Univ_String) is "&="

    function "indexing"(Str : Univ_String; Index : Univ_Integer)
      return Univ_Character
      with Import, External_Name => #string_indexing;
     -- a "read-only" element, indexed 1 .. |Str|

    function "index_set"(Str : Univ_String) return Countable_Set<Univ_Integer>
        -- Return set of indices for string

    function "slicing"(Str : Univ_String;
      Index_Set : Countable_Range<Univ_Integer>) 
      return Univ_String with Import, External_Name => #string_slicing;
        -- a "read-only" slice

    function Length(Str : Univ_String) return Univ_Integer
      with Import, External_Name => #string_length;

    function "magnitude"(Univ_String) return Univ_Integer
      with Import, External_Name => #string_length;

    function Hash(Val : Univ_String) return Univ_Integer
      with Import, External_Name => #identity;

    function "&"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String

    function "&"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String

    procedure "&="(Left : in out Univ_String; Right : Right_Type is Imageable<>)

    function "&"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String

    function "&"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String

    procedure "&="(Left : in out Univ_String; Right : Right_Type is Imageable<>)

    -- Operations to convert to/from a Vector of Univ_Character's
    function To_Vector(Str : Univ_String) return Vector<Univ_Character>
    function From_Vector(Vec : Vector<Univ_Character>) return Univ_String

    function Hex_Image(Val : Univ_Integer) return Univ_String;
    
  implements -- for Imageable

    -- These operations are needed so Univ_String satifies
    -- requirements of "Imageable" interface, but these
    -- operations are not directly callable, to avoid ambiguities.

    function Image(Val : Univ_String) return Univ_String
      with Import, External_Name => #identity;
    function Value(Str : Univ_String) return Univ_String
      with Import, External_Name => #identity;

end A2X.Core.Univ_String
    
procedure Test_Str() is
    var X : Univ_String := "Hello, Sparkeling World";
    Println (X);
    Println ("Hello with a string literal");
    Univ_String'Println (X);
    A2X'Core'Univ_String'Println (X);
    A2X.Core.Univ_String.Println (X);
    Univ_String.Println (X);
    Univ_String.Println ("Hello, Sparkel World with a literal")
end Test_Str

package body A2X.Core.Univ_String is
    subtype Substr_Array is Basic_Array<Univ_String>;

    type Univ_String is record
        Parts : access Substr_Array;
        Dummy : Univ_Integer;  -- make sure this doesn't end up as a wrapper
    end record Univ_String
    function "index_set"(Str : Univ_String) return Countable_Set<Univ_Integer> is
        -- Return set of indices for string
        return 1..|Str|
    end "index_set"

    function "*"(Left : Univ_Integer; Right : Univ_String) return Univ_String is
        -- Produce specified number of "Right" strings in a row
        if Left <= 0 then
            return ""
        elsif Left = 1 then
            return Right
        else
            -- Recurse to produce half-length, and then combine
            Partial : constant : Univ_String := (Left/2) * Right
            if Left mod 2 = 1 then
                return Partial | Partial | Right
            else
                return Partial | Partial
            end if
        end if
    end "*"

    function "*"(Left : Univ_String; Right : Univ_Integer) return Univ_String is
        -- Produce specified number of "Left" strings in a row
        return Right * Left   -- Just pass the buck to other "*"
    end "*"

    function "&"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String is
        return Left | Right_Type'Image(Right)
    end "&"

    function "&"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String is
        return Left_Type'Image(Left) | Right
    end "&"

    procedure "&="(Left : in out Univ_String; Right : Right_Type is Imageable<>) is
        Left |= Right_Type'Image(Right)
    end "&="

    function "&"(Left : Univ_String; Right : Right_Type is Imageable<>) 
      return Univ_String is
        return Left & Right_Type'Image(Right)
    end "&"

    function "&"(Left : Left_Type is Imageable<>; Right : Univ_String)
      return Univ_String is
        return Left_Type'Image(Left) & Right
    end "&"

    procedure "&="(Left : in out Univ_String; Right : Right_Type is Imageable<>) is
        Left &= Right_Type'Image(Right)
    end "&="

    function To_Vector(Str : Univ_String) return Vector<Univ_Character> is
        return [for I in 1 .. |Str| => Str[I]]
    end To_Vector

    function From_Vector(Vec : Vector<Univ_Character>) return Univ_String is
        return (for each C of Vec forward => <""> | C)
    end From_Vector

    function Hex_Image(Val : Univ_Integer) return Univ_String is
       Word_Size : constant := 64
       Max_Digits : constant := Word_Size / 4
       if Val is null then
          return '8' | ((Max_Digits-1)*'0')
       elsif Val = 0 then
          return "0"
       else
          var Vec : Vector<Univ_Character> := Create(Max_Digits, ' ')
          for (V := Val while V != 0;
               Index in 1..Max_Digits reverse)
          loop
             Digit : constant := V mod 16
             if Digit >= 10 then
                Vec[Index] := 'A' + (Digit-10)
             else
                Vec[Index] := '0' + Digit
             end if
    
             if V = Digit then
                return From_Vector(Vec[Index .. Max_Digits])
             else
                continue loop with V => (V - Digit) / 16
             end if
          end loop
          return From_Vector(Vec)
       end if
    end Hex_Image
end A2X.Core.Univ_String

package A2X.Core.Random is
    type Random is private;

    function Start(Seed : Univ_Integer := 1) return Random
      -- Start a new random number sequence with a standard multiplier/modulus

    function Start(Seed : Univ_Integer;
       Mult, Mod : Univ_Integer) return Random
      -- Start a new random number sequence with given multiplier and modulus

    function Next(Seq : in out Random) return Univ_Integer
      -- Get next value in random number sequence
end A2X.Core.Random

package body A2X.Core.Random is
    type Random is record
       Last_Value : Univ_Integer
       Mult : constant : Univ_Integer
       Mod : constant : Univ_Integer
    end record Random

    Debugging : constant : Boolean := #False
    function Start(Seed : Univ_Integer) return Random is
      -- Start a new random number sequence with a standard multiplier/modulus
        return (Last_Value => Seed,
          Mult => 7**5, Mod => 2**31 - 1)
    end Start

    function Start(Seed : Univ_Integer;
      Mult, Mod : Univ_Integer) return Random is
      -- Start a new random number sequence with given multiplier and modulus
        if Debugging then
            Println("Random: Seed = " & Seed & ", Mult = " & Mult &
              ", Mod = " & Mod)
        end if
        return (Last_Value => Seed, Mult => Mult, Mod => Mod)
    end Start

    function Next(Seq : in out Random) return Univ_Integer is
      -- Get next value in random number sequence
        Seq.Last_Value := Seq.Last_Value * Seq.Mult mod Seq.Mod
        return Seq.Last_Value
    end Next
end A2X.Core.Random

procedure A2X.Test.Test_String() is
    U : constant := "tab\t"
    T : constant := U[4]
    Println("U = " & U & ", |U| = " & |U| & ", U[4] = '" & T & "'")
    X : constant := "this is a string"
    Y : constant := X[3]
    pragma Assert (Y = 'i'); -- string indexing problem
    Z : constant := X[6..7]
    pragma assert (Z = "is"); -- string slicing problem, expected 'is', found Z 
    Println("X = " & X & ", X[3] = " & Y & ", X[6..7] = " & Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " & "hello")

    Seven_Xs : constant := "x" * 7
    pragma Assert (Seven_Xs = "xxxxxxx"); -- Char multiplication check

    Println("Here are seven x's: " & Seven_Xs)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)
end A2X.Test.Test_String

package body A2X.Core.Univ_Character is
    type Univ_Character is record
       Pos : Univ_Integer;
    end record;
    function "*"(Left : Univ_Integer; Right : Univ_Character) return Univ_String is
        -- Produce specified number of "Right" chars in a row
        return Left * Image(Right)   
           -- Just pass the buck to the string function
    end "*"

    function "*"(Left : Univ_Character; Right : Univ_Integer) return Univ_String is
        -- Produce specified number of "Left" chars in a row
        return Right * Image(Left)   
           -- Just pass the buck to the string function
    end "*"

    function First() return Univ_Character is
        return (Pos => 0);
    end First

    function Last() return Univ_Character is
        return (Pos => 2**31-1);
    end Last
end A2X.Core.Univ_Character

package A2X.Core.Comparable is
    type Comparable is abstract private; -- new Assignable;
    abstract function "=?"(Left, Right : Comparable) return Ordering
end A2X.Core.Comparable

package A2X.Core.Hashable is
    type Hashable is abstract new Comparable;
    -- Types which aren't ordered nevertheless are often
    -- hashable, which makes it possible to create an efficient
    -- set or map using them as the index type.

    --  function "=?"(Left, Right : Hashable) return Ordering
    --  TBD: overriding of abstracts NYI
    abstract function Hash(Val : Hashable) return Univ_Integer
end A2X.Core.Hashable

generic
    type Element_Type is new Hashable
package A2X.Containers.Set is
  -- A hashed-set module
    type Set is private

    function "[]"() return Set

    function Singleton(Elem : Element_Type) return Set

    function "&"(Left, Right : Element_Type) return Set
    function "&"(Left : Set; Right : Element_Type) return Set
    function "&"(Left : Element_Type; Right : Set) return Set
    function "&"(Left : Set; Right : Set) return Set

    procedure "&="(Left : in out Set; Right : Set)

    procedure "&="(Left : in out Set; Right : Element_Type)
	-- Add element to Set.

    procedure "<|="(Left : in out Set; Right : in out Element_Type)
	-- Move element into Set.

    procedure "<|="(Left : in out Set; Right : in out Set)
	-- Move all elements of Right into Left, leaving Right empty.

    function "in"(Left : Element_Type; Right : Set) return Boolean

    function "=?"(Left, Right : Set) return Ordering
	-- Return #equal if Left and Right have the same elements
	-- Return #less if Left is a proper subset of Right
	-- Return #greater if Left is a proper superset of Right
	-- Return #unordered otherwise

    function "or"(Left, Right : Set) return Set is "&"  -- Union
    procedure "or="(Left : in out Set; Right : Set) is "&="

    function "+"(Left, Right : Set) return Set is "&"   -- Union
    procedure "+="(Left : in out Set; Right : Set) is "&="
    procedure "+="(Left : in out Set; Right : Element_Type) is "&="   -- aka Include

    function "and"(Left, Right : Set) return Set
	-- Intersection
    procedure "and="(Left : in out Set; Right : Set)

    function "xor"(Left, Right : Set) return Set
	-- Symmetric difference
    procedure "xor="(Left : in out Set; Right : Set)

    function "-"(Left, Right : Set) return Set
	-- Set difference

    procedure "-="(Left : in out Set; Right : Set)
	-- Compute Set difference

    procedure "-="(S : in out Set; Elem : Element_Type)   -- aka Exclude
	-- Remove one element, if present

    function Count(S : Set) return Univ_Integer

    function "magnitude"(Set) return Univ_Integer is Count

    function Is_Empty(S : Set) return Boolean

    function Remove_Any(S : in out Set) return Element_Type
      -- Remove and return an arbitrary element of the Set S

    procedure Dump_Statistics(S : Set)
      -- A debugging routine to show bucket sizes of Set

end A2X.Containers.Set

package A2X.Core.Univ_Enumeration is
    type Univ_Enumeration is private;

    function "=?"(Left, Right : Univ_Enumeration) return Ordering 
      with Import, External_Name => #unordered_compare;
    procedure Print(Val : Univ_Enumeration) 
      with Import, External_Name => #print_univ_enum;

    procedure Put(Val : Univ_Enumeration) is Print

    function Image(Val : Univ_Enumeration) return Univ_String
      with Import, External_Name => #to_string_enum;

    function Value(Str : Univ_String) return Univ_Enumeration
      with Import, External_Name => #from_string_enum;

    function Hash(Val : Univ_Enumeration) return Univ_Integer
      with Import, External_Name => #hash_enum;

    function "in"(Left : Univ_Enumeration; Right : Set<Univ_Enumeration>) 
      return Boolean
      is of Set<Univ_Enumeration>

end A2X.Core.Univ_Enumeration

package A2X.Core.Boolean is
    type Boolean is private;

    function "from_univ"(Lit : Univ_Enumeration) 
      return Boolean with Import, External_Name => #ada202x_bool_from_univ,
       Pre => Lit in [#False, #True];

    function "to_univ"(Val : Boolean) return Univ_Enumeration 
      with Import, External_Name => #ada202x_bool_to_univ;

    function False () return Boolean is (#False)

    function True () return Boolean is (#True)

    function "=?"(Left, Right : Boolean) return Ordering
      with Import, External_Name => "=?";
        -- NOTE: #True > #False

    function "not"(Boolean) return Boolean with Import, External_Name => "not";
    function "and"(Left, Right : Boolean) return Boolean with Import, External_Name => "and";
    function "or"(Left, Right : Boolean) return Boolean with Import, External_Name => "or";
    function "xor"(Left, Right : Boolean) return Boolean with Import, External_Name => "xor";

    procedure "and="(Left : in out Boolean; Right : Boolean)
    procedure "or="(Left : in out Boolean; Right : Boolean)
    procedure "xor="(Left : in out Boolean; Right : Boolean)

    function Hash(Val : Boolean) return Univ_Integer
      with Import, External_Name => #identity;

    -- For Imageable
    function Image(Val : Boolean) return Univ_String
    function Value(Str : Univ_String) return Boolean

    -- Operators for Countable
    function "+"(Left : Univ_Integer; Right : Boolean) return Boolean 
      with Import, External_Name => "+";
    function "+"(Left : Boolean; Right : Univ_Integer) return Boolean 
      with Import, External_Name => "+";
    function "-"(Left, Right : Boolean) return Univ_Integer 
      with Import, External_Name => "-";
    function "-"(Left : Boolean; Right : Univ_Integer) return Boolean 
      with Import, External_Name => "-";

    -- TBD: These should be properties some day (e.g. Boolean#first).
    function First() return Boolean is (#False)
    function Last() return Boolean is (#True)

    function Min(Left, Right : Boolean) return Boolean
      with Import, External_Name => #min;
    function Max(Left, Right : Boolean) return Boolean
      with Import, External_Name => #max;

    function ".."(Left, Right : Boolean) return Countable_Set<Boolean>
    function "<.."(Left, Right : Boolean) return Countable_Set<Boolean>
    function "..<"(Left, Right : Boolean) return Countable_Set<Boolean>
    function "<..<"(Left, Right : Boolean) return Countable_Set<Boolean>
    function "&"(Left, Right : Boolean) return Countable_Set<Boolean>
end A2X.Core.Boolean

package body A2X.Core.Boolean is
    subtype Boolean_Set is Countable_Set<Boolean>

    procedure "and="(Left : in out Boolean; Right : Boolean) is
      Left := Left and Right
    end "and="

    procedure "or="(Left : in out Boolean; Right : Boolean) is
      Left := Left or Right
    end "or="

    procedure "xor="(Left : in out Boolean; Right : Boolean) is
      Left := Left xor Right
    end "xor="

    function Image(Val : Boolean) return Univ_String is
      if Val then
          return "#True"
      else
          return "#False"
      end if
    end Image

    function Value(Str : Univ_String) return Boolean is
      if Str = "#True" then
          return #True
      elsif Str = "#False" then
          return #False
      else
          return null
      end if
    end Value

    -- NOTE: For implementation reasons, we put these here rather than defining
    --       them in the interface using "is of Countable_Set<Boolean>"
    function ".."(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'".."(Left, Right)
    end ".."

    function "<.."(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"<.."(Left, Right)
    end "<.."

    function "..<"(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"..<"(Left, Right)
    end "..<"
    function "<..<"(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"<..<"(Left, Right)
    end "<..<"

    function "&"(Left, Right : Boolean) return Countable_Set<Boolean> is
        return Boolean_Set'"&"(Left, Right)
    end "&"
end A2X.Core.Boolean

procedure A2X.Test.Test_Boolean(UX, UY : Univ_Enumeration) is
    X : constant : Boolean := UX
    Y : constant : Boolean := UY

    And_XY : constant := X and Y
    Or_XY : constant := X or Y
    Xor_XY : constant := X xor Y
    Println(X & " and " & Y & " = " & (X and Y))
    Println(X & " or " & Y & " = " & (X or Y))
    Println(X & " xor " & Y & " = " & (X xor Y))

    var XX := X
    XX and= Y
    Println("X and= Y = " & Image (XX))
    XX := X
    XX or= Y
    Println(X & " or= " & Y & " = " & XX)
    XX := X
    XX xor= Y
    Println(X & " xor= " & Y & " = " & XX)
end A2X.Test.Test_Boolean

-- package A2X.Core.Optional is
--     type Optional is abstract private;
--     function "null"() return
--     function "is null"(Optional) return Boolean
-- end A2X.Core.Optional
-- 
package A2X.Core.Ordered is
    type Ordered is abstract new Comparable;
  -- The "=?" operator on Ordered types never return s #unordered
  -- They also provide a Min and Max operator.

  -- Note that Min and Max may be given null operands.
  -- They each return null if both operands are null, and return the
  -- non-null operand if only one of the operands is null.
  -- This allows null to be used as the initial value when computing
  -- the "Max" or "Min" of a possibly-empty sequence, rather than
  -- having to start with the equivalent of negative or positive infinity.

    subtype Full_Ordering is Ordering
      -- {Full_Ordering in #less | #equal | #greater}

    --  function "=?"(Left, Right : Ordered) return Full_Ordering
    --  TBD: overriding of abstracts NYI

    abstract function Min(Left, Right : Ordered) return Ordered
    abstract function Max(Left, Right : Ordered) return Ordered
end A2X.Core.Ordered

generic
    type Element_Type is new Assignable
package A2X.Core.ZVector is
  -- Extendable vector, indexed by Univ_Integer, 0..Length-1
    type ZVector is new Indexable<Element_Type, Univ_Integer> with private

    function "[]"() return ZVector
    function "indexing"(V : aliased in out ZVector; Index : Univ_Integer) return 
      access Element_Type
    function "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      return ZVector
      -- a "read-only" slice
    function "index_set"(V : ZVector) return Countable_Set<Univ_Integer>
    procedure "&="(V : in out ZVector; Elem : Element_Type)
    procedure "&="(V : in out ZVector; Elem : Element_Type) is "&="
    procedure "<|="(V : in out ZVector; Elem : in out Element_Type)
    function "&"(Left, Right : ZVector) return ZVector
    function "&"(Left, Right : ZVector) return ZVector is "&"
    function Length(V : ZVector) return Univ_Integer
    function "magnitude"(ZVector) return Univ_Integer is Length
end A2X.Core.ZVector
    
package body A2X.Core.ZVector is
  -- Extendable ZVector, indexed by Univ_Integer, 0..Length-1
    type ZVector is record
        Vec : Vector<Element_Type>
    end record ZVector

    function "[]"() return ZVector is
        return (Vec => [])
    end "[]"

    function Length(V : ZVector) return Univ_Integer is
        return Length(V.Vec)
    end Length

    function "indexing"(V : aliased in out ZVector; Index : Univ_Integer) return 
      access Element_Type is
        pragma Assert (Index in 0..Length(V.Vec)-1);  -- Index out of bounds
        return V.Vec[Index+1]
    end "indexing"

    function "slicing"(V : ZVector; Index_Set : Countable_Range<Univ_Integer>)
      return ZVector is
      -- a "read-only" slice
        return [for I in Index_Set => V[I]]
    end "slicing"

    function "index_set"(V : ZVector) return Countable_Set<Univ_Integer> is
        return 0..<Length(V.Vec)
    end "index_set"

    procedure "<|="(V : in out ZVector; Elem : in out Element_Type) is
        V.Vec <|= Elem
    end "<|="

    procedure "&="(V : in out ZVector; Elem : Element_Type) is
        V.Vec |= Elem
    end "&="
    
    function "&"(Left, Right : ZVector) return ZVector is
        return (Vec => Left.Vec | Right.Vec)
    end "&"

end A2X.Core.ZVector

procedure A2X.Test.Test_ZVector() is
    var V : ZVector<Univ_Integer> := []
    var U : ZVector<Univ_Integer> := []
    V |= 23
    U |= 24
    V := V | U
    Println("V = " & V[0] & ", " & V[1])
    for I in 1..10 loop
        V |= I
    end loop
    for I in 0..<Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    Println("\"indexing\"(V, 11) := 33;")
    "indexing"(V, 11) := 33
    for I in 0..<Length(V) forward loop
        Println("V[" & I & "] = " & V[I])
    end loop
    Slice : constant := V[3..7]
    Println("Slice := V[3..7]")
    for I in 0..<Length(Slice) forward loop
        Println("Slice[" & I & "] = " & Slice[I])
    end loop
end A2X.Test.Test_ZVector

package A2X.Core.ZString is
  -- A universal string with characters indexed starting at 0
    type ZString is private

    function "from_univ"(Univ : Univ_String) return ZString
      with Import, External_Name => #identity;
    function "to_univ"(ZStr : ZString) return Univ_String
      with Import, External_Name => #identity;

    procedure Print(ZString) with Import, External_Name => #print_string;
    procedure Println(ZString) with Import, External_Name => #println_string;
    function Readln() return ZString with Import, External_Name => #read_string;

    procedure Put(ZString) is Print
    procedure Put_Line(ZString) is Println
    function Get_Line() return ZString with Import, External_Name => #read_string;

    function "*"(Left : Univ_Integer; Right : ZString) return ZString
        -- Produce specified number of "Right" strings in a row
    function "*"(Left : ZString; Right : Univ_Integer) return ZString
        -- Produce specified number of "Left" strings in a row

    function "&"(Left, Right : ZString) return ZString 
      with Import, External_Name => #concat_string;

    function "&"(Left, Right : ZString) return ZString is "&"

    function "=?"(Left, Right : ZString) return Ordering
      with Import, External_Name => #string_compare;

    procedure "&="(Left : in out ZString; Right : ZString)
      with Import, External_Name => #assign_concat_string;

    procedure "&="(Left : in out ZString; Right : ZString) is "&="

    function "indexing"(Str : ZString; Index : Univ_Integer<>) return Univ_Character
        -- a "read-only" element, indexed 0..<Length(Str)

    function "index_set"(Str : ZString) return Countable_Set<Univ_Integer>
        -- Return set of indices for string

    function "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      return ZString
        -- a "read-only" slice

    function Length(Str : ZString) return Univ_Integer
      with Import, External_Name => #string_length;

    function "magnitude"(ZString) return Univ_Integer is Length

    function Hash(Val : ZString) return Univ_Integer
      with Import, External_Name => #identity;

    function "&"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString

    function "&"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString

    procedure "&="(Left : in out ZString; Right : Right_Type is Imageable<>)

    function "&"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString

    function "&"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString

    procedure "&="(Left : in out ZString; Right : Right_Type is Imageable<>)

    -- Operations to convert to/from a ZVector of Univ_Character's
    function To_ZVector(Str : ZString) return ZVector<Univ_Character>
    function From_ZVector(Vec : ZVector<Univ_Character>) return ZString

end A2X.Core.ZString
    
package body A2X.Core.ZString is
  -- A universal string with characters indexed starting at 0
    type ZString is record
        U_Str : Univ_String
    end record ZString

    function "indexing"(Str : ZString; Index : Univ_Integer<>)
      return Univ_Character is
        -- a "read-only" element, indexed 0..<Length(Str)
        return Str.U_Str[Index+1]
    end "indexing"

    function "index_set"(Str : ZString) return Countable_Set<Univ_Integer> is
        -- Return set of indices for string
        return 0 ..< |Str.U_Str|
    end "index_set"

    function "slicing"(Str : ZString;
      Index_Set : Countable_Range<Univ_Integer>) 
      return ZString is
        -- a "read-only" slice
        return (U_Str => Str.U_Str[Index_Set.First <.. Index_Set.Last+1])
    end "slicing"

    function "*"(Left : Univ_Integer; Right : ZString) return ZString is
        -- Produce specified number of "Right" strings in a row
        return (U_Str => Left * Right.U_Str)
    end "*"

    function "*"(Left : ZString; Right : Univ_Integer) return ZString is
        -- Produce specified number of "Left" strings in a row
        return Right * Left   -- Just pass the buck to other "*"
    end "*"

    function "&"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString is
        return (U_Str => Left.U_Str | Right_Type'Image(Right))
    end "&"

    function "&"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString is
        return (U_Str => Left_Type'Image(Left) | Right.U_Str)
    end "&"

    procedure "&="(Left : in out ZString; Right : Right_Type is Imageable<>) is
        Left.U_Str |= Right_Type'Image(Right)
    end "&="

    function "&"(Left : ZString; Right : Right_Type is Imageable<>) 
      return ZString is
        return Left & Right_Type'Image(Right)
    end "&"

    function "&"(Left : Left_Type is Imageable<>; Right : ZString)
      return ZString is
        return Left_Type'Image(Left) & Right
    end "&"

    procedure "&="(Left : in out ZString; Right : Right_Type is Imageable<>) is
        Left &= Right_Type'Image(Right)
    end "&="

    -- Operations to convert to/from a ZVector of Univ_Character's
    function To_ZVector(Str : ZString) return ZVector<Univ_Character> is
        return [for I in 0..<Length(Str) => Str[I]]
    end To_ZVector

    function From_ZVector(Vec : ZVector<Univ_Character>) return ZString is
        return (for each C of Vec forward => <""> | C)
    end From_ZVector

end A2X.Core.ZString

procedure A2X.Test.Test_ZString() is
    U : constant : ZString := "tab\t"
    T : constant := U[3]
    Println("U = " & U & ", Length(U) = " & Length(U) & ", U[4] = '" & T & "'")
    X : constant : ZString := "this is a string"
    Y : constant := X[2]
    pragma Assert (Y = 'i'); -- string indexing problem
    Z : constant := X[5..6]
    pragma Assert (Z = "is"); -- string slicing problem, expected 'is', found Z 
    Println("X = " & X & ", X[2] = " & Y & ", X[5..6] = " & Z)

    Println("About to indent 4 and then print 'hello'")
    Println(4 * " " & "hello")

    Seven_Xes : constant :ZString := "x" * 7
    pragma Assert (Seven_Xes = "xxxxxxx"); -- Char multiplication check

    Println("Here are seven x's: " & Seven_Xes)
    
    Print("Here are 6 y's: ")
    Println('y' * 6)
end A2X.Test.Test_ZString

generic
    type Array_Type is new Indexable
package A2X.Containers.Slice is
  -- A sliceable array.
    type Bounds is record
        First : constant : Array_Type'Index_Type
        Last : constant : Array_Type'Index_Type
    end record Bounds

    type Slice is limited new Bounds with private  -- TBD: Use discriminants

    function Length(S : Slice) return Univ_Integer
        -- Return length of slice (i.e. Last - First + 1)

    function "magnitude"(Slice) return Univ_Integer is Length
        -- Allows use of |...| operator

    function "slicing"(A : aliased in out Array_Type) return access Slice
        -- Convert an array into a slice covering 1..Length(A)

    function "slicing"(A : aliased in out Array_Type;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return access Slice
        -- Slice of an array

    function "slicing"(S : aliased in out Slice;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return access Slice
        -- Slice of a slice

    function "indexing"(S : aliased in out Slice; Index : Array_Type.Index_Type) 
      return access Array_Type.Elem_Type
        -- Index into a slice

    function "index_set"(S : Slice) return Countable_Set<Array_Type.Index_Type>
end A2X.Containers.Slice

package body A2X.Containers.Slice is
    type Slice is limited record
        Arr : access Array_Type
    end record Slice

    function Length(S : Slice) return Univ_Integer is
        -- Return length of slice (i.e. Last - First + 1)
        return S.Last - S.First + 1
    end Length

    function "slicing"(A : aliased in out Array_Type) return access Slice is
        -- Convert an array into a slice covering whole array
        A_Bounds : constant := "index_set"(A)
        return (First => First(A_Bounds), Last => Last(A_Bounds), Arr => A)
    end "slicing"

    function "slicing"(A : aliased in out Array_Type;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return access Slice is
        -- Slice of an array
        A_Bounds : constant := "index_set"(A)
        pragma Assert (Bounds.First > Bounds.Last or else 
          (Bounds.First >= First(A_Bounds) and then 
            Bounds.Last <= Last(A_Bounds))); --slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => A)
    end "slicing"

    function "slicing"(S : aliased in out Slice;
      Bounds : Countable_Range<Array_Type.Index_Type>)
      return access Slice is
        -- Slice of a slice
        pragma Assert (Bounds.First > Bounds.Last or else 
          (Bounds.First >= S.First and then Bounds.Last <= S.Last));
          -- slice out of bounds
        return (First => Bounds.First, Last => Bounds.Last, Arr => S.Arr)
    end "slicing"

    function "indexing"(S : aliased in out Slice; Index : Array_Type.Index_Type) 
      return access Array_Type.Elem_Type is
        -- Index into a slice
        {Index >= S.First and then Index <= S.Last}
          -- array index out of bounds
        return S.Arr[Index]
    end "indexing"
    
    function "index_set"(S : Slice) return Countable_Set<Array_Type.Index_Type> is
        return S.First .. S.Last
    end "index_set"
end A2X.Containers.Slice

generic
    type Elem_Type is new Assignable;
    type Indexed_By is new Countable
package A2X.Containers.Array is
    type Array is new Indexable<Elem_Type, Indexed_By> with private

  -- An array abstraction where the index type is not necessarily
  -- Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)

    function Create(Bounds : Countable_Range<Indexed_By>; Initial_Value : Elem_Type)
      return Array

    function Length(Arr : Array) return Univ_Integer
    function "magnitude"(Array) return Univ_Integer is Length

    function Bounds(Arr : Array) return Countable_Range<Indexed_By>

    function "indexing"(Arr : aliased in out Array; Index : Indexed_By) return access Elem_Type
    function "var_indexing"(Arr : aliased in out Array; Index : Indexed_By) 
      return access var Elem_Type
    function "index_set"(Arr : Array) return Countable_Set<Indexed_By>
    procedure "<|="(Left : in out Array; Right : in out Elem_Type)
    function "&"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>)
      return Array
    function "&"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>)
      return Array is "&"
    function "[]"() return Array
end A2X.Containers.Array

package body A2X.Containers.Array is
  -- An array abstraction where the index type is not necessarily
  -- Univ_Integer, but instead can be any Countable type (e.g. Enum<...>)
    subtype Elem_Array is Basic_Array<Elem_Type>

    type Array is record
        Data : Elem_Array
        Bounds : constant : Countable_Range<Indexed_By>
    end record Array


    function Create(Bounds : Countable_Range<Indexed_By>; Initial_Value : Elem_Type)
      return Array is
        return (Data => Create(Length(Bounds), Initial_Value),
          Bounds => Bounds)
    end Create

    function Length(Arr : Array) return Univ_Integer is
        return Length(Arr.Data)
    end Length

    function Bounds(Arr : Array) return Countable_Range<Indexed_By> is
        return Arr.Bounds
    end Bounds

    function "indexing"(Arr : aliased in out Array; Index : Indexed_By) return access Elem_Type is
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end "indexing"

    function "var_indexing"(Arr : aliased in out Array; Index : Indexed_By) 
      return access Elem_Type is
        if Length(Arr) = 0 then
            -- Create a one-element array
            Arr := (Data => Create(1, null),
              Bounds => Index .. Index)
        elsif Index < Arr.Bounds.First then
            -- Extend below
            Arr := (Data => 
              Elem_Array.Create(Arr.Bounds.First - Index, null) | Arr.Data,
              Bounds => Index .. Arr.Bounds.Last)
        elsif Index > Arr.Bounds.Last then
            -- Extend above
            Arr := (Data => 
              Arr.Data | Elem_Array.Create(Index - Arr.Bounds.Last, null),
              Bounds => Arr.Bounds.First .. Index)
        end if
        return Arr.Data[ Index - Arr.Bounds.First + 1 ]
    end "var_indexing"

    function "index_set"(Arr : Array) return Countable_Set<Indexed_By> is
        return Arr.Bounds.First .. Arr.Bounds.Last
    end "index_set"

    procedure "<|="(Left : in out Array; Right : in out Elem_Type) is
        -- Add Right onto Array
        if Length(Left) = 0 then
            Left := (Data => Create(1, null),
              Bounds => Indexed_By.First() .. Indexed_By.First())
            Left[Indexed_By.First()] <== Right
        else
            Left[Left.Bounds.Last + 1] <== Right
        end if
    end "<|="
    
    function "&"(Left : Array; Right : Key_Value<Indexed_By, Elem_Type>) 
      return Array is
        return Result : Array := Left do
           Result[Right.Key] := Right.Value
        end return;
    end "&"

    function "[]"() return Array is
        return (Data => Create(0, null),
          Bounds => Indexed_By.First()+1 .. Indexed_By.First())
            -- Bounds not meaningful when empty
    end "[]"

end A2X.Containers.Array

procedure A2X.Test.Test_Array() is
    type Color is new Enum< [#red, #green, #blue] >
    type RCB is new Array<Integer<Range => 0..0xFF>, Indexed_By => Color>

    Red : constant : RCB := [#red => 0x33, #green => 0, #blue => 0]
    Blue : constant : RCB := [#red => 0, #green => 0, #blue => 0x33]
    Yellow : constant : RCB := [0, 0x33, 0x33]
    White : constant : RCB := [0xFF, 0xFF, 0xFF]
    
    RCBs : constant : Vector<RCB> := [Red, Blue, Yellow, White]

    for each C of RCBs loop
        Println("#red => " & C[#red] & ", #green => " & C[#green] &
          ", #blue => " & C[#blue])
    end loop
end A2X.Test.Test_Array

generic
    type Content_Type is new Comparable
package A2X.Core.Atomic is
    type Atomic is protected private;

    function Create(Initial_Val : Content_Type) return Atomic
      -- Create an atomic object with given initial value

    procedure Set_Value(locked A : in out Atomic; Val : Content_Type)
      -- Atomically set the new value
      -- TBD: Use atomic hardware instructions eventually

    function Value(locked A : Atomic) return Content_Type
      -- Return the current value
      -- TBD: Use atomic hardware instructions eventually

    function Test_And_Set(locked A : in out Atomic; New_Val : Content_Type) return
      Content_Type
      -- Set Value(A) to New_Val; Return the prior value.

    function Compare_And_Swap(locked A : in out Atomic;
      Expected_Val, New_Val : Content_Type) return Content_Type
      -- If Value(A) = Expected_Val, then set Value(A) to New_Val.
      -- In any case, return the prior value.
end A2X.Core.Atomic

package body A2X.Core.Atomic is
    type Atomic is protected record
        Value : Content_Type
    end record Atomic
    function Create(Initial_Val : Content_Type) return Atomic is
      -- Create an atomic object with given initial value
        return (Value => Initial_Val)
    end Create

    procedure Set_Value(locked A : in out Atomic; Val : Content_Type) is
      -- Atomically set the new value
      -- TBD: Use atomic hardware instructions eventually
        A.Value := Val
    end Set_Value

    function Value(locked A : Atomic) return Content_Type is
      -- Return the current value
      -- TBD: Use atomic hardware instructions eventually
        return A.Value
    end Value

    function Test_And_Set(locked A : in out Atomic; New_Val : Content_Type) return
      Result : Content_Type is
      -- Set Value(A) to New_Val; Return the prior value.
        Result := A.Value
        A.Value := New_Val
    end Test_And_Set

    function Compare_And_Swap(locked A : in out Atomic;
      Expected_Val, New_Val : Content_Type) return Content_Type is
      -- If Value(A) = Expected_Val, then set Value(A) to New_Val.
      -- In any case, return the prior value.
        return Result : Content_Type := A.Value do
           if Result = Expected_Val then
               A.Value := New_Val
           end if
        end return;
    end Compare_And_Swap
end A2X.Core.Atomic

procedure A2X.Test.Test_Atomic(X, Y : Univ_Integer) is
    subtype Atomic_Univ is Atomic<Univ_Integer>
    var AX := Atomic_Univ.Create(X)

    Println("Value(X) = " & Value(AX))

    Set_Value(AX, X+1)
    Println("After Set_Value(" & (X+1) & "), Value(X) = " & Value(AX))

    Z : constant := Test_And_Set(AX, Y)
    Println("Test_And_Set(X, " & Y & ") = " & Z)

    CAS : constant := Compare_And_Swap(AX, Expected_Val => X-1, New_Val => Y-1)
    Println("Compare_And_Swap(X, " & (X-1) & ", " & (Y-1) & 
      ") = " & CAS & ", Value(X) = " & Value(AX))

    CAS2 : constant := Compare_And_Swap(AX, Y, Y-2)
    Println("Compare_And_Swap(X, " & Y & ", " & (Y-2) & 
      ") = " & CAS2 & ", Value(X) = " & Value(AX))

end A2X.Test.Test_Atomic

package A2X.Core.Countable_Base is
    type Countable_Base is abstract new Ordered
    --  TBD: All operations should be declared "abstract"
    --       unless perhaps we allow the whole package to be declared "abstract"

    abstract
      function "+"(Left : Countable_Base; Right : Univ_Integer)
        return Countable_Base
    abstract
      function "+"(Left : Univ_Integer; Right : Countable_Base)
        return Countable_Base

    abstract
      function "-"(Left : Countable_Base; Right : Univ_Integer)
        return Countable_Base
    abstract
      function "-"(Left, Right : Countable_Base) return Univ_Integer

    --  function "=?"(Left, Right : Countable_Base) return Ordered.Full_Ordering
    --  TBD: Overriding of abstracts NYI

    abstract
      function First() return Countable_Base

    abstract
      function Last() return Countable_Base

    --  function Hash(Val : Countable_Base) return Univ_Integer
    --  TBD: Overriding of abstracts NYI
end A2X.Core.Countable_Base

generic
    type Bound_Type is new Comparable
package A2X.Core.Closed_Interval is
    -- This provides a simple "closed" interval X..Y
    -- If a type is countable, then half-open or fully open intervals
    -- can be converted into the equivalent closed interval.
    type Closed_Interval is record
       Low : Bound_Type
       High : Bound_Type
    end record Closed_Interval

    function "in"(Left : Bound_Type; Right : Closed_Interval) return Boolean
    function "=?"(Left, Right : Closed_Interval) return Ordering
end A2X.Core.Closed_Interval

package body A2X.Core.Closed_Interval is
    function "in"(Left : Bound_Type; Right : Closed_Interval) return Boolean is
        return Left >= Right.Low and then Left <= Right.High
    end "in"

    function "=?"(Left, Right : Closed_Interval) return Ordering is
        -- Compare two intervals, and consider them #unordered
        -- if they overlap at all, unless they are identical.
        -- If they don't overlap, then return #less or #greater as appropriate.

        if Left.High < Right.Low then
            return #less
        elsif Left.Low > Right.High then
            return #greater
        elsif Left.Low = Right.Low and then
          Left.High = Right.High then
            return #equal
        else
            return #unordered
        end if
    end "=?"

end A2X.Core.Closed_Interval

generic
    type Element is new Comparable

package A2X.Core.AA_Tree is

    -- This module implements a balanced "AA" tree, originally
    -- described by Arne Andersson in the "Proceedings of the Workshop
    -- on Algorithms and Data Structures," pp 60-71, Springer Verlag, 1993.
    -- The following algorithm and descriptions were taken from the
    -- WikiPedia article on AA_Tree: 
    --       http://en.wikipedia.org/wiki/AA_tree
    -- Note that various additional checks for a null tree have been added.

    -- Only two operations are needed for maintaining balance in an AA tree.
    -- These operations are called skew and split. Skew is a right rotation
    -- when an insertion or deletion creates a left horizontal link. Split
    -- is a conditional left rotation when an insertion or deletion creates two
    -- horizontal right links, which once again corresponds to two
    -- consecutive red links in red-black trees.

    type AA_Tree is private

    function "[]"() return AA_Tree
        -- Create an empty tree

    procedure Insert(T : in out AA_Tree; X : Element)
        -- input: X, the value to be inserted, and 
        -- T, the root of the tree to insert it into.
        -- output: A balanced T' including X.

    procedure Delete(T : in out AA_Tree; X : Element)
        -- input: X, the value to delete, and T, 
        -- the root of the tree from which it should be deleted.
        -- output: T', balanced, without the value X.

    function "in"(X : Element; T : AA_Tree) return Boolean

    function Overlapping(T : AA_Tree; X : Element) return Element
        -- input: X, the value to find, and T, 
        -- the root of the tree to be searched.
        -- output: the element equal to or "unordered" relative to X.

    procedure "&="(T : in out AA_Tree; X : Element) is Insert

    procedure "<|="(T : in out AA_Tree; X : in out Element)
        -- Move X into AA_Tree, leaving X null.

    function First(T : AA_Tree) return Element
      -- Return first (smallest) element in tree

    function Last(T : AA_Tree) return Element
      -- Return last (greatest) element in tree

    function Remove_First(T : in out AA_Tree) return Element
      -- Remove first (smallest) element in tree

    function Remove_Last(T : in out AA_Tree) return Element
      -- Remove last (greatest) element in tree

    function Remove_Any(T : in out AA_Tree) return Element
      -- Remove some element from tree

    function Count(T : AA_Tree) return Univ_Integer
      -- Return a count of the nodes in the tree

    function "magnitude"(AA_Tree) return Univ_Integer is Count

    function Is_Empty(T : AA_Tree) return Boolean
      -- Return True if the tree is empty

end A2X.Core.AA_Tree

package body A2X.Core.AA_Tree is
    type AA_Tree is record
       Value : Element
       Level : Univ_Integer := 0
       Left : access AA_Tree
       Right : access AA_Tree
    end record AA_Tree

    function Node(Value : in out Element; Level : Univ_Integer;
      Left, Right : AA_Tree) return AA_Tree is
        -- Create a new tree; move Value into it.
        return (Value <== Value, Level => Level, Left => Left, Right => Right)
    end Node

    function Is_Leaf(T : AA_Tree) return Boolean is
        return T not null and then
          T.Left is null and then T.Right is null
    end Is_Leaf

    function Leftmost(T : access AA_Tree) return access AA_Tree is
        for L => T loop
            if L not null and then L.Left not null then
                -- Continue with Left until we reach null
                continue loop with L => L.Left
            else
                -- Found left-most
                return L
            end if
        end loop
    end Leftmost

    function Successor(T : AA_Tree) return Element is
        -- Return element in tree greater than but closest to T.Value
        if T.Right not null then
            Succ : constant := Leftmost(T.Right)
            {Succ not null}
            return Succ.Value
        else
            return null
        end if
    end Successor

    function Rightmost(T : access AA_Tree) return access AA_Tree is
        for R => T loop
            if R not null and then R.Right not null then
                -- Keep following down Right side
                continue loop with R => R.Right
            else
                -- Found right-most
                return R
            end if
        end loop
    end Rightmost

    function Predecessor(T : AA_Tree) return Element is
        -- Return element in tree less than but closest to T.Value
        if T.Left not null then
            return Rightmost(T.Left).Value
        else
            return null
        end if
    end Predecessor

    procedure Skew(T : in out AA_Tree) is
      -- input: T, a node representing an AA tree that needs to be rebalanced.
      -- output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Left not null and then
          T.Left.Level = T.Level then
            -- The current T.Left becomes new root

            -- Exchange value of T.Left with root
            T.Value <=> T.Left.Value
           
            -- Move old root and T.Left.Right over to right side of tree
            T.Left.Right <=> T.Right
            T.Left.Left <=> T.Right
            T.Left <=> T.Right
        end if
    end Skew

    procedure Split(T : in out AA_Tree) is
        -- input: T, a node representing an AA tree that needs to be rebalanced.
        -- output: T' Another node representing the rebalanced AA tree.

        if T not null and then
          T.Right not null and then
          T.Right.Right not null and then
          T.Level = T.Right.Right.Level then
            -- T.Right becomes the new root
            -- Exchange value and level between root and T.Right
            T.Value <=> T.Right.Value
            T.Level <=> T.Right.Level

            -- Move old root and T.Right.Left to left side of tree
            T.Left <=> T.Right.Right
            T.Right.Left <=> T.Right.Right
            T.Left <=> T.Right

            -- Increment level
            T.Level += 1
        end if
    end Split

    procedure Decrease_Level(T : in out AA_Tree) is
        -- input: T, a tree for which we want to remove links that skip levels.
        -- output: T with its level decreased.

        if T is null then
            return
        end if
           
        var Should_Be : Univ_Integer := 1

        if T.Left not null then
            Should_Be := T.Left.Level + 1
        end if

        if T.Right not null then
            Should_Be := Min(Should_Be, T.Right.Level + 1)
        end if
            
        if Should_Be < T.Level then
            T.Level := Should_Be
            if T.Right not null and then
              Should_Be < T.Right.Level then
                T.Right.Level := Should_Be
            end if
        end if
    end Decrease_Level


    function "[]"() return AA_Tree is
        -- Create an empty tree
        return null
    end "[]"

    -- Insertion begins with the normal binary tree search and insertion
    -- procedure. Then, as the call stack unwinds (assuming a recursive
    -- implementation of the search), it's easy to check the validity of the
    -- tree and perform any rotations as necessary. If a horizontal left link
    -- arises, a skew will be performed, and if two horizontal right links
    -- arise, a split will be performed, possibly incrementing the level of the
    -- new root node of the current subtree. Note, in the code as given above,
    -- the increment of T.Level. This makes it necessary to continue checking
    -- the validity of the tree as the modifications bubble up from the leaves.
    
    procedure "<|="(T : in out AA_Tree; X : in out Element) is
      -- Move X into AA_Tree, leaving X null.
        -- input: X, the value to be inserted, and 
        -- T, the root of the tree to insert it into.
        -- output: A balanced T' including X.

        -- Do the normal binary tree insertion procedure. 
        -- Set the result of the recursive call to the correct 
        -- child in case a new node was created or the
        -- root of the subtree changes.

        if T is null then
            -- Create a new leaf node with X.
            T := Node(X, 1, null, null)
            return
        end if

        case X =? T.Value is
          when #less =>
            T.Left <|= X
          when #greater =>
            T.Right <|= X
          when #equal | #unordered =>
            -- Note that the case is X = T.Value is unspecified. 
            -- As given, an insert will have no effect. 
            -- The implementor may desire different behavior.
            X := null
            return
        end case

        -- Perform skew and then split. 
        -- The conditionals that determine whether or
        -- not a rotation will occur or not are inside 
        -- of the procedures, as given above.

        Skew(T)
        Split(T)
    end "<|="

    procedure Insert(T : in out AA_Tree; X : Element) is
      -- Just pass the buck to the "<|=" operation
        var X_Copy for T := X
        T <|= X_Copy
    end Insert

    -- As in most balanced binary trees, the deletion of an internal node can
    -- be turned into the deletion of a leaf node by swapping the internal node
    -- with either its closest predecessor or successor, depending on which are
    -- in the tree or on the implementor's whims. Retrieving a predecessor is
    -- simply a matter of following one left link and then all of the remaining
    -- right links. Similarly, the successor can be found by going right once
    -- and left until a null pointer is found. Because of the AA property of
    -- all nodes of level greater than one having two children, the successor
    -- or predecessor node will be in level 1, making their removal trivial.
    -- 
    -- To re-balance a tree, there are a few approaches. The one described by
    -- Andersson in his original paper is the simplest, and it is described
    -- here, although actual implementations may opt for a more optimized
    -- approach. After a removal, the first step to maintaining tree validity
    -- is to lower the level of any nodes whose children are two levels below
    -- them, or who are missing children. Then, the entire level must be skewed
    -- and split. This approach was favored, because when laid down
    -- conceptually, it has three easily understood separate steps:
    -- 
    --     Decrease the level, if appropriate.
    --     Skew the level.
    --     Split the level.
    -- 
    -- However, we have to skew and split the entire level this time instead of
    -- just a node, complicating our code.

    procedure Delete(T : in out AA_Tree; X : Element) is
        -- input: X, the value to delete, and T, 
        -- the root of the tree from which it should be deleted.
        -- output: T', balanced, without the value X.

        if T is null then
            -- Not in tree -- should we complain?
            return
        end if

        case X =? T.Value is
          when #less =>
            Delete(T.Left, X)
          when #greater =>
            Delete(T.Right, X)
          when #equal =>
            -- If we're a leaf, easy, otherwise reduce to leaf case. 
            if Is_Leaf(T) then
                T := null
            elsif T.Left is null then
                -- Get successor value and delete it from right tree,
                -- and set root to have that value
                Succ : constant := Successor(T)
                Delete(T.Right, Succ)
                T.Value := Succ
            else
                -- Get predecessor value and delete it from left tree,
                -- and set root to have that value
                Pred : constant := Predecessor(T)
                Delete(T.Left, Pred)
                T.Value := Pred
            end if
          when #unordered =>
            -- Not in tree; should we complain?
            return
        end case

        -- Rebalance the tree. Decrease the level of all nodes in this level if
        -- necessary, and then skew and split all nodes in the new level.

        if T is null then
            return
        end if

        Decrease_Level(T)
        Skew(T)
        Skew(T.Right)
        if T.Right not null then
            Skew(T.Right.Right)
        end if
        Split(T)
        Split(T.Right)
    end Delete

    function "in"(X : Element; T : AA_Tree) return Boolean is
        for P => T while P not null loop
            case X =? P.Value is
              when #less =>
                continue loop with P => P.Left
              when #greater =>
                continue loop with P => P.Right
              when #equal =>
                return #True
              when #unordered =>
                return #False
            end case
        end loop
        return #False   -- Not found
    end "in"

    function First(T : AA_Tree) return Element is
      -- Return first (smallest) element in tree
        if T is null then
            return null
        else 
            return Leftmost(T).Value
        end if
    end First

    function Last(T : AA_Tree) return Element is
      -- Return last (greatest) element in tree
        if T is null then
            return null
        else
            return Rightmost(T).Value
        end if
    end Last


    function Remove_First(T : access AA_Tree)
      return access Element is
      -- Remove first (smallest) element in tree
        return Result : access Element := First(T) do
           if Result not null then
               Delete(T, Result)
           end if
        end return;
    end Remove_First

    function Remove_Last(T : access AA_Tree)
      return access Element is
      -- Remove last (greatest) element in tree
        return Result : access Element := Last(T) do
           if Result not null then
               Delete(T, Result)
           end if
        end return;
    end Remove_Last

    function Remove_Any(T : access AA_Tree)
      return access Element is
      -- Remove some element from tree
        if T is null then
            return null
        end if
        return Result : access Element := T.Value do
           if Result not null then
               Delete(T, Result)
           end if
        end return;
    end Remove_Any

    function Is_Empty(T : access AA_Tree) return Boolean is
      -- Return True if the tree is empty
        return T is null
    end Is_Empty

    function Count(T : access AA_Tree) return Univ_Integer is
      -- Return a count of the nodes in the tree
        if T is null then
            return 0
        else
            return Count(T.Left) + Count(T.Right) + 1
        end if
    end Count

    function Overlapping(T : access AA_Tree; X : Element)
      return Element is
        -- input: X, the value to find, and T, 
        -- the root of the tree to be searched.
        -- output: the element equal to or "unordered" relative to X.
        if T is null or else T.Value is null then
            return null
        else
            case X =? T.Value is
              when #less =>
                return Overlapping(T.Left, X)
              when #greater =>
                return Overlapping(T.Right, X)
              when #equal | #unordered =>
                -- Close enough
                return T.Value
            end case
        end if
    end Overlapping

end A2X.Core.AA_Tree

package body A2X.Containers.Countable_Set is

    subtype Element_Interval is Closed_Interval<Element_Type>

    type Countable_Set is record
        Items : access AA_Tree<Element_Interval>
    end record Countable_Set


    function "[]"() return Countable_Set is
        return (Items => [])
    end "[]"

    function Singleton(Elem : Element_Type) return Countable_Set is
        return Result : Countable_Set := [] do
           Result.Items |= (Low => Elem, High => Elem)
        end return;
    end Singleton

    function ".."(Left, Right : Element_Type) return Countable_Set is
        return Result : Countable_Set := [] do
           if Left <= Right then
               Result.Items |= (Low => Left, High => Right)
           end if
        end return;
    end ".."
    
    function "<.."(Left, Right : Element_Type) return Countable_Set is
        return Result : Countable_Set := [] do
           if Left < Right then
               Result.Items |= (Low => Left+1, High => Right)
           end if
        end return;
    end "<.."
    
    function "<..<"(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left < Right-1 then
            Result.Items |= (Low => Left+1, High => Right-1)
        end if
    end "<..<"
    
    function "..<"(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, High => Right-1)
        end if
    end "..<"
    
    function "&"(Left, Right : Element_Type) return Result : Countable_Set is
        Result := []
        if Left >= Right-1 and then Left <= Right + 1 then
            -- Can combine elements into a single interval
            if Left <= Right then
                Result.Items |= (Low => Left, High => Right)
            else
                Result.Items |= (Low => Right, High => Left)
            end if
        else
            -- Make each element its own interval
            Result.Items |= (Low => Left, High => Left)
            Result.Items |= (Low => Right, High => Right)
        end if
    end "&"

    function "&"(Left : Countable_Set; Right : Element_Type) 
      return Result : Countable_Set is
        Result := Left
        Result |= Right
    end "&"

    function "&"(Left : Element_Type; Right : Countable_Set) return Countable_Set is
        return Right | Left
    end "&"

    function "&"(Left : Countable_Set; Right : Countable_Set) 
      return Result : Countable_Set is
        Result := Left
        Result |= Right
    end "&"

    procedure "&="(Left : in out Countable_Set; Right : Element_Type) is
        Right_IV : constant : Element_Interval := (Low => Right, High => Right)
        Left_IV : constant := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            -- Nothing overlaps, need to add it (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end "&="

    procedure "<|="(Left : in out Countable_Set; Right : in out access Element_Type) is
        -- Move element into set, leaving Right null afterward.
        -- NOTE: No copy minimization done for countable types.
        Left |= Right
        Right := null
    end "<|="

    procedure "<|="(Left : in out Countable_Set; Right : in out Countable_Set) is
        -- Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) = 0 then
            Left.Items <== Right.Items
        else
            -- Iterate through the tree
            loop
                -- Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)

                if Right_IV is null then
                    return   -- All done
                end if

                -- See whether it overlaps with an existing interval
                -- in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    if Left_IV.Low <= Right_IV.Low and then
                      Left_IV.High >= Right_IV.High then
                        -- Right_IV is subsumed; nothing to add in
                        Right_IV := null
                        exit loop
                    else
                        -- Need to delete Left_IV and incorporate
                        -- into Right_IV
                        Delete(Left.Items, Left_IV)
                        if Left_IV.Low < Right_IV.Low then
                            Right_IV.Low := Left_IV.Low
                        end if
                        if Left_IV.High > Right_IV.High then
                            Right_IV.High := Left_IV.High
                        end if

                        -- Now see if there is anything still overlapping
                        Left_IV := Overlapping(Left.Items, Right_IV)
                    end if
                end loop

                if Right_IV not null then
                    -- Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end "<|="

    procedure "&="(Left : in out Countable_Set; Right : Countable_Set) is
        -- Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end "&="

    function "-"(Left, Right : Countable_Set) return Result : Countable_Set is
      -- Set difference
        Result := Left
        Result -= Right
    end "-"

    function "-"(Left : Countable_Set; Right : Element_Type)
      return Result : Countable_Set is
      -- Remove one element
        Result := Left
        Result -= Right
    end "-"
        
    procedure "-="(S : in out Countable_Set; Elem : Element_Type) is
      -- Remove the given element from the set, if present
        IV : constant := Overlapping(S.Items, (Low => Elem, High => Elem))
          -- Get interval, if any, which overlaps given element

        if IV not null then
            -- Delete interval and put back after removing Elem
            Delete(S.Items, IV)
            if IV.High > IV.Low then
                -- We need to put something back
                if IV.Low = Elem then
                    S.Items |= (Low => IV.Low + 1, High => IV.High)
                elsif IV.High = Elem then
                    S.Items |= (Low => IV.Low, High => IV.High-1)
                else
                    -- Elem is in the middle, put back intervals
                    -- on either side.
                    S.Items |= (Low => IV.Low, High => Elem-1)
                    S.Items |= (Low => Elem+1, High => IV.High)
                end if
            end if
        end if

    end "-="

    procedure "-="(Left : in out Countable_Set; Right : Countable_Set) is
      -- Remove all elements of Right from Left, if present
        for Elem in Right loop
            Left -= Elem
        end loop
    end "-="

    function "and"(Left, Right : Countable_Set) return Result : Countable_Set is
        -- Intersection
        Result := []
        for Elem in Right loop
            if Elem in Left then
                Result += Elem
            end if
        end loop
    end "and"

    procedure "and="(Left : in out Countable_Set; Right : Countable_Set) is
        -- Intersection
        for Elem in Left loop
            if Elem not in Right then
                Left -= Elem
            end if
        end loop
    end "and="

    function "xor"(Left, Right : Countable_Set) return Result : Countable_Set is
        -- Symmetric difference
        Result := Left
        Result xor= Right
    end "xor"

    procedure "xor="(Left : in out Countable_Set; Right : Countable_Set) is
        -- Symmetric difference
        -- Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end "xor="

    function "in"(Left : Element_Type; Right : Countable_Set) return Boolean is
        return Overlapping(Right.Items, (Low => Left, High => Left)) not null
    end "in"

    function "=?"(Left, Right : Countable_Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            -- Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                -- Left is a superset
                return #greater
            end if
        else
            -- Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                -- Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end "=?"

    function Count(S : Countable_Set) return Result : Univ_Integer is
        -- Return count of items in set

        Result := 0

        -- Copy items and then iterate through them to build up count
        var Items := S.Items
        var Next_IV := Remove_Any(Items)
        while Next_IV not null loop
            Result += Next_IV.High - Next_IV.Low + 1
            Next_IV := Remove_Any(Items)
        end loop
    end Count

    function Is_Empty(S : Countable_Set) return Boolean is
        return Is_Empty(S.Items)
    end Is_Empty

    function First(S : Countable_Set) return Element_Type is
        First_IV : constant := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end First

    function Last(S : Countable_Set) return Element_Type is
        Last_IV : constant := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end Last

    function Remove_First(S : in out Countable_Set) 
      return Result : access Element_Type is
        -- Return first element of set

        -- Get first interval in tree
        var First_IV := Remove_First(S.Items)
        if First_IV is null then
            -- Tree is empty
            return null
        end if

        -- See whether interval has more than one value in it
        if First_IV.High > First_IV.Low then
            -- Need to put back the remainder
            S.Items |= (Low => First_IV.Low+1, High => First_IV.High)
        end if

        -- Return first item
        return First_IV.Low
    end Remove_First

    function Remove_Last(S : in out Countable_Set) return Result : access Element_Type is
        -- Remove last element of set

        -- Get Last interval in tree
        var Last_IV := Remove_Last(S.Items)
        if Last_IV is null then
            -- Tree is empty
            return null
        end if

        -- See whether interval has more than one value in it
        if Last_IV.High > Last_IV.Low then
            -- Need to put back the remainder
            S.Items |= (Low => Last_IV.Low, High => Last_IV.High-1)
        end if

        -- Return Last item
        return Last_IV.High
    end Remove_Last

    function Remove_Any(S : in out Countable_Set) return Element_Type is
        -- Remove any element of set

        -- Get any interval in tree
        var Any_IV := Remove_Any(S.Items)
        if Any_IV is null then
            -- Tree is empty
            return null
        end if

        -- See whether interval has more than one value in it
        if Any_IV.High > Any_IV.Low then
            -- Need to remove one to return and put back the remainder
            if (Any_IV.High - Any_IV.Low) mod 2 = 0 then
                -- Return high bound when high-low is even
                -- NOTE: We do this to avoid having algorithms become
                --       dependent on always getting values in ascending 
                --       or descending order.
                S.Items |= (Low => Any_IV.Low, High => Any_IV.High-1)
                return Any_IV.High
            else
                -- Return low bound when high-low is odd
                S.Items |= (Low => Any_IV.Low+1, High => Any_IV.High)
                return Any_IV.Low
            end if
        else
            -- Return only item in interval
            return Any_IV.Low
        end if

    end Remove_Any

end A2X.Containers.Countable_Set

procedure A2X.Test.Test_Countable_Set(A, X, Y, Z : Integer) is
    var S : Countable_Set<Integer> := X | Y..Z
    Println(A & " in " & X & "&" & Y & ".." & Z & "=" & ( A in S ))

    Agg : constant : Countable_Set<Integer> := [X, Y, Z]
    Or : constant : Countable_Set<Integer> := Y | Z | X

    Println(" [X, Y, Z] =? (Y | Z | X) --> " & ( Agg =? Or ))

    for J in S loop 
        Println("Remove_Any(S) = " & J)
    end loop

    S := []

    for I in 1..10 forward loop
        S += I
        Println("Adding " & I & " to S, Count = " & Count(S))
    end loop

    for K in S loop 
        Println("Remove_Any(S) = " & K)
    end loop

    Println("Count(S) = " & Count(S))
    S -= 7
    Println("After S -= 7, Count(S) = " & Count(S))

    var Xor := S xor [2, 5, 12, 15]
    Print("S xor [2, 5, 12, 15] = ")
    for J in Xor forward loop
        Print(J & " ")
    end loop
    Print("\n")
end A2X.Test.Test_Countable_Set

package A2X.Core.Countable is
    type Countable is abstract new Countable_Base

    --  The following 8 ops are inherited (TBD: overriding NYI)

    --  function "+"(Left : Countable; Right : Univ_Integer) return Countable
    --  function "+"(Left : Univ_Integer; Right : Countable) return Countable

    --  function "-"(Left : Countable; Right : Univ_Integer) return Countable
    --  function "-"(Left, Right : Countable) return Univ_Integer

    --  function "=?"(Left, Right : Countable) return Ordered.Full_Ordering

    --  function First() return Countable

    --  function Last() return Countable

    --  function Hash(Val : Countable) return Univ_Integer

    --  TBD: operations (or package?) should be declared abstract

    abstract
      function ".."(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract
      function "<.."(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract
      function "..<"(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract
      function "<..<"(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
    abstract function "&"(Left, Right : Countable) return Countable_Set<Countable>
      is of Countable_Set<Countable>
end A2X.Core.Countable

package A2X.Core.Ordering is
    type Ordering is private;

    function "from_univ"(Lit : Univ_Enumeration) 
      {Lit in [#less, #equal, #greater, #unordered]}
      return Ordering with Import, External_Name => #ordering_from_univ;

    function "to_univ"(Val : Ordering) return Univ_Enumeration 
      with Import, External_Name => #ordering_to_univ;

    function "to_bool"(Ord : Ordering; Mask : Univ_Integer) return Boolean 
      with Import, External_Name => #ordering_to_bool;

    function "=?"(Left, Right : Ordering) return Ordering with Import, External_Name => "=?";

    function Hash(Val : Ordering) return Univ_Integer
      with Import, External_Name => #identity;

    -- For Imageable
    function Image(Val : Ordering) return Univ_String
    function Value(Str : Univ_String) return Ordering

    -- Operators for Countable
    function "+"(Left : Univ_Integer; Right : Ordering) return Ordering 
      with Import, External_Name => "+";
    function "+"(Left : Ordering; Right : Univ_Integer) return Ordering 
      with Import, External_Name => "+";
    function "-"(Left, Right : Ordering) return Univ_Integer 
      with Import, External_Name => "-";
    function "-"(Left : Ordering; Right : Univ_Integer) return Ordering 
      with Import, External_Name => "-";

    -- TBD: These should be properties some day (e.g. Ordering#first).
    function First() return Ordering
    function Last() return Ordering

    function Min(Left, Right : access Ordering) return Ordering
      with Import, External_Name => #min;
    function Max(Left, Right : access Ordering) return Ordering
      with Import, External_Name => #max;

    function ".."(Left, Right : Ordering) return Countable_Set<Ordering>
    function "<.."(Left, Right : Ordering) return Countable_Set<Ordering>
    function "..<"(Left, Right : Ordering) return Countable_Set<Ordering>
    function "<..<"(Left, Right : Ordering) return Countable_Set<Ordering>
    function "&"(Left, Right : Ordering) return Countable_Set<Ordering>
end A2X.Core.Ordering

package body A2X.Core.Ordering is
    subtype Ordering_Set is Countable_Set<Ordering>

    function First() return Ordering is
        return #less
    end First

    function Last() return Ordering is
        return #unordered
    end Last

    function Image(Val : Ordering) return Univ_String is
        case Val is
          when #less =>
            return "#less"
          when #equal =>
            return "#equal"
          when #greater =>
            return "#greater"
          when #unordered =>
            return "#unordered"
        end case
    end Image

    function Value(Str : Univ_String) return Ordering is
        case Str is
          when "#less" =>
            return #less
          when "#equal" =>
            return #equal
          when "#greater" =>
            return #greater
          when "#unordered" =>
            return #unordered
          when others =>
            return null
        end case
    end Value

    -- NOTE: For implementation reasons, we put these here rather than defining
    --       them in the interface using "is of Countable_Set<Ordering>"
    function ".."(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'".."(Left, Right)
    end ".."

    function "<.."(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"<.."(Left, Right)
    end "<.."

    function "..<"(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"..<"(Left, Right)
    end "..<"
    function "<..<"(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"<..<"(Left, Right)
    end "<..<"

    function "&"(Left, Right : Ordering) return Countable_Set<Ordering> is
        return Ordering_Set'"&"(Left, Right)
    end "&"
end A2X.Core.Ordering

generic
  Range : Countable_Range<Univ_Integer> := -2**62 .. +2**62
package A2X.Core.Integer is
    -- NOTE: We restrict Integer to this range so Univ_Integer can use
    --       values outside this range as indices into an extended-range
    --       integer table.
    type Integer is private;

    function "from_univ"(Lit : Univ_Integer) return Integer 
      with Import, External_Name => #integer_from_univ;

    function "to_univ"(Val : Integer) return Univ_Integer 
      with Import, External_Name => #integer_to_univ;

    function "+"(Right : Integer) return Integer
      with Import, External_Name => #identity;

    function "-"(Right : Integer) return Integer
      with Import, External_Name => #negate;

    function "abs"(Right : Integer) return Integer
      with Import, External_Name => "abs";

    function "magnitude"(Integer) return Integer is "abs"

    function "+"(Left, Right : Integer) return Result : Integer 
      with Import, External_Name => "+";

    function "-"(Left, Right : Integer) return Result : Integer
      with Import, External_Name => "-";

    function "*"(Left, Right : Integer) return Result : Integer 
      with Import, External_Name => "*";

    function "/"(Left, Right : Integer) return Result : Integer
      with Import, External_Name => "/";

    function "mod"(Left, Right : Integer) return Integer
      with Import, External_Name => "mod";

    function "rem"(Left, Right : Integer) return Integer
      with Import, External_Name => "rem";

    function "**"(Left, Right : Integer) return Result : Integer
      with Import, External_Name => "**";

    procedure "+="(Left : in out Integer; Right : Integer) 
      with Import, External_Name => "+=";

    procedure "-="(Left : in out Integer; Right : Integer) 
      with Import, External_Name => "-=";

    procedure "*="(Left : in out Integer; Right : Integer) 
      with Import, External_Name => "*=";

    procedure "/="(Left : in out Integer; Right : Integer) 
      with Import, External_Name => "/=";

    procedure "**="(Left : in out Integer; Right : Integer) 
      with Import, External_Name => "**=";

    function "=?"(Left, Right : Integer) return Ordering
      with Import, External_Name => "=?";

    function Min(Left, Right : access Integer) return Integer
      with Import, External_Name => #min;
    function Max(Left, Right : access Integer) return Integer
      with Import, External_Name => #max;

    function Hash(Val : Integer) return Univ_Integer
      with Import, External_Name => #identity;

    procedure Print(X : Integer) with Import, External_Name => #print_int;

    procedure Put(X : Integer) is Print

    function Image(Val : Integer) return Univ_String
      with Import, External_Name => #to_string_int;

    function Value(Str : Univ_String) return Integer
      with Import, External_Name => #from_string_int;

    function First() return Integer

    function Last() return Integer

    function "[..]"() return Countable_Range<Integer> is of Countable_Range<Integer>

    function ".."(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    function "<.."(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    function "..<"(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    function "<..<"(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>
    function "&"(Left, Right : Integer) return Countable_Set<Integer>
      is of Countable_Set<Integer>

  implements -- for Countable

    -- These operations are needed so Integer satifies
    -- requirements of "Countable" interface, but these
    -- operations are not directly callable (if they were callable,
    -- we would have ambiguity when adding an integer to an int-literal).

    function "+"(Left : Integer; Right : Univ_Integer) return Result : Integer 
      with Import, External_Name => "+";

    function "+"(Left : Univ_Integer; Right : Integer) return Result : Integer 
      with Import, External_Name => "+";

    function "-"(Left : Integer; Right : Univ_Integer) return Result : Integer 
      with Import, External_Name => "-";

    function "-"(Left, Right : Integer) return Result : Univ_Integer
      with Import, External_Name => "-";

end A2X.Core.Integer

package body A2X.Core.Integer is
    type Integer is record
       Content : constant : Univ_Integer;  -- So this ends up as a wrapper
    end record Integer

    function First() return Integer is
        return Range.First
    end First

    function Last() return Integer is
        return Range.Last
    end Last

end A2X.Core.Integer

procedure A2X.Test.Test_Integer(X, Y : Univ_Integer) is
   -- type I6 is new Integer<1..10**6>
   subtype I6 is Integer<1..10**6>
   var A : I6 := X
   var B : I6 := Y

   var C : I6 := A + B
   Println (" " & A & " + " & B & " = " & C)
end A2X.Test.Test_Integer
    
generic
    type Bound_Type is new Comparable
package A2X.Core.Interval is
    -- This supports closed, half-open, and open intervals.
    -- This is appropriate for uncountable types where you
    -- can't normalize all intervals into closed intervals.

    type Interval is record
        Low : Bound_Type
        Low_Is_Open : Boolean
        High : Bound_Type
        High_Is_Open : Boolean
    end record Interval

    function Singleton(Val : Bound_Type) return Interval
      -- Return interval consisting of a single value

    function Is_Empty(IV : access Interval) return Boolean
      -- Return True if interval is null or it represents
      -- no values

    function "in"(Left : Bound_Type; Right : Interval) return Boolean

    function "=?"(Left, Right : Interval) return Ordering
      -- "#greater" means Left is strictly greater than Right
      -- "#less" means Left is strictly less than Right
      -- "#equal" means Left and Right are the same interval
      -- "#unordered" means anything else

    function "and"(Left, Right : Interval) return Interval
      -- Return intersection of the two intervals

    procedure "and="(Left : in out access Interval; Right : Interval)
      -- Intersect Right into Left

    function Is_Strictly_Within(Left, Right : access Interval) return Boolean
      -- Return #True if Left is strictly within Right,
      -- meaning low bound of Left is higher, and high bound is lower.
      -- NOTE: If #True, then removing Right from Left will produce two 
      --       non-overlapping intervals.

    function "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      return Interval
      -- Subtract out Right interval from Left interval
      -- Right must not be strictly within Left, since
      -- that would require return ing two intervals.

    procedure "-="(Left : in out access Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)}
      -- Subtract Right interval from Left

    function Overlaps(Left, Right : access Interval) return Boolean
      -- Return True if intervals overlap

    function "or"(Left, Right : Interval) {Overlaps(Left, Right)} return Interval
      -- Return union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
    function "&"(Left, Right : Interval) {Overlaps(Left, Right)}
      return Interval is "or"

    procedure "or="(Left : in out access Interval; Right : Interval) 
      {Overlaps(Left, Right)}
      -- Compute union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
    procedure "&="(Left : in out access Interval; Right : Interval) 
      {Overlaps(Left, Right)} is "or="

    procedure "<|="(var Left, Right : access Interval) {Overlaps(Left, Right)}
      -- Compute union of two intervals; leave Right empty.  
      -- Must have some overlap to ensure that result can be 
      -- represented as a single interval.

end A2X.Core.Interval

package body A2X.Core.Interval is
    function Singleton(Val : Bound_Type) return Interval is
      -- Return interval consisting of a single value
        return (Low => Val, Low_Is_Open => #False,
          High => Val, High_Is_Open => #False)
    end Singleton

    function Is_Empty(IV : access Interval) return Boolean is
      -- Return True if interval is null or it represents
      -- no values
        return IV is null or else
          IV.Low > IV.High or else
          (IV.Low = IV.High and then (IV.Low_Is_Open or IV.High_Is_Open))
    end Is_Empty

    function "in"(Left : Bound_Type; Right : Interval) return Boolean is
        case Left =? Right.Low is
          when #less => return #False
          when #equal => return not Right.Low_Is_Open
          when #greater =>
            case Left =? Right.High is
              when #less => return #True
              when #equal => return not Right.High_Is_Open
              when #greater => return #False
            end case
        end case
    end "in"

    function "=?"(Left, Right : Interval) return Ordering is
        -- Compare two intervals, and consider them #unordered
        -- if they overlap at all, unless they are identical.
        -- If they don't overlap, then return #less or #greater as appropriate.
        -- Return #unordered if any of the comparisons return #unordered.

        -- First check for perfect equality
        if Left.Low = Right.Low and then
          Left.High = Right.High and then
          Left.Low_Is_Open = Right.Low_Is_Open and then
          Left.High_Is_Open = Right.High_Is_Open then
            -- NOTE: We are considering X..Y-1 /= X..<Y since
            --       we don't require countable elements.
            return #equal
        end if

        case Left.High =? Right.Low is
          when #unordered =>
            return #unordered
          when #less =>
            return #less
          when #equal =>
            if Left.High_Is_Open or else Right.Low_Is_Open then
                -- No overlap
                return #less
            else
                -- We have already ruled out #equal
                return #unordered
            end if
          when #greater =>
            -- Not clearly less, see whether clearly greater.
            case Left.Low =? Right.High is
              when #unordered =>
                return #unordered
              when #less =>
                -- We have already ruled out #equal
                return #unordered
              when #equal =>
                if Left.Low_Is_Open or else Right.High_Is_Open then
                    -- No overlap
                    return #greater
                else
                    -- We have already ruled out #equal
                    return #unordered
                end if
              when #greater =>
                return #greater
            end case
        end case
    end "=?"

    function "and"(Left, Right : Interval) return Interval is
      -- Return intersection of the two intervals
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
        
        case Left.Low =? Right.Low is
          when #less => 
            New_Low := Right.Low
            New_Low_Is_Open := Right.Low_Is_Open
          when #greater => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open
          when #equal => 
            New_Low := Left.Low
            New_Low_Is_Open := Left.Low_Is_Open or Right.Low_Is_Open
          when #unordered => 
            return null
        end case
      
        case Left.High =? Right.High is
          when #less => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open
          when #greater => 
            New_High := Right.High
            New_High_Is_Open := Right.High_Is_Open
          when #equal => 
            New_High := Left.High
            New_High_Is_Open := Left.High_Is_Open or Right.High_Is_Open
          when #unordered => 
            return null
        end case
      
        return (Low => New_Low, Low_Is_Open => New_Low_Is_Open,
          High => New_High, High_Is_Open => New_High_Is_Open)
    end "and"

    procedure "and="(Left : in out access Interval; Right : Interval) is
      -- Intersect Right into Left
        if Left not null then
            Left := Left and Right
        end if
    end "and="

    function Is_Strictly_Within(Left, Right : access Interval) return Boolean is
      -- Return #True if Left is strictly within Right,
      -- meaning low bound of Left is higher, and high bound is lower.
      -- NOTE: If #True, then removing Right from Left will produce two 
      --       non-overlapping intervals.
        if Right is null or else Left is null then
            return #False
        end if
        return (Left.Low > Right.Low or else 
          (Left.Low = Right.Low and then Left.Low_Is_Open > Right.Low_Is_Open))
          and then
            (Left.High < Right.High or else
             (Left.High = Right.High and then 
              Left.High_Is_Open > Right.High_Is_Open))
    end Is_Strictly_Within

    function "-"(Left, Right : Interval) {not Is_Strictly_Within(Right, Left)} 
      return Result : access Interval is
      -- Subtract out Right interval from Left interval
      -- Right must not be strictly within Left, since
      -- that would require return ing two intervals.
        var New_Low : Bound_Type
        var New_High : Bound_Type
        var New_Low_Is_Open : Boolean
        var New_High_Is_Open : Boolean
  
        case Left.Low =? Right.Low is
          when #less => 
            -- Return left part of Left
            Result := (Low => Left.Low, Low_Is_Open => Left.Low_Is_Open,
              High => Right.Low, High_Is_Open => not Right.Low_Is_Open)
          when #greater => 
            -- Return right part of Left
            Result := (Low => Right.High, Low_Is_Open => not Right.High_Is_Open,
              High => Left.High, High_Is_Open => Left.High_Is_Open)
          when #equal => 
            if Left.Low_Is_Open >= Right.Low_Is_Open then
                -- Return right part of Left
                Result := (Low => Right.High, 
                  Low_Is_Open => not Right.High_Is_Open,
                  High => Left.High, 
                  High_Is_Open => Left.High_Is_Open)
            else
                -- Only one element is left
                return (Left.Low, #False, Left.Low, #False)
            end if
          when #unordered => 
            return null
        end case
      
        if Result.Low > Result.High then
            -- Empty interval
            return null
        elsif Result.Low = Result.High and then
          (Result.Low_Is_Open or Result.High_Is_Open) then
            -- Empty interval
            return null
        else
            return Result
        end if
    end "-"

    procedure "-="(Left : in out access Interval; Right : Interval) 
      {not Is_Strictly_Within(Right, Left)} is
      -- Subtract Right interval from Left
        if Left not null then
            Left := Left - Right
        end if
    end "-="

    function Overlaps(Left, Right : access Interval) return Boolean is
        if Left is null or else Right is null then
            return #False
        else
            case Left =? Right is
              when #equal | #unordered => return #True
              when #less | #greater => return #False
            end case
        end if
    end Overlaps

    function "or"(Left, Right : Interval) {Overlaps(Left, Right)} 
      return Result : Interval is
      -- Return union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
  
        Result := Left
        Result or= Right
    end "or"

    procedure "or="(Left : in out access Interval; Right : Interval) 
      {Overlaps(Left, Right)} is
      -- Compute union of two intervals.  Must have some overlap
      -- to ensure that result can be represented as a single interval.
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end "or="

    procedure "<|="(var Left, Right : access Interval) {Overlaps(Left, Right)} is
      -- Compute union of two intervals; leave Right empty.  
      -- Must have some overlap to ensure that result can be 
      -- represented as a single interval.
        if Left is null then
            Left <== Right
        elsif Right not null then
            var Right_Copy <== Right
                -- Make copy and null out Right, so
                -- we don't end up with Right partially nulled out
            
            case Left.Low =? Right_Copy.Low is
              when #less => 
                -- No change to Left.Low
                null
              when #greater => 
                Left.Low <== Right_Copy.Low
                Left.Low_Is_Open := Right_Copy.Low_Is_Open
              when #equal => 
                Left.Low_Is_Open and= Right_Copy.Low_Is_Open
            end case
      
            case Left.High =? Right_Copy.High is
              when #less => 
                Left.High <== Right_Copy.High
                Left.High_Is_Open := Right_Copy.High_Is_Open
              when #greater => 
                -- No change to Left.High
                null
              when #equal => 
                Left.High_Is_Open and= Right_Copy.High_Is_Open
            end case
        end if
    end "<|="

end A2X.Core.Interval

procedure A2X.Test.Test_Interval(X, Y, Z : Univ_Integer) is
    var Y_Up_To_Z : Interval<Univ_Integer> := 
      (Low => Y, Low_Is_Open => #False, High => Z, High_Is_Open => #True)

    Println(X & " in " & Y & "..<" & Z & " = " & (X in Y_Up_To_Z))

    var Y_To_Z : Closed_Interval<Univ_Integer> := (Low => Y, High => Z)

    Println(X & " in " & Y & ".." & Z & " = " & (X in Y_To_Z))

    var One_To_X : Closed_Interval<Univ_Integer> :=
      (Low => 1, High => X)

    Println(1 & ".." & X & "=?" & Y & ".." & Z & " = " & 
      (One_To_X =? Y_To_Z))

end A2X.Test.Test_Interval

procedure A2X.Test.Test_AA_Tree
  (A : Univ_Integer; B : Univ_Integer; C : Univ_Integer) is
    subtype Univ_Tree is AA_Tree<Univ_Integer>
    var T : Univ_Tree := []
    var X : Univ_Integer := A

    Insert(T, A)
    Println("Count = " & Count(T) & " after insert of " & A)
    Insert(T, B)
    Println("Count = " & Count(T) & " after insert of " & B)
    Insert(T, C)
    Println("Count = " & Count(T) & " after insert of " & C)

    Insert(T, A)
    Println("Count = " & Count(T) & " after another insert of " & A)

    Println(A & " in T = " & (A in T))
    Println(B & " in T = " & (B in T))
    Println(C & " in T = " & (C in T))
    Println("7 in T = " & (7 in T))

    for E := Remove_First(T) then Remove_First(T) while E not null loop
        Println("Remove_First = " & E)
    end loop

    Println("Count after loop : " & Count(T))

    for I in 1..10 forward loop
        Insert(T, I)
        Println("Count = " & Count(T) & " after insert of " & I)
    end loop

    for L := Remove_Last(T) then Remove_Last(T) while L not null loop
        Println("Remove_Last = " & L)
    end loop

    Println("Count after loop : " & Count(T))

    for J in 1..10 reverse loop
        Insert(T, J)
        Println("Count = " & Count(T) & " after insert of " & J)
    end loop

    Println("Count after loop : " & Count(T))

    Println("Overlapping(T, 5) = " & Overlapping(T, 5))

    for Z := Remove_Any(T) then Remove_Any(T) while Z not null loop
        Println("Remove_Any = " & Z)
    end loop

    Println("Count after loop : " & Count(T))

    for K in 1..10 loop
        Insert(T, K)
        Println("Count = " & Count(T) & " after insert of " & K)
    end loop

    for F := Remove_First(T) then Remove_First(T) while F not null loop
        Println("Remove_First = " & F)
    end loop

    Println("Count after loop : " & Count(T))

end A2X.Test.Test_AA_Tree

generic
    type Key_Type is new Hashable
package A2X.Containers.Keyed is
    type Keyed is abstract private

    abstract function Key_Of(KV : aliased Keyed) return access constant Key_Type
    abstract function Has_Value(KV : Keyed) return Boolean
      -- Return #True if Keyed object has a non-null value
    abstract function Key_Only(Key : Key_Type) return Keyed
      -- Return a Keyed object given a key, having no associated value
end A2X.Containers.Keyed

generic
    type Key_Type_KV is new Hashable;
    type Value_Type is new Assignable
package A2X.Containers.Key_Value is
  -- This supports the use of [Key => Value] as a way to
  -- add a single element to an existing indexable container of some sort.
    type Key_Value is new Keyed<Key_Type_KV> with record
         Key : access Key_Type_KV
         Value : access Value_Type
    end record Key_Value

    function "[]"() return Key_Value
    function "var_indexing"(KV : aliased in out Key_Value; Index : Key_Type_KV) 
      return access Value_Type
    function Key_Of(KV : aliased Key_Value) return access constant Key_Type_KV
    function Has_Value(KV : Key_Value) return Boolean
      -- Return #True if Key_Value object has a non-null value
    function Key_Only(Key : Key_Type_KV) return Key_Value
      -- Return a Key_Value object given a key, having no associated value
end A2X.Containers.Key_Value

package body A2X.Containers.Key_Value is
    function "[]"() return Key_Value is
        return (Key => null, Value => null)
    end "[]"

    function "var_indexing"(KV : aliased in out Key_Value; Index : Key_Type_KV) 
      return access Value_Type is
        KV.Key := Index
        return KV.Value
    end "var_indexing"

    function Key_Of(KV : aliased Key_Value) return access constant Key_Type_KV is
        return KV.Key
    end Key_Of

    function Has_Value(KV : Key_Value) return Boolean is
        -- Return #True if Key_Value object has a non-null value
        return KV.Value not null
    end Has_Value

    function Key_Only(Key : Key_Type_KV) return Key_Value is
        -- Return a Key_Value object given a key, having no associated value
        return [Key => null]
    end Key_Only
end A2X.Containers.Key_Value

generic
    type KV_Type is new Keyed
package A2X.Containers.Basic_Map is
  -- A basic hashed-map module
    type Basic_Map is private

    function "[]"() return Basic_Map

    procedure "&="(Left : in out Basic_Map; Right : KV_Type)
      -- Add Key=>Value to Basic_Map, replacing pre-existing Basic_Mapping
      -- for Key, if any.

    procedure "<|="(Left : in out Basic_Map; Right : in out access KV_Type)
      -- Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
      -- for Key, if any, leaving Right null.

    procedure "+="(Left : in out Basic_Map; Right : KV_Type) is "&="
      -- A synonym for adding a key=>value KV_Type

    function "in"(Left : KV_Type'Key_Type; Right : Basic_Map) return Boolean
      -- Return True if given key has a Basic_Mapping in the Basic_Map

    procedure "-="(M : in out Basic_Map; Key : KV_Type'Key_Type)   -- aka Exclude
      -- Remove Basic_Mapping for Right, if present

    function "index_set"(M : Basic_Map) return Set<KV_Type'Key_Type>
      -- Return set of keys with Basic_Mappings

    function "indexing"(M : aliased in out Basic_Map; Key : KV_Type'Key_Type) 
      return access KV_Type with Pre => Key in M;
      -- Used for references to M[Key]; requires the Key to be in M.

    function "var_indexing"(ref M : in out Basic_Map; Key : KV_Type'Key_Type) 
      return ref var optional KV_Type
      -- Used for assignments to M[Key]; Key is added to M if not present

    function Remove_Any(M : in out Basic_Map) return KV_Type
      -- Remove one Basic_Mapping from the Basic_Map.  
      -- Return null if Basic_Map is empty

    function Count(M : Basic_Map) return Univ_Integer
      -- Number of Basic_Mappings in the table

    function "magnitude"(Basic_Map) return Univ_Integer is Count

    function Is_Empty(M : Basic_Map) return Boolean
      -- Return True if map has no mappings

    procedure Dump_Statistics(M : Basic_Map)
      -- A debugging routine to show bucket sizes of Basic_Map

end A2X.Containers.Basic_Map

package body A2X.Containers.Basic_Map is
  -- A basic hashed-map module

  -- A Basic_Map is represented as a hash table, where each bucket is 
  -- a linked list of key/value KV_Types.
  -- When key/value KV_Types are deleted from the Basic_Map they end 
  -- up as "null"s in the list.  
  -- We expand the table when the Count gets to be twice
  -- that of the length of the table.

    type Hash_Bucket is record
      -- a simple linked-list is used as a hash bucket
        Elem : access KV_Type
        Tail : access Hash_Bucket
    end record Hash_Bucket

    type Basic_Map is record
        Count : Univ_Integer
        Table : access Basic_Array<optional Hash_Bucket>
    end record;

    Initial_Table_Size : constant := 4
    Debugging : constant : Boolean := #False
    
    function Empty(Table_Size : Univ_Integer) return Basic_Map is
        -- Create an empty Basic_Map with the given table size
        return (Count => 0, Table => Create(Table_Size, null))
    end Empty

    procedure Move_One(To : in out Basic_Map; Elem : in out access KV_Type) is
        -- Move Element into table, without expanding table.
        -- Elem is set to null as a result.
        Index : constant := Hash(Key_Of(Elem)) mod |To.Table| + 1
        ref Bucket => To.Table[Index]
      
        if Bucket is null then
            -- Bucket is now empty, so create bucket
            -- with Elem as its only element.
            Bucket := (Elem <== Elem, Tail => null)
        else
            -- See whether Elem already in bucket
            var Has_Empty_Slot : Boolean := #False
            for B => Bucket then B.Tail while B not null loop
                if B.Elem is null then
                    -- Remember there is an empty slot
                    Has_Empty_Slot := #True
                elsif Key_Of(Elem) = Key_Of(B.Elem) then
                    -- Already there; replace it in case Value is different.
                    B.Elem <== Elem
                    return
                end if
            end loop
      
            if Has_Empty_Slot then
                -- Fill in the empty slot
                for B => Bucket then B.Tail while B not null loop
                    if B.Elem is null then
                        -- Use the empty slot
                        B.Elem <== Elem
                        exit loop
                    end if
                end loop
            else
                -- Make old bucket the new tail of the new bucket.
                Bucket := (Elem <== Elem, Tail <== Bucket)
            end if
        end if
      
        To.Count += 1
    end Move_One
      
    procedure Add_One(To : in out Basic_Map; Elem : KV_Type) is
        -- Add Element to table, without expanding it
        var Elem_Copy for To := Elem
      
        -- Just pass the buck to "Move_One"
        Move_One(To, Elem_Copy)
    end Add_One
      
    procedure Expand_Table(Expanding : in out Basic_Map) is
        -- Expand table of given Basic_Map.
        if Debugging then
            Println(" Expanding hash table, Count = " & Expanding.Count & 
              ", Length = " & |Expanding.Table|)
        end if
        var Old_Basic_Map <== Expanding
        Expanding := Empty(2 * |Old_Basic_Map.Table|)
        -- Move elements into new table
        loop
            var Elem for Expanding := Remove_Any(Old_Basic_Map)
                -- "for Expanding" means to allocate Elem in
                -- region associated with Expanding.
            if Elem is null then
                exit loop
            end if
            Move_One(Expanding, Elem)
        end loop
        if Debugging then
            Println(" After expansion, Count = " & Expanding.Count &
              ", Length = " & |Expanding.Table|)
        end if
    end Expand_Table
      
    function "[]"() return Basic_Map is
        return (Count => 0, Table => null)
    end "[]"
      
    procedure "&="(Left : in out Basic_Map; Right : KV_Type) is
        if not Has_Value(Right) then
            -- Putting in Key => null is equivalent to deleting Key
            Left -= Key_Of(Right)
            return
        end if
      
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            -- Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if

        Add_One(Left, Right)
    end "&="
      
    procedure "<|="(Left : in out Basic_Map; Right : in out access KV_Type) is
        -- Move Key=>Value into Basic_Map, replacing pre-existing Basic_Mapping
        -- for Key, if any, leaving Right null.
        if not Has_Value(Right) then
            -- Putting in Key => null is equivalent to deleting Key
            Left -= Key_Of(Right)
            Right := null
            return
        end if
      
        if Left.Table is null then
            Left := Empty(Initial_Table_Size)
        elsif Left.Count >= 2*Length(Left.Table) then
            -- Expand table if averaging 2 or more per hash bucket
            Expand_Table(Left)
        end if
        Move_One(Left, Right)
    end "<|="
      
    function "in"(Left : KV_Type'Key_Type; Right : Basic_Map) return Boolean is
        if Right.Count = 0 then
            -- Empty Basic_Map
            return #False
        end if
        Index : constant := Hash(Left) mod Length(Right.Table) + 1
        ref Bucket => Right.Table[Index]
        if Bucket is null then
            -- Hash bucket is empty
            return #False
        end if
        -- Scan for Elem in hash bucket
        for B => Bucket then B.Tail while B not null loop 
            if B.Elem not null and then
              Has_Value(B.Elem) and then
              Key_Of(B.Elem) = Left then
                -- Found it
                return #True
            end if
        end loop
        -- Not in Basic_Map
        return #False
    end "in"
      
    procedure "-="(M : in out Basic_Map; Key : KV_Type'Key_Type) is
            -- Remove the given key from the Basic_Map, if present
        if M.Count = 0 then
            -- Empty Basic_Map
            return
        end if
      
        Index : constant := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        if Bucket is null then
            -- Hash bucket is empty
            return
        end if
      
        -- Scan for Key in bucket
        for B => Bucket then B.Tail while B not null loop
            if B.Elem not null and then
              Key_Of(B.Elem) = Key then
                -- Found it.  Map it to null, and decrement Basic_Map count.
                B.Elem := null
                M.Count -= 1
                return
            end if
        end loop
        -- Not found
    end "-="
         
    function "index_set"(M : Basic_Map) return Result : Set<KV_Type'Key_Type> is
        -- Return set of keys with non-null Basic_Mappings
        Result := []
        if M.Count = 0 then
            return
        end if
        for each Bucket of M.Table loop
            for B => Bucket then B.Tail while B not null loop
                if B.Elem not null and then
                  Has_Value(B.Elem) then
                    Result |= Key_Of(B.Elem)
                end if
            end loop
        end loop
    end "index_set"
      
    function "indexing"(ref M : Basic_Map; Key : KV_Type'Key_Type)
            return ref KV_Type is
        -- Used for references to M[Key]; requires the Key to be in M.
        pragma Assert (M not null and then M.Count > 0);
        Index : constant := Hash(Key) mod Length(M.Table) + 1
        -- Scan for Key in bucket
        for B => M.Table[Index] then B.Tail while B not null loop
            if B.Elem not null and then
              Key_Of(B.Elem) = Key then
                -- Found it.  Return reference to element of KV_Type
                pragma Assert (Has_Value(B.Elem));
                return B.Elem
            end if
        end loop
        pragma Assert (#False);
    end "indexing"
      
    function "var_indexing"(ref M : in out Basic_Map; Key : KV_Type'Key_Type) 
            return ref var optional KV_Type is
        -- Used for assignments to M[Key]; Key is added to M if not present
        if M.Table not null then
            Index : constant := Hash(Key) mod Length(M.Table) + 1
            -- Scan for Key in bucket
            for B => M.Table[Index] then B.Tail while B not null loop
                if B.Elem not null and then
                  Key_Of(B.Elem) = Key then
                    -- Found it.  Return reference to element of KV_Type
                    return B.Elem
                end if
            end loop
        end if
      
        -- Not in table.  Add it, and then return reference
        if M.Table is null then
            M := Empty(Initial_Table_Size)
        elsif M.Count >= 2*Length(M.Table) then
            -- Expand table if averaging 2 or more per hash bucket
            Expand_Table(M)
        end if
      
        -- Add [Key => null] to front of appropriate bucket.
        Index : constant := Hash(Key) mod Length(M.Table) + 1
        ref Bucket => M.Table[Index]
        Bucket := (Elem => Key_Only(Key), Tail <== Bucket)
        M.Count += 1
      
        -- Return ref to new element
        return Bucket.Elem
    end "var_indexing"
      
    function Count(M : Basic_Map) return Univ_Integer is
              if M is null then
                  return 0
              else
                  return M.Count
              end if
    end Count
      
    function Is_Empty(M : Basic_Map) return Boolean is
        -- Return True if map has no mappings
        return M.Count = 0
    end Is_Empty
      
    function Remove_Any(M : in out Basic_Map) return Result : access KV_Type is
        if M.Count = 0 then
            -- Basic_Map is empty
            return null
        else
            -- Find a non-empty bucket and pull out an item.
            for each Bucket of M.Table loop
                if Bucket not null then
                    for B => Bucket then B.Tail while B not null loop 
                        if B.Elem not null then
                            -- Found an item, remove from Bucket and return
                            Result <== B.Elem
                            M.Count -= 1
                            return
                        end if
                    end loop
                    -- This bucket is completely empty, so might
                    -- as well empty it out.
                    Bucket := null
                end if
                -- Go on to the next bucket, this one's empty
            end loop
            -- Should never get here
            return null
        end if
    end Remove_Any
      
    procedure Dump_Statistics(M : Basic_Map) is
            -- A debugging routine to show bucket sizes of Basic_Map
        Println("Basic_Map statistics: Count = " & M.Count)
        if M.Table is null then
            Println(" Table is null")
        else
            Println(" Table of length " & Length(M.Table))
            for each [I => Bucket] of M.Table forward loop
                Print("  Bucket #" & I)
                if Bucket is null then
                    Println(" is null")
                else
                    var Len := 0
                    var Holes := 0
                    for B => Bucket then B.Tail while B not null loop
                        Len += 1
                        if B.Elem is null then
                            -- This list has a hole
                            Holes += 1
                        end if
                    end loop
                    if Holes > 0 then
                        Println(" of length " & Len & " with " & 
                          Holes & " holes")
                    else
                        Println(" of length " & Len)
                    end if
                end if
            end loop
        end if
    end Dump_Statistics
      
end A2X.Containers.Basic_Map

procedure A2X.Test.Test_Basic_Map(X : Univ_Enumeration; Y : Univ_String;
  A : Univ_Enumeration; B : Univ_String) is
    subtype Enum_String_KV_Type is Key_Value<Univ_Enumeration, Univ_String>
    subtype Enum_String_Basic_Map is Basic_Map<Enum_String_KV_Type>

    var M : Enum_String_Basic_Map := [X => [X => Y], A => [A => B]]

    Println("Count = " & Count(M))

    for each KV of M loop
        ref K : constant => KV.Key
        ref V : constant => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
        Println(K & " in M = " & (K in M))
    end loop

    Println("#xy in M = " & (#xy in M))

    M |= [X => null]

    Println("Count after deletion = " & Count(M))

    for each KV of M loop
        ref K : constant => KV.Key
        ref V : constant => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " & Count(M))

    for each KV of M loop
        ref K : constant => KV.Key
        ref V : constant => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " & Count(M))

    for each KV of M loop
        ref K : constant => KV.Key
        ref V : constant => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    M -= A

    Println("Count after deletion = " & Count(M))

    for each KV of M loop
        ref K : constant => KV.Key
        ref V : constant => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
    end loop

    var Ran := Random.Start(Hash(A))
    var MUI : Basic_Map<Key_Value<Univ_Integer, Univ_Integer>> := []

    Println("Adding 100 random KV_Typeings to Basic_Map.")
    for I in 1..100 loop
        Key : constant := Next(Ran) mod 100
        Value : constant := Next(Ran) mod 100
        MUI[Key] := [Key => Value]
    end loop
    Println("Basic_Map is now of count = " & Count(MUI))

    for each [K => KV] of MUI loop
        ref V : constant => KV.Value
        Println("Basic_Mapping " & K & " => " & V)
        Println("MUI[" & K & "] = " & MUI[K].Value)
    end loop

    var I := 0
    for KV_Type in MUI loop
        I += 1
        Print(" [" & Key_Of(KV_Type) & " => " & KV_Type.Value & "]")
        if I mod 5 = 0 then
            Print("\n")
        end if
    end loop
    if I mod 5 /= 0 then
        Print("\n")
    end if

end A2X.Test.Test_Basic_Map

package body A2X.Containers.Set is
  -- A hashed-set module

  -- A Set is represented as a hash table, where each bucket is a linked list.
  -- When elements are deleted from the Set they end up a "null"s in the
  -- list.  We expand the table when the Count gets to be twice
  -- that of the length of the table.

    type KV_Wrapper is new Keyed<Element_Type> with record
            -- Create a wrapper for a key that implements the Keyed interface
        Key : Element_Type
    end record KV_Wrapper

    function Key_Of(ref KV : constant : KV_Wrapper) return ref const Element_Type
      is (KV.Key)
    function Has_Value(KV : KV_Wrapper) return Boolean is (#True)
        -- Return #True if KV_Wrapper object has a non-null value
    function Key_Only(Key : Element_Type) return KV_Wrapper is (Key => Key)
        -- Return a KV_Wrapper object given a key, 
        -- having no associated value
      
    type Set is record
        Data : Basic_Map<KV_Wrapper>
        -- Set is represented as a map from keys to nothing.
    end record Set;
      

    function "[]"() return Set is
        return (Data => [])
    end "[]"
      
    function Singleton(Elem : Element_Type) return Result : Set is
        Result := []
        Result.Data |= (Key => Elem)
    end Singleton
      
    function "&"(Left, Right : Element_Type) return Result : Set is
        Result := []
        Result.Data |= (Key => Left)
        Result.Data |= (Key => Right)
    end "&"
      
    function "&"(Left : Set; Right : Element_Type) return Result : Set is
        Result := Left
        Result |= Right
    end "&"
      
    function "&"(Left : Element_Type; Right : Set) return Result : Set is
        Result := Right
        Result |= Left
    end "&"
      
    function "&"(Left : Set; Right : Set) return Result : Set is
        -- Union, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            Result := Right
            Result |= Left
        else
            Result := Left
            Result |= Right
        end if
    end "&"
      
    procedure "&="(Left : in out Set; Right : Set) is
        if Count(Left.Data) = 0 then
            Left := Right
        else
            for Elem in Right loop
                Left |= Elem
            end loop
        end if
    end "&="
      
    procedure "&="(Left : in out Set; Right : Element_Type) is
        Left.Data |= (Key => Right)
    end "&="
      
    procedure "<|="(Left : in out Set; Right : in out access Element_Type) is
        -- Move Right into Set Left
        var KV : KV_Wrapper := (Key <== Right)
        Left.Data <|= KV
    end "<|="
      
    procedure "<|="(Left : in out Set; Right : in out Set) is
        -- Move all elements of Right into Left, leaving Right empty.
        loop
            -- Extract element from Right, in region for Left
            var Elem for Left := Remove_Any(Right)
            if Elem is null then
                -- All done
                return
            end if
            -- Move element into Left
            Left <|= Elem
        end loop
    end "<|="
      
    function "in"(Left : Element_Type; Right : Set) return Boolean is
        return Left in Right.Data
    end "in"
      
    function "=?"(Left, Right : Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
              var Overlaps := 0
              var Missing := 0
              for Elem in Left loop
                  if Elem not in Right then
                      Missing += 1
                  else
                      Overlaps += 1
                  end if
              end loop
      
              if Missing > 0 then
                  -- Can't be equal, but Left might be a proper superset
                  if Overlaps < Count(Right.Data) then
                      return #unordered
                  else
                      -- Left is a superset
                      return #greater
                  end if
              else
                  -- Might be equal or Left might be a proper subset
                  if Overlaps < Count(Right.Data) then
                      -- Left is a proper subset of Right
                      return #less
                  else
                      return #equal
                  end if
              end if
    end "=?"
      
    function "and"(Left, Right : Set) return Result : Set is
        -- Intersection, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            -- Left is smaller
            Result := []
            for Elem in Left loop
                if Elem in Right then
                    Result |= Elem
                end if
            end loop
        else
            -- Left is bigger
            Result := Left
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
        end if
    end "and"
      
    procedure "and="(Left : in out Set; Right : Set) is
        -- Intersection, iterate over smaller Set
        if Count(Left.Data) <= Count(Right.Data) then
            -- Left is smaller
            for Elem in Left loop
                if Elem not in Right then
                    Left -= Elem
                end if
            end loop
        else
            -- Left is bigger
            var Result : Set for Left := []
            for Elem in Right loop
                if Elem in Left then
                    Result |= Elem
                end if
            end loop
            Left <== Result
        end if
    end "and="
      
    function "xor"(Left, Right : Set) return Result : Set is
        -- Symmetric difference
        -- Want elements that are only in one of the two inputs
        if Count(Left.Data) < Count(Right.Data) then
            -- Swap order to shorten iteration
            Result := Right
            Result xor= Left
        else
            Result := Left
            Result xor= Right
        end if
    end "xor"
          
    procedure "xor="(Left : in out Set; Right : Set) is
        -- Want elements that are only in one of the two inputs
        for Elem in Right loop
            if Elem in Left then
                Left -= Elem
            else
                Left += Elem
            end if
        end loop
    end "xor="
      
    function "-"(Left, Right : Set) return Result : Set is
        -- Set difference, iterate over smaller Set
        if Count(Left.Data) < Count(Right.Data) then
            -- Left is smaller, build up 
            Result := []
            for Elem in Left loop
                if Elem not in Right then
                    Result |= Elem
                end if
            end loop
        else
            -- Left is bigger, tear down
            Result := Left
            Result -= Right
        end if
    end "-"
      
    procedure "-="(Left : in out Set; Right : Set) is
        -- Compute Set difference
        for Elem in Right loop
            Left -= Elem
        end loop
    end "-="
      
    procedure "-="(S : in out Set; Elem : Element_Type) is
            -- Remove the given element from the Set, if present
        S.Data -= Elem
    end "-="
         
    function Count(S : Set) return Univ_Integer is
        return Count(S.Data)
    end Count
      
    function Is_Empty(S : Set) return Boolean is
        return Is_Empty(S.Data)
    end Is_Empty
      
    function Remove_Any(S : in out Set) return Result : access Element_Type is
        var Result_Wrapper for Result := Remove_Any(S.Data)
        if Result_Wrapper is null then
            return null
        else
            Result <== Result_Wrapper.Key
        end if
    end Remove_Any
      
    procedure Dump_Statistics(S : Set) is
            -- A debugging routine to show bucket sizes of Set
        Dump_Statistics(S.Data)
    end Dump_Statistics
      
end A2X.Containers.Set

procedure A2X.Test.Test_Set(A, X, Y, Z : Univ_Integer) is
    var S : Set<Univ_Integer> := X | Y | Z
    if A in S then
        Println(A & " is in " & X & "&" & Y & "&" & Z)
    else
        Println(A & " is *not* in " & X & "&" & Y & "&" & Z)
    end if

    Save_Set : constant := S

    CSet : constant : Set<Univ_Integer> := [Z, Y, X]
    Println("[Z, Y, X] =? (X | Y | Z) --> " &
      ( CSet =? S ))

    var Ran := Random.Start(A)
    Println("Adding 100 random digits to Set.")
    for I in 1..100 loop
        S |= Next(Ran) mod 100
    end loop
    Println("Set is now of count = " & Count(S))
    Println("Contents of Set:")
    var I := 1
    for Elem in S loop
        Print(Elem & " ")
        if I mod 10 = 0 then
            Print("\n")
        end if
        I += 1
    end loop
    if Count(S) mod 10 /= 0 then
        Print("\n")
    end if
    Println("S Before adding random elements =? now --> " &
      (Save_Set =? S))
    Println("S =? S --> " & (S =? S))

    var Small_Set : Set<Univ_Integer> := []
    Small_Set += -1
    Small_Set or= [2]

    Println("S =? (-1 | 2) --> " & (S =? Small_Set))
    Println("[2 , -1] =? (-1 | 2) --> " & ([2, -1] =? Small_Set))

    Println("S =? [] --> " & (S =? []))

    Println("Count(S) = " & Count(S))
    
    Before_Exclude : constant := S
    S -= X
    Println("After Exclude(S, " & X & "), Count(S) = " & Count(S))
    Println("Before_Exclude =? After Exclude --> " & (Before_Exclude =? S))

    Dump_Statistics(S)
end A2X.Test.Test_Set

generic
    Literals : Vector<Univ_Enumeration>
package A2X.Core.Enum is
    type Enum is private;

    function "from_univ"(Univ : Univ_Enumeration) 
      return Enum
      with Pre => (for some Lit of Literals => Lit = Univ);
    function "to_univ"(Val : access Enum)
      return Result : access Univ_Enumeration
      with Post => Result is null
        or else (for some Lit of Literals => Lit = Result);

    function "=?"(Left, Right : Enum) return Ordering
      with Import, External_Name => "=?";

    -- Functions for Imageable
    function Image(Val : Enum) return Univ_String
    function Value(Str : Univ_String) return Enum

    -- Operators for Countable
    function "+"(Left : Univ_Integer; Right : Enum) return Enum 
      with Import, External_Name => "+";
    function "+"(Left : Enum; Right : Univ_Integer) return Enum 
      with Import, External_Name => "+";
    function "-"(Left, Right : Enum) return Univ_Integer 
      with Import, External_Name => "-";
    function "-"(Left : Enum; Right : Univ_Integer) return Enum 
      with Import, External_Name => "-";

    -- TBD: These should be properties some day (e.g. Color#first).
    function First() return Enum
    function Last() return Enum
    function Range() return Countable_Range<Enum> is "[..]" of Countable_Range<Enum>

    function "[..]"() return Countable_Range<Enum> is of Countable_Range<Enum>

    function Hash(Val : Enum) return Univ_Integer
      with Import, External_Name => #identity;

    function ".."(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    function "<.."(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    function "..<"(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    function "<..<"(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>
    function "&"(Left, Right : Enum) return Countable_Set<Enum>
      is of Countable_Set<Enum>

    function Min(Left, Right : access Enum) return Enum
      with Import, External_Name => #min;
    function Max(Left, Right : access Enum) return Enum
      with Import, External_Name => #max;
end A2X.Core.Enum

package body A2X.Core.Enum is
    type Enum is record
        Value : constant : Univ_Integer
    end record;
    function "from_univ"(Univ : Univ_Enumeration) 
      return Enum is
        for I in 1 .. |Literals| loop
            if Literals[I] = Univ then
                return (Value => I-1)
            end if
        end loop
        pragma Assert (#False);
    end "from_univ"

    function "to_univ"(Val : access Enum)
      return Result : access Univ_Enumeration
        if Val is null then
            return null
        else
            return Literals[Val.Value+1]
        end if
    end "to_univ"

    -- Functions for Imageable
    function Image(Val : Enum) return Univ_String is
        return Univ_Enumeration'Image([[Val]])
    end Image

    function Value(Str : Univ_String) return Enum is
        return Univ_Enumeration'Value(Str)
    end Value

    function First() return Enum is
        return (Value => 0)
    end First

    function Last() return Enum is
        return (Value => |Literals| - 1)
    end Last

end A2X.Core.Enum

procedure A2X.Test.Test_Enum() is
    subtype Color is Enum<[#red, #green, #blue]>
    subtype Day_Of_Week is Enum<[#Monday, #Tuesday, #Wednesday, #Thursday, 
        #Friday, #Saturday, #Sunday]>

    for C : Color in Color.First() .. Color.Last() forward loop
        Println("Next color = " & C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " & C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " & D3)
    end loop

    pragma Assert (#Monday in Day_Of_Week);

end A2X.Test.Test_Enum

generic
    type Key_Type is new Hashable;
    type Value_Type is new Assignable
package A2X.Containers.Map is
        -- A hashed-map module
    type Map is private

    subtype Pair is Key_Value<Key_Type, Value_Type>

    function "[]"() return Map

    procedure "&="(Left : in out Map; Right : Pair)
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any.

    function "&"(Left : Map; Right : Pair) return Map
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any in result.

    procedure "<|="(Left : in out Map; Right : in out access Pair)
        -- Move Key/Value pair into map, leaving Right null

    procedure "<|="(Left : in out Map; Right : in out Map)
        -- Move key/value pairs from Right into Left, leaving Right empty,
        -- replacing any pre-existing entries with the same key.

    procedure "+="(Left : in out Map; Right : Pair) is "&="
        -- A synonym for adding a key=>value pair

    function "in"(Left : Key_Type; Right : Map) return Boolean
        -- Return True if given key has a mapping in the Map

    procedure "-="(M : in out Map; Key : Key_Type)   -- aka Exclude
        -- Remove mapping for Right, if present

    function "index_set"(M : Map) return Set<Key_Type>
        -- Return set of keys with mappings

    function Keys(M : Map) return Set<Key_Type> is "index_set"

    function "indexing"(ref M : Map; Key : Key_Type)
      return ref Value_Type with Pre => Key in M;
        -- Used for references to M[Key]; requires the Key to be in M.

    function "var_indexing"(ref M : in out Map; Key : Key_Type) 
            return ref var optional Value_Type
        -- Used for assignments to M[Key]; Key is added to M if not present

    function Remove_Any(M : in out Map) return Pair
        -- Remove one mapping from the Map.  Return null if Map is empty

    function Count(M : Map) return Univ_Integer
        -- Number of mappings in the table

    function "magnitude"(Map) return Univ_Integer is Count

    function Is_Empty(M : Map) return Boolean
        -- Return True if no mappings in the table

    procedure Dump_Statistics(M : Map)
            -- A debugging routine to show bucket sizes of Map

end A2X.Containers.Map

package body A2X.Containers.Map is
        -- A hashed-map module
    type Map is record
        Data : Basic_Map<Key_Value<Key_Type, Value_Type>>
    end record;

    function "[]"() return Map is
              return (Data => [])
    end "[]"

    function "&"(Left : Map; Right : Pair) return Result : Map is
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any in result.
              Result := Left
              Result.Data |= Right
    end "&"

    procedure "&="(Left : in out Map; Right : Pair) is
        -- Add Key=>Value to Map, replacing pre-existing mapping
        -- for Key, if any.
        Left.Data |= Right
    end "&="

    procedure "<|="(Left : in out Map; Right : in out access Pair) is
        -- Move Key/Value pair into map, leaving Right null
        Left.Data <|= Right
    end "<|="

    procedure "<|="(Left : in out Map; Right : in out Map) is
        -- Move key/value pairs from Right into Left, leaving Right empty,
        -- replacing any pre-existing entries with the same key.
        loop
            var Right_Elem for Left := Remove_Any(Right)
            if Right_Elem is null then
                return   -- All done
            end if

            Left.Data <|= Right_Elem
        end loop
    end "<|="

    function "in"(Left : Key_Type; Right : Map) return Boolean is
        return Left in Right.Data
    end "in"

    procedure "-="(M : in out Map; Key : Key_Type) is
            -- Remove the given key from the Map, if present
        M.Data -= Key
    end "-="
         
    function "index_set"(M : Map) return Result : Set<Key_Type> is
        -- Return set of keys with non-null mappings
              if M.Data is null then
                  return []
              else
                 return "index_set"(M.Data)
              end if
    end "index_set"

    function "indexing"(ref M : Map; Key : Key_Type) return ref Value_Type is
        -- Used for references to M[Key]; requires the Key to be in M.
        return M.Data[Key].Value
    end "indexing"

    function "var_indexing"(ref M : in out Map; Key : Key_Type) 
            return ref var optional Value_Type is
        -- Used for assignments to M[Key]; Key is added to M if not present
        return "var_indexing"(M.Data, Key).Value
    end "var_indexing"

    function Count(M : Map) return Univ_Integer is
        return Count(M.Data)
    end Count

    function Is_Empty(M : Map) return Boolean is
        -- Return True if no mappings in the table
        return Is_Empty(M.Data)
    end Is_Empty

    function Remove_Any(M : in out Map) return Result : access Pair is
        return Remove_Any(M.Data)
    end Remove_Any

    procedure Dump_Statistics(M : Map) is
            -- A debugging routine to show bucket sizes of Map
        Dump_Statistics(M.Data)
    end Dump_Statistics

end A2X.Containers.Map

procedure A2X.Test.Test_Map(X : Univ_Enumeration; Y : Univ_String;
        A : Univ_Enumeration; B : Univ_String) is
    subtype Enum_String_Map is Map<Univ_Enumeration, Univ_String>

    var M : Enum_String_Map := [X => Y, A => B]

    Println("Count = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
        Println(K & " in M = " & (K in M))
    end loop

    Println("#xy in M = " & (#xy in M))

    M |= [X => null]

    Println("Count after deletion = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    M |= [X => "a new value"]

    Println("Count after addition = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    M |= [X => "a third value"]

    Println("Count after replacement = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    M -= A

    Println("Count after deletion = " & Count(M))

    for each [K => V] of M loop
        Println("Mapping " & K & " => " & V)
    end loop

    var Ran := Random.Start(Hash(A))
    var MUI : Map<Univ_Integer, Univ_Integer> := []

    Println("Adding 100 random pairings to Map.")
    for I in 1..100 loop
        Key : constant := Next(Ran) mod 100
        Value : constant := Next(Ran) mod 100
        MUI[Key] := Value
    end loop
    Println("Map is now of count = " & Count(MUI))

    for each [K => V] of MUI loop
        Println("Mapping " & K & " => " & V)
        Println("MUI[" & K & "] = " & MUI[K])
    end loop

    for (Pair in MUI; I in 1..60 forward) loop
        Print(" [" & Pair.Key & " => " & Pair.Value & "]")
        if I mod 5 = 0 then
            Print("\n")
        end if
    end loop

    if Count(MUI) > 60 then
        Println(" ...")
    elsif Count(MUI) mod 5 /= 0 then
        Print("\n")
    end if

end A2X.Test.Test_Map

generic
    type Element_Type is new Comparable
package A2X.Containers.Ordered_Set is
  -- A set abstraction that supports efficiently storing potentially
  -- large ranges of values
    type Ordered_Set is private

    function "[]"() return Ordered_Set

    function Singleton(Elem : Element_Type) return Ordered_Set
        -- Return a set consisting of a single element

    function ".."(Left, Right : Element_Type) return Ordered_Set
        -- Closed interval of values
    function "<.."(Left, Right : Element_Type) return Ordered_Set
        -- Open-Closed interval of values
    function "..<"(Left, Right : Element_Type) return Ordered_Set
        -- Closed-Open interval of values
    function "<..<"(Left, Right : Element_Type) return Ordered_Set
        -- Open interval of values

    function "&"(Left, Right : Element_Type) return Ordered_Set
    function "&"(Left : Ordered_Set; Right : Element_Type) return Ordered_Set
    function "&"(Left : Element_Type; Right : Ordered_Set) return Ordered_Set
    function "&"(Left : Ordered_Set; Right : Ordered_Set) return Ordered_Set

    procedure "&="(Left : in out Ordered_Set; Right : Element_Type)
    procedure "&="(Left : in out Ordered_Set; Right : Ordered_Set)

    procedure "<|="(Left : in out Ordered_Set; Right : in out access Element_Type)
              -- Move element into set, leaving Right null afterward.

    procedure "<|="(Left : in out Ordered_Set; Right : in out Ordered_Set)
        -- Move all elements of Right into Left, leaving Right empty.

    function "-"(Left, Right : Ordered_Set) return Ordered_Set
            -- Set difference
    procedure "-="(S : in out Ordered_Set; Elem : Element_Type)
            -- Remove the given element from the set, if present
    procedure "-="(Left : in out Ordered_Set; Right : Ordered_Set)
            -- Remove all elements of Right from Left, if present

    function "or"(Left : Ordered_Set; Right : Ordered_Set) 
            return Ordered_Set is "&"   -- union
    procedure "or="(Left : in out Ordered_Set; Right : Ordered_Set) is "&="

    function "+"(Left : Ordered_Set; Right : Ordered_Set) 
            return Ordered_Set is "&"   -- Union
    procedure "+="(Left : in out Ordered_Set; Right : Ordered_Set) is "&="
    procedure "+="(Left : in out Ordered_Set; Right : Element_Type) is "&="
         
    function "and"(Left, Right : Ordered_Set) return Ordered_Set
        -- Intersection
    procedure "and="(Left : in out Ordered_Set; Right : Ordered_Set)

    function "xor"(Left, Right : Ordered_Set) return Ordered_Set
        -- Symmetric difference
    procedure "xor="(Left : in out Ordered_Set; Right : Ordered_Set)

    function "in"(Left : Element_Type; Right : Ordered_Set) return Boolean

    function "=?"(Left, Right : Ordered_Set) return Ordering
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise

    function Is_Empty(S : Ordered_Set) return Boolean

    function Lower_Bound(S : Ordered_Set) return Element_Type
        -- Lower bound of set
    function Lower_Bound_Is_Open(S : Ordered_Set) return Boolean
        -- Whether lower bound is "open" or "closed"

    function Upper_Bound(S : Ordered_Set) return Element_Type
        -- Upper bound of set
    function Upper_Bound_Is_Open(S : Ordered_Set) return Boolean
        -- Whether upper bound is "open" or "closed"

    function Remove_First(S : in out Ordered_Set)
      return Interval<Element_Type>
        -- Remove first interval of set (lowest low bound)

    function Remove_Last(S : in out Ordered_Set) return Interval<Element_Type>
        -- Remove last interval of set (highest high bound)

    function Remove_Any(S : in out Ordered_Set) return Interval<Element_Type>
        -- Remove an arbitrary interval of set

end A2X.Containers.Ordered_Set

package body A2X.Containers.Ordered_Set is

    subtype Element_Interval is Interval<Element_Type>

    type Ordered_Set is record
        Items : access AA_Tree<Element_Interval>
    end record Ordered_Set

    procedure Remove_Interval(S : in out Ordered_Set; Remove_IV : Element_Interval) is
      -- Remove the given interval from the set, if present
        if Remove_IV.Low > Remove_IV.High then
            -- Nothing to remove
            return
        end if

          -- Find an interval within the AA_Tree that overlaps
        for Remaining_IV := Remove_IV while Remaining_IV not null loop
            -- Get overlap, if any
            var IV := Overlapping(S.Items, Remaining_IV)

            if IV is null then
                -- No overlap, nothing left to remove
                exit loop
            end if
        
            -- Found an overlapping interval; delete it and add back what's left
            Delete(S.Items, IV)
            if Is_Strictly_Within(Remaining_IV, IV) then
                -- Add back left and right remnants
                -- Remaining_IV is fully subsumed.
                S.Items |= (Low => IV.Low, Low_Is_Open => IV.Low_Is_Open, 
                  High => Remaining_IV.Low, 
                  High_Is_Open => not Remaining_IV.Low_Is_Open)
                S.Items |= (Low => Remaining_IV.High, 
                  Low_Is_Open => not Remaining_IV.High_Is_Open,
                  High => IV.High, 
                  High_Is_Open => IV.High_Is_Open)
                -- we are all done now
                exit loop
            end if

            -- May be something left
            Overlap : constant := IV and Remaining_IV
            IV -= Overlap

            if not Is_Empty(IV) then
                -- Worth putting the interval back
                S.Items |= IV
            end if

            continue loop with Remaining_IV => Remaining_IV - Overlap

        end loop

    end Remove_Interval

    function Is_Subset(Left, Right : Ordered_Set) return Boolean is
        -- Return True if Left is a subset of Right
        for Left_IV in Left loop
            for Remaining_IV := Left_IV while not Is_Empty(Remaining_IV) loop
                Right_IV : constant := Overlapping(Right.Items, Remaining_IV)
                if Right_IV is null then
                    -- Found some values that are not in Right
                    return #False
                end if

                -- Loop around with what is left
                continue loop with Remaining_IV => Remaining_IV - Right_IV
            end loop
        end loop
        -- Everything in Left was found in Right
        return #True
    end Is_Subset

    function "[]"() return Ordered_Set is
              return (Items => [])
    end "[]"

    function Singleton(Elem : Element_Type) return Result : Ordered_Set is
        -- Return a set consisting of a single element
        Result := []
        Result.Items |= Singleton(Elem)
    end Singleton

    function ".."(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left <= Right then
            Result.Items |= (Low => Left, Low_Is_Open => #False, 
              High => Right, High_Is_Open => #False)
        end if
    end ".."
          
    function "<.."(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #True,
              High => Right, High_Is_Open => #False)
        end if
    end "<.."
          
    function "<..<"(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #True,
              High => Right, High_Is_Open => #True)
        end if
    end "<..<"
          
    function "..<"(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        if Left < Right then
            Result.Items |= (Low => Left, Low_Is_Open => #False,
              High => Right, High_Is_Open => #True)
        end if
    end "..<"
          
    function "&"(Left, Right : Element_Type) return Result : Ordered_Set is
        Result := []
        Result |= Left
        if Left /= Right then
            Result |= Right
        end if
    end "&"

    function "&"(Left : Ordered_Set; Right : Element_Type) 
      return Result : Ordered_Set is
        Result := Left
        Result |= Right
    end "&"

    function "&"(Left : Element_Type; Right : Ordered_Set) return Ordered_Set is
              return Right | Left
    end "&"

    function "&"(Left : Ordered_Set; Right : Ordered_Set) 
      return Result : Ordered_Set is
        Result := Left
        Result |= Right
    end "&"

    procedure "&="(Left : in out Ordered_Set; Right : Element_Type) is
        Right_IV : constant : Element_Interval := Singleton(Right)
        Left_IV : constant := Overlapping(Left.Items, Right_IV)
        if Left_IV is null then
            -- Nothing overlaps, need to add it
            --  (might want to merge someday)
            Left.Items |= Right_IV
        end if
    end "&="

    procedure "<|="(Left : in out Ordered_Set; Right : in out access Element_Type) is
              -- Move element into set, leaving Right null afterward.
        -- TBD: No copy minimization done at the moment
        Left |= Right
        Right := null
    end "<|="

    procedure "&="(Left : in out Ordered_Set; Right : Ordered_Set) is
        if Count(Left.Items) = 0 then
            Left := Right
        else
            -- Make a copy of the Right set
            var Right_Copy for Left := Right

            -- Merge all of its intervals into Left
            Left <|= Right_Copy
        end if
    end "&="

    procedure "<|="(Left : in out Ordered_Set; Right : in out Ordered_Set) is
        -- Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) = 0 then
            Left.Items <== Right.Items
        else
            -- Iterate through the tree
            loop
                -- Extract interval from Right
                var Right_IV for Left := Remove_Any(Right.Items)
                if Right_IV is null then
                    return
                end if

                -- See whether it overlaps with an existing interval
                -- in Left tree
                var Left_IV for Left := Overlapping(Left.Items, Right_IV)
                while Left_IV not null loop
                    -- Incorporate left interval into Right_IV
                    Right_IV |= Left_IV

                    if Right_IV = Left_IV then
                        -- Right_IV fully subsumed by existing interval
                        Right_IV := null
                        exit loop
                    end if

                    -- Need to delete Left_IV 
                    Delete(Left.Items, Left_IV)

                    -- Now see if there is anything still overlapping
                    Left_IV := Overlapping(Left.Items, Right_IV)
                end loop

                if not Is_Empty(Right_IV) then
                    -- Add Right_IV
                    Left.Items <|= Right_IV
                end if

            end loop
        end if
    end "<|="

    function "-"(Left, Right : Ordered_Set) return Result : Ordered_Set is
      -- Set difference
        Result := Left
        Result -= Right
    end "-"

    procedure "-="(S : in out Ordered_Set; Elem : Element_Type) is
      -- Remove the given element from the set, if present
        Remove_Interval(S, Singleton(Elem))
    end "-="

    procedure "-="(Left : in out Ordered_Set; Right : Ordered_Set) is
      -- Remove all intervals of Right from Left, if present
        for IV in Right loop
            Remove_Interval(Left, IV)
        end loop
    end "-="

    function "and"(Left, Right : Ordered_Set) return Result : Ordered_Set is
        -- Intersection

        -- Add elements that are in both Right and Left into result
        Result := []
        for Right_IV in Right loop
            for Remaining_IV := Right_IV while Remaining_IV not null loop
                var Left_IV := Overlapping(Left.Items, Remaining_IV)

                if Left_IV is null then
                    exit loop
                end if

                -- Compute overlap, add into result, and then loop
                -- around after removing it from Remaining_IV
                Overlap : constant := Remaining_IV and Left_IV

                Result.Items |= Overlap

                continue loop with Remaining_IV => Remaining_IV - Overlap
            end loop
        end loop
    end "and"

    procedure "and="(Left : in out Ordered_Set; Right : Ordered_Set) is
        -- Intersection
        Left := Left and Right
    end "and="

    function "xor"(Left, Right : Ordered_Set) return Ordered_Set is
        -- Symmetric difference

        return (Left - Right) or (Right - Left)
    end "xor"

    procedure "xor="(Left : in out Ordered_Set; Right : Ordered_Set) is
        -- Symmetric difference
        -- Want elements that are only in one of the two inputs
        Only_In_Right : constant := Right - Left
        Left -= Right
        Left += Only_In_Right
    end "xor="

    function "in"(Left : Element_Type; Right : Ordered_Set) return Boolean is
        return Overlapping(Right.Items, Singleton(Left)) not null
    end "in"

    function "=?"(Left, Right : Ordered_Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
        if Is_Subset(Left, Right) then
            if Is_Subset(Right, Left) then
                return #equal
            else
                return #less
            end if
        elsif Is_Subset(Right, Left) then
            return #greater
        else
            return #unordered
        end if
    end "=?"

    function Is_Empty(S : Ordered_Set) return Boolean is
        -- Return count of items in set
        return Count(S.Items) = 0
    end Is_Empty

    function Lower_Bound(S : Ordered_Set) return Element_Type is
        First_IV : constant := First(S.Items)
        if First_IV is null then
            return null
        else
            return First_IV.Low
        end if
    end Lower_Bound

    function Lower_Bound_Is_Open(S : Ordered_Set) return Boolean is
        First_IV : constant := First(S.Items)
        if First_IV is null then
            return #True   -- TBD: or null?
        else
            return First_IV.Low_Is_Open
        end if
    end Lower_Bound_Is_Open

    function Upper_Bound(S : Ordered_Set) return Element_Type is
        Last_IV : constant := Last(S.Items)
        if Last_IV is null then
            return null
        else
            return Last_IV.High
        end if
    end Upper_Bound

    function Upper_Bound_Is_Open(S : Ordered_Set) return Boolean is
        Last_IV : constant := Last(S.Items)
        if Last_IV is null then
            return #True   -- TBD: or null?
        else
            return Last_IV.High_Is_Open
        end if
    end Upper_Bound_Is_Open

    function Remove_First(S : in out Ordered_Set) 
      return Interval<Element_Type> is
        -- Remove first interval of set (lowest low bound)
        return Remove_First(S.Items)
    end Remove_First

    function Remove_Last(S : in out Ordered_Set) 
      return Interval<Element_Type> is
        -- Remove last interval of set (highest high bound)
        return Remove_Last(S.Items)
    end Remove_Last

    function Remove_Any(S : in out Ordered_Set) 
      return Interval<Element_Type> is
        -- Remove an arbitrary interval of set
        return Remove_Any(S.Items)
    end Remove_Any

end A2X.Containers.Ordered_Set

procedure A2X.Test.Test_Ordered_Set(A, X, Y, Z : Univ_Real) is
    var S : Ordered_Set<Univ_Real> := X | Y..Z
    Println(A & " in " & X & "&" & Y & ".." & Z & "=" & ( A in S ))

    Agg : constant : Ordered_Set<Univ_Real> := [X, Y, Z]
    Or : constant : Ordered_Set<Univ_Real> := Y | Z | X
    Open_Ind : constant : Map<Boolean, Univ_String> := [#False => "", #True => "<"]

    Println(" [X, Y, Z] =? (Y | Z | X) --> " & ( Agg =? Or ))

    S := []

    var R := 0.0
    for I in 1..10 forward loop
        R += 1.0
        S += R
        Println("Adding " & R & " to S, Is_Empty(S) = " & Is_Empty(S))
    end loop

    var Xor := S xor [2.0, 5.0, 12.0, 15.0]
    Print("S xor [2.0, 5.0, 12.0, 15.0] = ")
    for IV in Xor forward loop
        if IV.Low /= IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] & ".." & 
              Open_Ind[IV.High_Is_Open] | IV.High & " ")
        else
            Print(IV.Low & " ")
        end if
    end loop
    Print("\n")
end A2X.Test.Test_Ordered_Set

package A2X.Core.Univ_Real is
    type Univ_Real is private

    function "+"(Right : Univ_Real) return Univ_Real
      with Import, External_Name => #identity;

    function "-"(Right : Univ_Real) return Univ_Real
      with Import, External_Name => #real_negate;

    function "abs"(Right : Univ_Real) return Univ_Real
      with Import, External_Name => #real_abs;

    function "magnitude"(Univ_Real) return Univ_Real is "abs"

    function "+"(Left, Right : Univ_Real) return Result : Univ_Real 
      with Import, External_Name => #real_add;

    function "-"(Left, Right : Univ_Real) return Result : Univ_Real
      with Import, External_Name => #real_subtract;

    function "*"(Left, Right : Univ_Real) return Result : Univ_Real 
      with Import, External_Name => #real_multiply;

    function "*"(Left : Univ_Real; Right : Univ_Integer) return Univ_Real
      with Import, External_Name => #real_int_multiply;

    function "*"(Left : Univ_Integer; Right : Univ_Real) return Univ_Real

    function "/"(Left, Right : Univ_Real) return Result : Univ_Real
      with Import, External_Name => #real_divide;

    function "/"(Left : Univ_Real; Right : Univ_Integer) return Univ_Real
      with Import, External_Name => #real_int_divide;

    function "**"(Left : Univ_Real; Right : Univ_Integer) return Univ_Real
      with Import, External_Name => #real_exp;

    procedure "+="(Left : in out Univ_Real; Right : Univ_Real) 
      with Import, External_Name => #real_assign_add;

    procedure "-="(Left : in out Univ_Real; Right : Univ_Real) 
      with Import, External_Name => #real_assign_subtract;

    procedure "*="(Left : in out Univ_Real; Right : Univ_Real) 
      with Import, External_Name => #real_assign_multiply;

    procedure "/="(Left : in out Univ_Real; Right : Univ_Real) 
      with Import, External_Name => #real_assign_divide;

    procedure "**="(Left : in out Univ_Real; Right : Univ_Integer) 
      with Import, External_Name => #real_assign_exp;


    function "=?"(Left, Right : Univ_Real) return Ordering
      with Import, External_Name => #real_compare;

    function Min(Left, Right : access Univ_Real) return Univ_Real
      with Import, External_Name => #real_min;
    function Max(Left, Right : access Univ_Real) return Univ_Real
      with Import, External_Name => #real_max;

    function Sqrt(Val : Univ_Real) return Univ_Real
      with Pre => Val >= 0.0;

    function Hash(Val : Univ_Real) return Univ_Integer
      with Import, External_Name => #identity;

    procedure Print(X : Univ_Real) with Import, External_Name => #print_real;

    procedure Put(X : Univ_Real) is Print

    function Image(Val : Univ_Real) return Univ_String
      with Import, External_Name => #to_string_real;

    function Value(Str : Univ_String) return Univ_Real
      with Import, External_Name => #from_string_real;

    function Round_To_Int(Real : Univ_Real) return Univ_Integer
      with Import, External_Name => #round_to_int;

    function Int_To_Real(Int : Univ_Integer) return Univ_Real
      with Import, External_Name => #int_to_real;

    function "in"(Left : Univ_Real; Right : Ordered_Set<Univ_Real>) return Boolean
      is of Ordered_Set<Univ_Real>

end A2X.Core.Univ_Real

package body A2X.Core.Univ_Real is
    function "*"(Left : Univ_Integer; Right : Univ_Real) return Univ_Real is
        -- Hand off to built-in real * int function
        return Right * Left
    end "*"

    function Sqrt(Val : Univ_Real) return Result : Univ_Real is
        pragma Assert (Val >= 0.0);
        Result := Val / 2.0
        while Result > 0.0 and then Result * Result / Val 
          not in 0.9999999999999 .. 1.00000000000001 loop
            Result := (Val / Result + Result)/2.0
        end loop
    end Sqrt

end A2X.Core.Univ_Real
    
procedure A2X.Test.Test_Real() is
    var X := 3.5
    var Y := 5.22
    var Z := X + Y

    Println("X = " & X & ", Y = " & Y & ", X + Y = " & Z)
    var Teeny := 0.000023
    Println("Teeny = " & Teeny)
    var Small := 0.005
    Println("Small = " & Small)
    var Medium := 235.123
    Println("Medium = " & Medium)
    var Big := 11.0**5
    Println("Big = " & Big)
    var Huge := 13.0**15
    Println("Huge = " & Huge)

    Println("Y in 1.0 .. 6.0 = " & ( Y in 1.0 .. 6.0 ))
    
    Println("Y in 1.0 ..< 5.22 = " & ( Y in 1.0 ..< 5.22 ))

    Println("Sqrt(2.0) = " & Sqrt(2.0))

    var Neg := -2.0;
    Println("Sqrt(-2.0) = " & Sqrt(Neg))
end A2X.Test.Test_Real

generic
    Digits : Univ_Integer := 15
package A2X.Core.Float is
        -- A floating point type that provides at least the
        -- given number of digits of precision.
    type Float is private

    function "from_univ"(Univ : Univ_Real) return Float
            with Import, External_Name => #identity;

    function "to_univ"(Val : Float) return Univ_Real
            with Import, External_Name => #identity;

    function "+"(Right : Float) return Float
            with Import, External_Name => #identity;

    function "-"(Right : Float) return Float
            with Import, External_Name => #real_negate;

    function "abs"(Right : Float) return Float
            with Import, External_Name => #real_abs;

    function "magnitude"(Float) return Float is "abs"

    function "+"(Left, Right : Float) return Result : Float 
            with Import, External_Name => #real_add;

    function "-"(Left, Right : Float) return Result : Float
            with Import, External_Name => #real_subtract;

    function "*"(Left, Right : Float) return Result : Float 
            with Import, External_Name => #real_multiply;

    function "*"(Left : Float; Right : Univ_Integer) return Result : Float 
            with Import, External_Name => #real_int_multiply;

    function "*"(Left : Univ_Integer; Right : Float) return Result : Float

    function "/"(Left, Right : Float) return Result : Float
            with Import, External_Name => #real_divide;

    function "/"(Left : Float; Right : Univ_Integer) return Result : Float
            with Import, External_Name => #real_int_divide;

    function "**"(Left : Float; Right : Univ_Integer) return Float
            with Import, External_Name => #real_exp;

    procedure "+="(Left : in out Float; Right : Float) 
            with Import, External_Name => #real_assign_add;

    procedure "-="(Left : in out Float; Right : Float) 
            with Import, External_Name => #real_assign_subtract;

    procedure "*="(Left : in out Float; Right : Float) 
            with Import, External_Name => #real_assign_multiply;

    procedure "/="(Left : in out Float; Right : Float) 
            with Import, External_Name => #real_assign_divide;

    procedure "**="(Left : in out Float; Right : Univ_Integer) 
            with Import, External_Name => #real_assign_exp;


    function "=?"(Left, Right : Float) return Ordering
            with Import, External_Name => #real_compare;

    function Min(Left, Right : access Float) return Float
            with Import, External_Name => #real_min;
    function Max(Left, Right : access Float) return Float
            with Import, External_Name => #real_max;

    function Hash(Val : Float) return Univ_Integer
            with Import, External_Name => #identity;

    function Round_To_Int(Val : Float) return Univ_Integer
            with Import, External_Name => #round_to_int;

    function Int_To_Float(Int : Univ_Integer) return Float
            with Import, External_Name => #int_to_real;

    procedure Print(X : Float) with Import, External_Name => #print_real;

    procedure Put(X : Float) is Print

    function Image(Val : Float) return Univ_String
            with Import, External_Name => #to_string_real;

    function Value(Str : Univ_String) return Float
            with Import, External_Name => #from_string_real;

    function "in"(Left : Float; Right : Ordered_Set<Float>) return Boolean
            is of Ordered_Set<Float>
        -- "in" defined in Ordered_Set

          
end A2X.Core.Float

package body A2X.Core.Float is
    type Float is record
        Value : constant : Univ_Real
    end record;
    function "*"(Left : Univ_Integer; Right : Float) return Result : Float is
        -- Hand off to built-in real*int function
        return Right * Left
    end "*"
end A2X.Core.Float
          
procedure A2X.Test.Test_Float() is
    subtype My_Float is Float<Digits => 8>

    var X : My_Float := 3.5
    var Y : My_Float := 5.22
    var Z : My_Float := X + Y

    Println("X = " & X & ", Y = " & Y & ", X + Y = " & Z)
    var Teeny := 0.000023
    Println("Teeny = " & Teeny)
    var Small := 0.005
    Println("Small = " & Small)
    var Medium := 235.123
    Println("Medium = " & Medium)
    var Big := 11.0**5
    Println("Big = " & Big)
    var Huge := 13.0**15
    Println("Huge = " & Huge)

    var X2 : My_Float := 3.5 * 2

    Println("X * 2 = " & X * 2 & ", 2 * X = " & 2 * X & ", X2 = " & X2)
    Println("X / 2 = " & X / 2 )

    if X in 1.5 ..< 3.6 then
        Println("X *is* in 1.5 ..< 3.6")
    else
        Println("X *not* in 1.5 ..< 3.6??")
    end if

    Println("X in 1.5 ..< 3.5 = " & (X in 1.5 ..< 3.5) )
end A2X.Test.Test_Float

generic
    Delta : Univ_Real
package A2X.Core.Fixed is
  -- Fixed point types, represented as an integer
  -- multiple of the given Delta
    type Fixed is private

    function "from_univ"(Univ : Univ_Real) return Fixed
    function "to_univ"(Val : access Fixed) return Univ_Real

    function "+"(Right : Fixed) return Fixed
            with Import, External_Name => #identity;

    function "-"(Right : Fixed) return Fixed
            with Import, External_Name => #negate;

    function "abs"(Right : Fixed) return Fixed
            with Import, External_Name => "abs";

    function "magnitude"(Fixed) return Fixed is "abs"

    function "+"(Left, Right : Fixed) return Fixed
            with Import, External_Name => "+";
    function "-"(Left, Right : Fixed) return Fixed
            with Import, External_Name => "-";
    function "*"(Left : Fixed; Right : Univ_Real) return Fixed
            with Import, External_Name => #fixed_real_mul;
    function "*"(Left : Univ_Real; Right : Fixed) return Fixed
            with Import, External_Name => #real_fixed_mul;
    function "*"(Left : Fixed; Right : Univ_Integer) return Fixed
            with Import, External_Name => "*";
    function "*"(Left : Univ_Integer; Right : Fixed) return Fixed
            with Import, External_Name => "*";
    function "/"(Left : Fixed; Right : Univ_Real) return Fixed
            with Import, External_Name => #fixed_real_div;
    function "/"(Left : Fixed; Right : Univ_Integer) return Fixed
            with Import, External_Name => "/";

    procedure "+="(Left : in out Fixed; Right : Fixed) 
            with Import, External_Name => "+=";

    procedure "-="(Left : in out Fixed; Right : Fixed) 
            with Import, External_Name => "-=";

    procedure "*="(Left : in out Fixed; Right : Fixed) 
            with Import, External_Name => "*=";

    procedure "/="(Left : in out Fixed; Right : Univ_Integer) 
            with Import, External_Name => "/=";

    procedure "/="(Left : in out Fixed; Right : Univ_Real)

    function "=?"(Left, Right : Fixed) return Ordering
            with Import, External_Name => "=?";

    function Min(Left, Right : access Fixed) return Fixed
            with Import, External_Name => #min;
    function Max(Left, Right : access Fixed) return Fixed
            with Import, External_Name => #max;

    function Hash(Val : Fixed) return Univ_Integer
            with Import, External_Name => #identity;

    function Round_To_Int(Val : Fixed) return Univ_Integer

    procedure Print(X : Fixed)

    procedure Put(X : Fixed) is Print

    function Image(Val : Fixed) return Univ_String

    function Value(Str : Univ_String) return Fixed

    function "in"(Left : Fixed; Right : Ordered_Set<Fixed>) 
            return Boolean is of Ordered_Set<Fixed>
          
end A2X.Core.Fixed

package body A2X.Core.Fixed is
    type Fixed is record
        Value : constant : Univ_Integer
    end record;

    function "from_univ"(Univ : Univ_Real) return Fixed is
        return (Value => Univ_Real.Round_To_Int(Univ/Delta))
    end "from_univ"

    function "to_univ"(Val : access Fixed) return Univ_Real is
        if Val is null then
            return null
        else
            return Delta * Int_To_Real(Val.Value)
        end if
    end "to_univ"

    procedure "/="(Left : in out Fixed; Right : Univ_Real) is
        Left := Left / Right
    end "/="

    procedure Print(X : Fixed) is
        var Val : Univ_Real := [[X]]
        Print(Val)
    end Print

    function Image(Val : Fixed) return Univ_String is
        return Univ_Real'Image([[Val]])
    end Image

    function Value(Str : Univ_String) return Fixed is
        return Univ_Real'Value(Str)
    end Value

    function Round_To_Int(Val : Fixed) return Univ_Integer is
        return Univ_Real.Round_To_Int([[Val]])
    end Round_To_Int

end A2X.Core.Fixed

procedure A2X.Test.Test_Fixed(X : Univ_Real) is
    subtype My_Fixed is Fixed<Delta => 1.0E-6>

    var XTI : My_Fixed := X
    Minute : constant : My_Fixed := 60.0
    Println("X = " & XTI)
    Println("X * 2 = " & (XTI*2))
    Println("X + X = " & (XTI + XTI))
    Println("X - X = " & (XTI - XTI))
    Println("X / 2 = " & (XTI / 2))
    Println("X / 2.0 = " & (XTI / 2.0))
    Println("X * 3.0 = " & (XTI * 3.0))
    Println("5.0 * X = " & (5.0 * XTI))
    Println("-5.0 * X = " & (-5.0 * XTI))
    Println("-5.0 = " & -5.0)
    Println("Minute = " & Minute)
    Println("-5.0*Minute = " & -5.0*Minute)

    Println("Round_To_Int(X) = " & Round_To_Int(XTI))

    Rng : constant : Ordered_Set<My_Fixed> := 1.0 ..< 5.0

    Print("Rng = ")
    Open_Ind : constant : Map<Boolean, Univ_String> := [#False => "", #True => "<"]
    for IV in Rng forward loop
        if IV.Low /= IV.High then
            Print(IV.Low | Open_Ind[IV.Low_Is_Open] & ".." & 
              Open_Ind[IV.High_Is_Open] | IV.High & " ")
        else
                  Print(IV.Low & " ")
        end if
    end loop
    Print("\n")

    Println("X = " & XTI)
    Println("X in Rng = " & (XTI in Rng))

    if XTI in 1.0 ..< 5.0 then
        Println("X in 1.0 ..< 5.0")
    else
        Println("X not in 1.0 ..< 5.0")
    end if

    Println("X in 1.0 ..< 5.0 = " & (XTI in 1.0 ..< 5.0))

end A2X.Test.Test_Fixed

package A2X.Core.Time is
  -- Time in nanoseconds since Jan 1, 1970
    type Time is private

    type Time_Interval is new Fixed<Delta => 1.0E-9>

    Second : constant : Time_Interval := 1.0
    Millisecond : constant : Time_Interval := 1.0/1000
    Microsecond : constant : Time_Interval := 1.0/10**6
    Nanosecond : constant : Time_Interval := 1.0/10**9

    Minute : constant : Time_Interval := 60.0
    Hour : constant : Time_Interval := 60 * Minute
    Day : constant : Time_Interval := 24 * Hour

    type Month_Enum is new Enum< 
       [#Jan, #Feb, #Mar, #Apr, #May, #Jun,
        #Jul, #Aug, #Sep, #Oct, #Nov, #Dec] >

    function Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      return Time
      with Pre => Year in 1970 .. 2399
        and then Day_Of_Month in 1..31
        and then Time_Zone in -12.0*Hour .. +12.0*Hour
        and then Time_Of_Day in 0.0 .. 86400.0;

    function Zero() return Time

    function "+"(Left : Time; Right : Time_Interval) return Time
      with Import, External_Name => "+";
    function "+"(Left : Time_Interval; Right : Time) return Time
      with Import, External_Name => "+";
    function "-"(Left : Time; Right : Time_Interval) return Time
      with Import, External_Name => "-";
    function "-"(Left, Right : Time) return Time_Interval
      with Import, External_Name => "-";

    function "=?"(Left, Right : Time) return Ordering
      with Import, External_Name => "=?";
end A2X.Core.Time

package body A2X.Core.Time is
    type Time is record
        Since_1970 : constant : Time_Interval
    end record

    type Year_Kind is new Enum< [#normal, #leap] >

    Month_Base : constant : Array<Array<Univ_Integer, Indexed_By => Year_Kind>,
      Indexed_By => Month_Enum> := 
        [#Jan => [0, 0], #Feb => [31, 31], #Mar => [59, 60], #Apr => [90, 91],
         #May => [120, 121], #Jun => [151, 152], #Jul => [181, 182],
         #Aug => [212, 213], #Sep => [243, 244], #Oct => [273, 274],
         #Nov => [304, 305], #Dec => [334, 335]]

    function Kind_Of_Year(Year : Univ_Integer) return Year_Kind is
        if Year mod 4 = 0 and then
          (Year mod 100 /= 0 or else Year mod 400 = 0) then
            -- Every 100 years leap year is omitted, 
            -- except for multiples of 400 which *are* leap years.
            return #leap
        else
            return #normal
        end if
    end Kind_Of_Year

    function Leaps_Before(Year : Univ_Integer) return Univ_Integer is
        -- Number of leap years before this year, starting from 1970
        if Year < 2101 then
            return (Year-1969)/4
        else
            -- Every 100 years leap year is omitted, 
            -- except for multiples of 400 which *are* leap years.
            return (Year-1969)/4 - (Year-2001)/100
        end if
    end Leaps_Before


    function Create(Year : Univ_Integer; Month : Month_Enum;
      Day_Of_Month : Univ_Integer;
      Time_Of_Day : Time_Interval := 0.0;
      Time_Zone : Time_Interval := 0.0)
      return Time is
        -- Determine number of nanos since Jan 1, 1970
        Kind : constant := Kind_Of_Year(1970)
        Base : constant := Month_Base[Month][Kind]

        return (Since_1970 => 
          (Year-1970) * (365*Day) + 
          (Leaps_Before(Year) + Base + Day_Of_Month)*Day +
          Time_Of_Day - Time_Zone)
    end Create

    function Zero() return Time is
        return (Since_1970 => 0.0)
    end Zero

end A2X.Core.Time

procedure A2X.Test.Test_Time(X : Univ_Real) is
    var XTI : Time.Time_Interval := X
    Local_Minute : constant : Time.Time_Interval := 60.0
    Println("X = " & XTI)
    Println("X * 2 = " & XTI*2)
    Println("X + X = " & (XTI + XTI))
    Println("X - X = " & (XTI - XTI))
    Println("X / 2 = " & (XTI / 2))
    Println("X / 2.0 = " & (XTI / 2.0))
    Println("X * 3.0 = " & (XTI * 3.0))
    Println("5.0 * X = " & (5.0 * XTI))
    Println("-5.0 * X = " & (-5.0 * XTI))
    Println("-5.0 = " & -5.0)
    Println("Local_Minute = " & Local_Minute)
    Println("-5.0*Local_Minute = " & (-5.0*Local_Minute))
    Println("Time.Minute = " & Time.Minute)
    Println("-5.0*Time.Minute = " & (-5.0*Time.Minute))
    Println("Time.Hour = " & Time.Hour )
    Println("-5.0*Time.Hour = " & (-5.0*Time.Hour))

    var T : Time := Create(Year => 2011, Month => #Oct, Day_Of_Month => 18,
      Time_Of_Day => 10*Time.Hour + 5*Time.Minute,
      Time_Zone => -5.0*Time.Hour)

    Println("18-Oct-2011 = " & ( T - Zero() ))
    Println("X = " & XTI )
    Println("18-Oct-2011 - X = " & ( (T - XTI) - Zero() ) )

end A2X.Test.Test_Time
     
package A2X.Core.Clock is
    -- A module that provides access to a wall clock and
    -- to other timers, and an ability to delay the caller
    -- for a given amount of time, or until a specified time
    -- in the future.
    type Clock is protected private
    
    function Create() return Clock
        -- Create a clock, which corresponds to the current wall clock time

    function Create(Now : Time) return Clock
        -- Create a clock, where Now() return s the given time when created

    function Now(locked C : Clock) return Time
        -- Return current reading of clock

    queued procedure Delay(C : Clock; Until : Time)
        -- Wait until the given clock reads >= Until

    queued procedure Delay(C : Clock; For : Time.Time_Interval)
        -- Wait until the given clock reads "Now(C) + For"

    procedure Set(locked C : in out Clock; To : Time)
        -- Update clock so it reads the given time
end A2X.Core.Clock

package body A2X.Core.Clock is
    type Clock is protected record
        Timer_Delta : Time.Time_Interval
        -- Amount to be subtracted from Current Time
        -- to produce value of timer
    end record

    function Current_Time(locked C : Clock) return Time 
      with Import, External_Name => #clock_current_time;
        -- NOTE: Clock parameter is ignored; return s wall clock

    procedure Wait_For_Delay(queued C : Clock; Until : Time) is 
      import(#clock_delay)
        -- Wait until the wall clock reads >= Until
        -- NOTE: Clock parameter is ignored

    function Create() return Clock is
        -- Create a clock, which corresponds to the current wall clock time
        -- Println("Create Clock with Delta 0.0")
        return (Timer_Delta => 0.0)
    end Create

    function Create(Now : Time) return Result : Clock is
        -- Create a clock, where Now() return s the given time when created
        Delta : constant := Current_Time(Create()) - Now
        -- Println("Create Clock with Delta = " & Delta)
        return (Timer_Delta => Current_Time(Create()) - Now)
    end Create

    function Now(locked C : Clock) return Result : Time is
        -- Return current reading of clock
        Result := Current_Time(C) - C.Timer_Delta
        -- Println("Now return ing " & Result-Zero())
    end Now

    queued procedure Delay(C : Clock; Until : Time) is
        -- Wait until the given clock reads >= Until
        Wait_For_Delay(C, Until + C.Timer_Delta)
    end Delay

    queued procedure Delay(C : Clock; For : Time.Time_Interval) is
        -- Wait until the given clock reads "Now(C) + For"
        -- NOTE: Timer_Delta is irrelevant for this one
        -- Println("Wait for delay of " & For)
        Time_Now : constant := Current_Time(C)
        Until : constant := Time_Now + For
        -- Println("Time_Now + " & For & " - Time_Now = " & Until - Time_Now)
        Wait_For_Delay(C, Until)
    end Delay

    procedure Set(locked C : in out Clock; To : Time) is
        -- Update clock so it reads the given time
        C.Timer_Delta := Current_Time(C) - To
    end Set

end A2X.Core.Clock

procedure A2X.Test.Test_Clock() is
    var C := Clock.Create()
    Start : constant := C.Now()

  then
    Println("About to delay 4.0 seconds")
    C.Delay(4.0)
    Println("Done with delay of 4.0")
  ||
    Println("About to delay 2.0 seconds")
    C.Delay(2.0)
    Println("Done with delay of 2.0")
||    -- check that indent of 0 works
    for I in 1..7 loop
        Println("In loop delaying for 1.0")
        C.Delay(1.0)
        Println("Done with delay " & I & " of 1.0")
    end loop
then  -- check that indent of 0 works
    Println("Elapsed time: " & (C.Now() - Start))
end A2X.Test.Test_Clock

generic
    Modulus : Univ_Integer
package A2X.Core.Modular is
  -- This is an unsigned type whose arithmetic is "modulo" the modulus
    type Modular is private

    function "from_univ"(Lit : Univ_Integer) return Modular 
      with Import, External_Name => #integer_from_univ;

    function "to_univ"(Val : Modular) return Univ_Integer 
      with Import, External_Name => #integer_to_univ;

    function "+"(Right : Modular) return Modular
      with Import, External_Name => #identity;

    function "-"(Right : Modular) return Modular

    function "abs"(Right : Modular) return Modular
      with Import, External_Name => #identity;

    function "magnitude"(Modular) return Modular is "abs"

    function "+"(Left, Right : Modular) return Result : Modular

    function "-"(Left, Right : Modular) return Result : Modular

    function "*"(Left, Right : Modular) return Result : Modular

    function "/"(Left, Right : Modular) return Result : Modular
      with Import, External_Name => "/";

    function "mod"(Left, Right : Modular) return Modular
      with Import, External_Name => "mod";

    function "rem"(Left, Right : Modular) return Modular
      with Import, External_Name => "rem";

    function "**"(Left : Modular; Right : Univ_Integer) return Result : Modular

    procedure "+="(Left : in out Modular; Right : Modular)

    procedure "-="(Left : in out Modular; Right : Modular)

    procedure "*="(Left : in out Modular; Right : Modular)

    procedure "/="(Left : in out Modular; Right : Modular) 
      with Import, External_Name => "/=";

    procedure "**="(Left : in out Modular; Right : Univ_Integer)

    function "=?"(Left, Right : Modular) return Ordering
      with Import, External_Name => "=?";

    function "and"(Left, Right : Modular) return Modular with Import, External_Name => #bit_and;
    function "or"(Left, Right : Modular) return Modular
    function "xor"(Left, Right : Modular) return Modular
    function "not"(M : Modular) return Modular

    function Min(Left, Right : access Modular) return Modular
      with Import, External_Name => #min;
    function Max(Left, Right : access Modular) return Modular
      with Import, External_Name => #max;

    function Hash(Val : Modular) return Univ_Integer
      with Import, External_Name => #identity;

    procedure Print(X : Modular) with Import, External_Name => #print_int;

    procedure Put(X : Modular) is Print

    function Image(Val : Modular) return Univ_String
      with Import, External_Name => #to_string_int;

    function Value(Str : Univ_String) return Modular

    function First() return Modular

    function Last() return Modular

    function "[..]"() return Countable_Range<Modular> is of Countable_Range<Modular>

    function ".."(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    function "<.."(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    function "..<"(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    function "<..<"(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
    function "&"(Left, Right : Modular) return Countable_Set<Modular>
      is of Countable_Set<Modular>
  implements -- for Countable
    -- These operations are needed so Modular satifies
    -- requirements of "Countable" interface, but these
    -- operations are not directly callable (if they were callable,
    -- we would have ambiguity when adding an Modular to an int-literal).

    function "+"(Left : Modular; Right : Univ_Integer) return Result : Modular

    function "+"(Left : Univ_Integer; Right : Modular) return Result : Modular

    function "-"(Left : Modular; Right : Univ_Integer) return Result : Modular

    function "-"(Left, Right : Modular) return Result : Univ_Integer

end A2X.Core.Modular

package body A2X.Core.Modular is
    type Modular is record
        Content : constant : Univ_Integer;  -- So this ends up as a wrapper
    end record Modular

    function Bit_Or(Left, Right : Univ_Integer) return Univ_Integer 
      with Import, External_Name => #bit_or;

    function Bit_Xor(Left, Right : Univ_Integer) return Univ_Integer 
      with Import, External_Name => #bit_xor;
    function "-"(Right : Modular) return Modular is
        return (Content => Modulus - Right.Content)
    end "-"

    function "+"(Left, Right : Modular) return Result : Modular is
        return (Content => (Left.Content + Right.Content) mod Modulus)
    end "+"

    function "-"(Left, Right : Modular) return Result : Modular is
        return (Content => (Left.Content - Right.Content) mod Modulus)
    end "-"

    function "*"(Left, Right : Modular) return Result : Modular is
        return (Content => (Left.Content * Right.Content) mod Modulus)
    end "*"

    function "**"(Left : Modular; Right : Univ_Integer) return Result : Modular is
        return (Content => (Left.Content ** Right) mod Modulus)
    end "**"

    procedure "+="(Left : in out Modular; Right : Modular) is
        Left := (Content => (Left.Content + Right.Content) mod Modulus)
    end "+="

    procedure "-="(Left : in out Modular; Right : Modular) is
        Left := (Content => (Left.Content - Right.Content) mod Modulus)
    end "-="

    procedure "*="(Left : in out Modular; Right : Modular) is
        Left := (Content => (Left.Content * Right.Content) mod Modulus)
    end "*="

    procedure "**="(Left : in out Modular; Right : Univ_Integer) is
        Left := (Content => (Left.Content ** Right) mod Modulus)
    end "**="

    function Value(Str : Univ_String) return Modular is
        Val : constant : Univ_Integer := Value(Str)
        if Val is null or else Val in 0..<Modulus then
            return (Content => Val)
        else
            return null
        end if
    end Value

    function "or"(Left, Right : Modular) return Modular is
        return (Content => Bit_Or(Left.Content, Right.Content) mod Modulus)
    end "or"

    function "xor"(Left, Right : Modular) return Modular is
        return (Content => Bit_Xor(Left.Content, Right.Content) mod Modulus)
    end "xor"

    function "not"(M : Modular) return Modular is
        return (Content => Modulus - 1 - M.Content)
    end "not"

    function First() return Modular is
        return (Content => 0)
    end First

    function Last() return Modular is
        return (Content => Modulus-1)
    end Last

    -- implements -- for Countable
    -- These operations are needed so Modular satifies
    -- requirements of "Countable" interface, but these
    -- operations are not directly callable (if they were callable,
    -- we would have ambiguity when adding an Modular to an int-literal).

    function "+"(Left : Modular; Right : Univ_Integer) return Result : Modular is
        return (Content => (Left.Content + Right) mod Modulus)
    end "+"

    function "+"(Left : Univ_Integer; Right : Modular) return Result : Modular is
        return (Content => (Left + Right.Content) mod Modulus)
    end "+"

    function "-"(Left : Modular; Right : Univ_Integer) return Result : Modular is
        return (Content => (Left.Content - Right) mod Modulus)
    end "-"

    function "-"(Left, Right : Modular) return Result : Univ_Integer is
        return (Left.Content - Right.Content) mod Modulus
    end "-"
end A2X.Core.Modular
    
procedure A2X.Test.Test_Modular() is
    type Mod16 is new Modular<16>

    Println("Testing mod 16")
    Println("0xA + 0xA = " & (Mod16'(0xA) + Mod16'(0xA)))
    Println("0xA or 0x1 = " & (Mod16'(0xA) or Mod16'(0x1)))
    Println("0xA xor 0x2 = " & (Mod16'(0xA) xor Mod16'(0x2)))
    Println("not 0xA = " & (not Mod16'(0xA)))
end A2X.Test.Test_Modular

generic
    type Element_Type is new Comparable
package A2X.Containers.Discrete_Ordered_Set is
  -- A set over individual but ordered elements
    type Discrete_Ordered_Set is private

    function "[]"() return Discrete_Ordered_Set

    function Singleton(Elem : Element_Type) return Discrete_Ordered_Set

    function "&"(Left, Right : Element_Type) return Discrete_Ordered_Set
    function "&"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      return Discrete_Ordered_Set
    function "&"(Left : Element_Type; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set
    function "&"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set

    procedure "&="(Left : in out Discrete_Ordered_Set; Right : Element_Type)
    procedure "&="(Left : in out Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    procedure "<|="(Left : in out Discrete_Ordered_Set;
      var Right : access Element_Type)
        -- Move element into set, leaving Right null afterward.

    procedure "<|="(Left : in out Discrete_Ordered_Set;
      var Right : Discrete_Ordered_Set)
        -- Move all elements of Right into Left, leaving Right empty.

    function "-"(Left, Right : Discrete_Ordered_Set) return Discrete_Ordered_Set
      -- Set difference
    function "-"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      return Discrete_Ordered_Set
      -- Remove one element
    procedure "-="(S : in out Discrete_Ordered_Set; Elem : Element_Type)
      -- Remove the given element from the set, if present
    procedure "-="(Left : in out Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      -- Remove all elements of Right from Left, if present

    function "or"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set is "&"   -- union
    procedure "or="(Left : in out Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      is "&="

    function "+"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set is "&"   -- Union
    procedure "+="(Left : in out Discrete_Ordered_Set; Right : Discrete_Ordered_Set)
      is "&="
    procedure "+="(Left : in out Discrete_Ordered_Set; Right : Element_Type) is "&="
   
    function "and"(Left, Right : Discrete_Ordered_Set) return Discrete_Ordered_Set
        -- Intersection
    procedure "and="(Left : in out Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    function "xor"(Left, Right : Discrete_Ordered_Set) return Discrete_Ordered_Set
        -- Symmetric difference
    procedure "xor="(Left : in out Discrete_Ordered_Set; Right : Discrete_Ordered_Set)

    function "in"(Left : Element_Type; Right : Discrete_Ordered_Set) return Boolean

    function "=?"(Left, Right : Discrete_Ordered_Set) return Ordering
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise

    function Count(S : Discrete_Ordered_Set) return Univ_Integer

    function "magnitude"(Discrete_Ordered_Set) return Univ_Integer is Count

    function Is_Empty(S : Discrete_Ordered_Set) return Boolean

    function First(S : Discrete_Ordered_Set) return Element_Type
    function Last(S : Discrete_Ordered_Set) return Element_Type

    function Remove_First(S : in out Discrete_Ordered_Set) return Element_Type
        -- Remove first element of set (lowest value)

    function Remove_Last(S : in out Discrete_Ordered_Set) return Element_Type
        -- Remove last element of set (highest value)

    function Remove_Any(S : in out Discrete_Ordered_Set) return Element_Type
        -- Remove an arbitrary element of set

end A2X.Containers.Discrete_Ordered_Set

package body A2X.Containers.Discrete_Ordered_Set is

    type Discrete_Ordered_Set is record
        Items : access AA_Tree<Element_Type>
    end record Discrete_Ordered_Set

    function "[]"() return Discrete_Ordered_Set is
        return (Items => [])
    end "[]"

    function Singleton(Elem : Element_Type) return Result : Discrete_Ordered_Set is
        Result := []
        Result.Items |= Elem
    end Singleton

    function "&"(Left, Right : Element_Type) return Result : Discrete_Ordered_Set is
        Result := [];
        Result.Items |= Left;
        Result.Items |= Right;
    end "&"

    function "&"(Left : Discrete_Ordered_Set; Right : Element_Type) 
      return Result : Discrete_Ordered_Set is
        Result := Left
        Result.Items |= Right
    end "&"

    function "&"(Left : Element_Type; Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set is
        return Right | Left
    end "&"

    function "&"(Left : Discrete_Ordered_Set; Right : Discrete_Ordered_Set) 
      return Result : Discrete_Ordered_Set is
        Result := Left
        Result |= Right
    end "&"

    procedure "&="(Left : in out Discrete_Ordered_Set; Right : Element_Type) is
        Left.Items |= Right;
    end "&="

    procedure "<|="(Left : in out Discrete_Ordered_Set;
      var Right : access Element_Type)
      is
        -- Move element into set, leaving Right null afterward.
        Left.Items <|= Right
    end "<|="

    procedure "<|="(Left : in out Discrete_Ordered_Set;
      var Right : Discrete_Ordered_Set)
      is
  -- Move all elements of Right into Left, leaving Right empty.
        if Count(Left.Items) = 0 then
            Left.Items <== Right.Items
        else
            -- Iterate through the tree
            loop
                -- Extract element from right
                var Elem for Left := Remove_Any(Right.Items)

                if Elem is null then
                    return   -- All done
                end if

                Left.Items <|= Elem

            end loop
        end if
    end "<|="

    procedure "&="(Left : in out Discrete_Ordered_Set; Right : Discrete_Ordered_Set) is
        -- Pass the buck to the "<|=" operation
        var Right_Copy for Left := Right
        Left <|= Right_Copy
    end "&="

    function "-"(Left, Right : Discrete_Ordered_Set) 
      return Result : Discrete_Ordered_Set is
      -- Set difference
        Result := Left
        Result -= Right
    end "-"

    function "-"(Left : Discrete_Ordered_Set; Right : Element_Type)
      return Result : Discrete_Ordered_Set is
      -- Remove one element
        Result := Left
        Result -= Right
    end "-"
        
    function "and"(Left, Right : Discrete_Ordered_Set)
      return Result : Discrete_Ordered_Set is
        -- Intersection
        Result := []
        for Elem in Right loop
            if Elem in Left then
                Result += Elem
            end if
        end loop
    end "and"

    function "xor"(Left, Right : Discrete_Ordered_Set) 
      return Discrete_Ordered_Set is
        -- Symmetric difference
        return Result : Discrete_Ordered_Set := Left do
           Result xor= Right
        end return;
    end "xor"

    function "in"(Left : Element_Type; Right : Discrete_Ordered_Set)
      return Boolean is
        return Overlapping(Right.Items, Left) not null
    end "in"

    function "=?"(Left, Right : Discrete_Ordered_Set) return Ordering is
        -- Return #equal if Left and Right have the same elements
        -- Return #less if Left is a proper subset of Right
        -- Return #greater if Left is a proper superset of Right
        -- Return #unordered otherwise
        var Overlaps := 0
        var Missing := 0
        for Elem in Left loop
            if Elem not in Right then
                Missing += 1
            else
                Overlaps += 1
            end if
        end loop

        if Missing > 0 then
            -- Can't be equal, but Left might be a proper superset
            if Overlaps < Count(Right) then
                return #unordered
            else
                -- Left is a superset
                return #greater
            end if
        else
            -- Might be equal or Left might be a proper subset
            if Overlaps < Count(Right) then
                -- Left is a proper subset of Right
                return #less
            else
                return #equal
            end if
        end if
    end "=?"

    function Count(S : Discrete_Ordered_Set) return Result : Univ_Integer is
        -- Return count of items in set
        return Count(S.Items);
    end Count

    function Is_Empty(S : Discrete_Ordered_Set) return Boolean is
        return Is_Empty(S.Items)
    end Is_Empty

    function First(S : Discrete_Ordered_Set) return Element_Type is
        return First(S.Items);
    end First

    function Last(S : Discrete_Ordered_Set) return Element_Type is
        return Last(S.Items);
    end Last

    function Remove_First(S : in out Discrete_Ordered_Set) 
      return Result : access Element_Type is
        -- Return first element of set
        return Remove_First(S.Items)
    end Remove_First

    function Remove_Last(S : in out Discrete_Ordered_Set) 
      return Result : access Element_Type is
        -- Remove last element of set
        return Remove_Last(S.Items);
    end Remove_Last

    function Remove_Any(S : in out Discrete_Ordered_Set)
      return Element_Type is
        -- Remove any element of set
        return Remove_Any(S.Items);
    end Remove_Any

end A2X.Containers.Discrete_Ordered_Set

generic
    type Rep_Type is new Imageable;
    Rep_Map : Map<Univ_Enumeration, Rep_Type>
package A2X.Core.Enum_With_Rep is
  -- An enumeration type specified using a map from literal to value
  -- of an underlying representation type.

    type Enum_With_Rep is private

    function "from_univ"(Univ : Univ_Enumeration) 
      return Enum_With_Rep
      with Pre => (for some [Lit => Val] of Rep_Map => Lit = Univ);
    function "to_univ"(Val : access Enum_With_Rep)
      return Result : access Univ_Enumeration
      with Post => Result is null or else
        (for some [Lit => Value] of Rep_Map => Lit = Result);

    -- Functions to convert from/to rep
    function From_Rep (Rep : access Rep_Type) return Enum_With_Rep
    function To_Rep (Val : access Enum_With_Rep) return Rep_Type

    function "[..]"() return Discrete_Ordered_Set<Enum_With_Rep>

    function "=?"(Left, Right : Enum_With_Rep) return Ordering

    -- Functions for Imageable
    function Image(Val : Enum_With_Rep) return Univ_String
    function Value(Str : Univ_String) return Enum_With_Rep

    function Hash(Val : Enum_With_Rep) return Univ_Integer

    function Min(Left, Right : access Enum_With_Rep) return Enum_With_Rep
    function Max(Left, Right : access Enum_With_Rep) return Enum_With_Rep

end A2X.Core.Enum_With_Rep

package body A2X.Core.Enum_With_Rep is
    type Enum_With_Rep is record
        Rep : constant : Rep_Type
    end record Enum_With_Rep
    function "from_univ"(Univ : Univ_Enumeration) 
      return Enum_With_Rep is
        return (Rep => Rep_Map[Univ]);
    end "from_univ"

    function "to_univ"(Val : access Enum_With_Rep) 
      return Result : access Univ_Enumeration is
        if Val is null then
            return null
        else
            for each [Lit => Rep] of Rep_Map loop
                if Val.Rep = Rep then
                    return Lit
                end if
            end loop
            return null
        end if
    end "to_univ"

    function From_Rep (Rep : access Rep_Type) return Enum_With_Rep is
        if Rep is null then
            return null
        else
            return (Rep => Rep)
        end if
    end From_Rep

    function To_Rep (Val : access Enum_With_Rep) return Rep_Type is
        if Val is null then
            return null
        else
            return Val.Rep
        end if
    end To_Rep

    -- Functions for Imageable
    function Image(Val : Enum_With_Rep) return Univ_String is
        Enum : constant : access Univ_Enumeration := [[Val]];
        if Enum not null then
            -- use enum image
            return Univ_Enumeration'Image(Enum);
        else
            -- use rep-type Image
            return Rep_Type'Image(Val.Rep)
        end if
    end Image

    function Value(Str : Univ_String) return Enum_With_Rep is
        if Str[1] = '#' then
            -- Presume is an enum
            return Univ_Enumeration'Value(Str)
        else
            -- Use rep-type Value
            return (Rep => Rep_Type'Value(Str))
        end if
    end Value

    function "[..]"() return Discrete_Ordered_Set<Enum_With_Rep> is
        return [for each Rep of Rep_Map => From_Rep(Rep)]
    end "[..]";

    function "=?"(Left, Right : Enum_With_Rep) return Ordering is
        return Left.Rep =? Right.Rep
    end "=?"

    function Hash(Val : Enum_With_Rep) return Univ_Integer is
        return Hash (Val.Rep)
    end Hash

    function Min(Left, Right : access Enum_With_Rep) return Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep > Left.Rep then
            return Left
        else
            return Right
        end if
    end Min

    function Max(Left, Right : access Enum_With_Rep) return Enum_With_Rep
    is
        if Left is null then
            return Right
        elsif Right is null or else Right.Rep < Left.Rep then
            return Left
        else
            return Right
        end if
    end Max

end A2X.Core.Enum_With_Rep

procedure A2X.Test.Test_Enum_With_Rep() is
    type Color is new Enum_With_Rep<Univ_Integer,
               [#red => 1, #green => 3, #blue => 5]>;

    type Day_Of_Week is new Enum_With_Rep<Modular<2**7>,
          [#Monday => 1<<1, #Tuesday => 1<<2, #Wednesday => 1<<3,
           #Thursday => 1<<4, #Friday => 1<<5,
            #Saturday => 1<<6, #Sunday => 1<<7]>

    for C in Color forward loop
        Println("Next color = " & C)
    end loop

    for C2 in Color reverse loop
        Println("Prev color = " & C2)
    end loop

    for D3 in Day_Of_Week loop
        Println("Random day of week = " & D3)
    end loop

    pragma Assert (#Monday in Day_Of_Week);

    for D4 in Day_Of_Week reverse loop
        Println("Prev day of week = " & D4)
    end loop

    for D5 in Day_Of_Week forward loop
        Println("To_Rep(" & D5 & ") = " & To_Rep(D5))
    end loop

    for I in 1..10 forward loop
        Println("Day_Of_Week.From_Rep(" & I & ") = " &
          Day_Of_Week.From_Rep(I))
    end loop

end A2X.Test.Test_Enum_With_Rep

package A2X.Core.Exception_Type is
    type Exception_Type is private
    function Create(Msg : Univ_String := "") return Exception_Type
    function Exception_Message (Occurrence : Exception_Type'Class)
      return Univ_String
    function Exception_Name (Occurrence : Exception_Type'Class)
      return Univ_String
      with Import, External_Name => #exception_name;
    procedure Raise_Occurrence (Occurrence : Exception_Type'Class)
      with Import, External_Name => #raise_exception_occurrence;
    function "[..]"() return Exception_Type'Class is (null);
end A2X.Core.Exception_Type

package body A2X.Core.Exception_Type is
    type Exception_Type is record
        Msg : Univ_String;
        Id : Univ_Integer;
    end record Exception_Type

    function Create(Msg : Univ_String := "") return Exception_Type is
        ((Msg => Msg, Id => 42));

    function Exception_Message (Occurrence : Exception_Type'Class)
      return Univ_String is
        ((Occurrence.Msg));

end A2X.Core.Exception_Type

package A2X.Core.Exceptions is
   Constraint_Error : exception;
   Program_Error : exception;
   Tasking_Error : exception;
end A2X.Core.Exceptions;

procedure A2X.Test.Test_Exceptions() is
   My_Exception : exception;
   
begin
   Put_Line ("About to raise My_Exception");

   raise My_Exception with "this is only a test"

   Put_Line ("After raise exception -- should NOT get here");

exception
   when Exceptions.Tasking_Error | Exceptions.Constraint_Error =>
      Put_Line ("Tasking_Error or C_E raised");
   when E : My_Exception =>
       Put_Line ("Got into handler for My_Exception");
       Put_Line ("Exception_Name: " & Exception_Name (E));
       Put_Line ("Exception_Message: " & Exception_Message (E));
   when E : others =>
       Put_Line ("Got into exception handler");
       Put_Line ("Exception_Name: " & Exception_Name (E));
       Put_Line ("Exception_Message: " & Exception_Message (E));
end A2X.Test.Test_Exceptions

package A2X.Core.Storage_Pool is
   type Storage_Pool is private;
   function Create() return Storage_Pool;
end A2X.Core.Storage_Pool;


generic
   type Desig_Type is new Assignable;
package A2X.Core.Access_Type is
   --  Access types designate Aliased objects
   --  Aliased objects include a self reference.
   type Access_Type is private;
   function "=?"(Left, Right : Access_Type) return Ordering;
   function Is_Null (Acc : access Access_Type) return Boolean;
   function Null_Value() return Access_Type;
   function Non_Null_Value (Index : Univ_Integer) return Access_Type;
   function Index (Acc : Access_Type) return Univ_Integer;
   function Allocate (Pool : in out Storage_Pool'Class; Val : Desig_Type)
     return Access_Type
     with Import, External_Name => #allocate_from_pool;
end A2X.Core.Access_Type;

generic
   type Desig_Type is new Assignable;
package A2X.Core.Access_All_Type is
   --  Access types designate Aliased objects
   --  Aliased objects include a self reference.
   type Access_All_Type is new Access_Type<Desig_Type>;
--    function "=?"(Left, Right : Access_All_Type) return Ordering;
--    function Is_Null (Acc : access Access_All_Type) return Boolean;
--    function Null_Value() return Access_All_Type;
--    function Non_Null_Value (Index : Univ_Integer) return Access_All_Type;
--    function Index (Acc : Access_All_Type) return Univ_Integer;
--    function Allocate (Pool : in out Storage_Pool'Class; Val : Desig_Type)
--      return Access_All_Type
--      with Import, External_Name => #allocate_from_pool;
end A2X.Core.Access_All_Type;

generic
   type Desig_Type is new Assignable;
   type Acc is new Access_Type <Desig_Type>;
package A2X.Core.Aliased_Obj is
   type Aliased_Obj is limited private;
   function Value (Ali : Aliased_Obj) return Desig_Type;
   procedure Set_Value (Ali : in out Aliased_Obj; New_Val : Desig_Type);
   function Deref (Acc) return ref var Aliased_Obj
     with Import, External_Name => #deref_var;
   function Deref_ : constant(Acc) return ref const Aliased_Obj
     with Import, External_Name => #deref_const;
   function Tick_Access (Ali : aliased in out Aliased_Obj) return Acc
     with Import, External_Name => #tick_access;
   function Create (Val : Desig_Type;
                Self : access Acc := Null_Value()) return Aliased_Obj;

end A2X.Core.Aliased_Obj;

package body A2X.Core.Storage_Pool is
   type Storage_Pool is record
      Handle : Aliased_Obj<Integer, Access_Type<Integer>> := Create(0);
   end record;
      
   function Create() return Storage_Pool is (());
end A2X.Core.Storage_Pool;

package body A2X.Core.Access_Type is
   type Access_Type is record
       Index : Univ_Integer := null;
   end record;

   subtype AO is Aliased_Obj<Desig_Type, Access_Type>;

   function "=?"(Left, Right : Access_Type) return Ordering is
     (Left.Index =? Right.Index);

   function Is_Null (Acc : access Access_Type) return Boolean
     is (Acc is null or else Acc.Index is null or else Acc.Index = 0);

   function Null_Value() return Access_Type is ((Index => null));

   function Non_Null_Value (Index : Univ_Integer) return Access_Type is
     ((Index => Index));

   function Index (Acc : Access_Type) return Univ_Integer is (Acc.Index);

end A2X.Core.Access_Type;

package body A2X.Core.Aliased_Obj is
   type Aliased_Obj is record
       Self : access Acc;
       Desig : Desig_Type;
   end record;
   Check_Digit_Multiplier : constant : Univ_Integer := 2**32;
   var The_Pool : Storage_Pool := Create();
   function Value (Ali : Aliased_Obj) return Desig_Type is
      return Ali.Desig;
   end Value;

   procedure Set_Value (Ali : in out Aliased_Obj; New_Val : Desig_Type) is
      Ali.Desig := New_Val;
   end Set_Value;

   function Create (Val : Desig_Type;
                Self : access Acc := Null_Value()) return Aliased_Obj is
      return (Self => Self, Desig => Val);
   end Create;
end A2X.Core.Aliased_Obj;

procedure A2X.Test.Test_Access() is
   Put_Line ("Running Test_Access");
   type Acc_Int is access all Integer;
   Pool : Storage_Pool := Create();
   X : Acc_Int := Null_Value();
   Y : Aliased_Obj<Integer, Acc_Int> :=
     Create (42, Self => Null_Value());
   Put_Line ("Value(Y) = " & Value(Y));
   Set_Value (Y, 35);
   Put_Line ("Value(Y) = " & Value(Y));
   X := Tick_Access(Y);
   Put_Line ("Y'Access = " & Hex_Image (Index(X)));
   var Z : Aliased_Obj<Integer, Acc_Int> := Deref_Const(X);
   Put_Line ("Value(Deref_Const(X)) = " & Value(Z));
   Set_Value(Z, 33);
   Put_Line ("Updating Deref_Const(X) to " & Value(Z));
   Put_Line ("Value(Y) now = " & Value(Y));
   subtype Ali is Aliased_Obj<Integer, Acc_Int>;
   ref Q => Ali'Deref(X)
   Set_Value (Q, 55);
   Put_Line ("Udating Deref(X) to " & Value(Q));
   Put_Line ("Value(Y) now = " & Value(Y));
   Put_Line ("Value(Deref_Const(X)) now = " & Value(Z));
   var A : Acc_Int := Allocate(Pool, 77);
   Put_Line ("new Integer'(77) = " & Hex_Image (Index(A)));
   ref AA => Ali'Deref(A);
   Put_Line ("Value(Deref(Allocate(Pool,77)) = " & Value(AA));
end A2X.Test.Test_Access;

generic
    type Component_Type is new Assignable;
    type Indexed_By is new Countable_Base;
package A2X.Core.Array_Type is
    type Array_Type is new Indexable<Component_Type, Indexed_By> with private
    function "indexing"(ref A : Array_Type; Index : Indexed_By)
      return ref Component_Type
    function Length(A : Array_Type) return Univ_Integer
    function "magnitude"(Array_Type) return Univ_Integer is Length
    function Length(A : Array_Type; Dimension : Univ_Integer) return Univ_Integer
    function "index_set"(A : Array_Type) return Countable_Set<Indexed_By>
    function Bounds(A : Array_Type) return Countable_Set<Indexed_By>
      is "index_set"
end A2X.Core.Array_Type

package body A2X.Core.Array_Type is
    type Array_Type is record
        Low_Bounds : Indexed_By;
        High_Bounds : Indexed_By;
        Data : Basic_Array <Component_Type>;
    end record Array_Type

    function "indexing"(ref A : Array_Type; Index : Indexed_By)
      return ref Component_Type is
        return A.Data [(Index - A.Low_Bounds) + 1]
    end "indexing"

    function Length(A : Array_Type) return Univ_Integer is
        --  TBD: Should be first dim len
        return (A.High_Bounds - A.Low_Bounds) + 1
    end Length

    function Length(A : Array_Type; Dimension : Univ_Integer) return Univ_Integer
    is
        --  TBD: should be based on specified dimension
        return Length (A)
    end Length

    function "index_set"(A : Array_Type) return Countable_Set<Indexed_By> is
        return A.Low_Bounds .. A.High_Bounds
    end "index_set"
end A2X.Core.Array_Type

package A2X.Core.IO is
  -- Locked versions of the Print, Println and Readln operations
    type IO is protected private;

    function Get_IO() return IO;  -- Get handle on IO subsystem

    procedure Println(IO : in out Core.IO; Univ_String);
    procedure Print(IO : in out Core.IO; Univ_String);
    procedure Print(IO : in out Core.IO; Univ_Character);
    procedure Print(IO : in out Core.IO; Univ_Integer);
    procedure Print(IO : in out Core.IO; Univ_Real);
    procedure Print(IO : in out Core.IO; Univ_Enumeration) ;

    function Readln(IO : in out Core.IO) return Univ_String;

    procedure Put_Line(IO : in out Core.IO; Univ_String) renames Println;
    procedure Put(IO : in out Core.IO; Univ_String) renames Print;
    procedure New_Line(IO : in out Core.IO) is (Put("\n"));
    procedure Put(IO : in out Core.IO; Univ_Character) renames Print;
    procedure Put(IO : in out Core.IO; Univ_Integer) renames Print;
    procedure Put(IO : in out Core.IO; Univ_Real) renames Print;
    procedure Put(IO : in out Core.IO; Univ_Enumeration) renames Print;

    function Get_Line(IO : in out Core.IO) return Univ_String is Readln
end A2X.Core.IO

package body A2X.Core.IO is
    type IO is protected null record

    function Get_IO() return IO is
        return ()
    end Get_IO

    procedure Println(IO : in out Core.IO; Univ_String) is
        Println (Univ_String)
    end Println

    procedure Print(IO : in out Core.IO; Univ_String) is
        Print (Univ_String)
    end Print

    procedure Print(IO : in out Core.IO; Univ_Character) is
        Print (Univ_Character)
    end Print

    procedure Print(IO : in out Core.IO; Univ_Integer) is
        Print (Univ_Integer)
    end Print

    procedure Print(IO : in out Core.IO; Univ_Real) is
        Print (Univ_Real)
    end Print

    procedure Print(IO : in out Core.IO; Univ_Enumeration) is
        Print (Univ_Enumeration)
    end Print

    function Readln(IO : in out Core.IO) return Univ_String is
        return Readln()
    end Readln

end A2X.Core.IO

procedure A2X.Test.Test_IO (X, Y : Univ_String; Z : Univ_Integer) is
    var IO := Core.IO.Get_IO()
    Pi : constant := 3.141592653589793
    True : constant Boolean := Boolean'(#True)

    IO.Print ("Pi = ")
    IO.Print (Pi)
    IO.Print (", True prints as ")
    IO.Print (True)
    IO.Print ("\n")
    IO.Print ("X = \"" & X & '"')
    IO.Print (", Y = \"" & Y & '"')
    IO.Println (", Z = " & Z )
    IO.Print ("Give me somethin: ")
    var Input := IO.Readln()
    IO.Println ("You gave me: \"" & Input & '"')

end A2X.Test.Test_IO
    
with A2X.Test.Test_IO

procedure Test_IO (X, Y : Univ_String; Z : Univ_Integer) is
    A2X.Test.Test_IO (X, Y, Z)
end Test_IO

package A2X.Core.Output_Stream is
  -- Output stream interface; all operations
  -- expressed in terms of Univ_String print and close
    type Output_Stream is abstract private

    abstract procedure Put(var Output_Stream; Univ_String)
    abstract procedure Close(var optional Output_Stream)
    abstract procedure Flush(var optional Output_Stream)

    procedure Print(var Output_Stream'Class; Univ_String)

    procedure Println(var Output_Stream'Class; Univ_String)

    procedure Print(var Output_Stream'Class; Univ_Character)
    procedure Print(var Output_Stream'Class; Univ_Integer)
    procedure Print(var Output_Stream'Class; Univ_Real)
    procedure Print(var Output_Stream'Class; Univ_Enumeration) 

    procedure Put_Line(var Output_Stream'Class; Univ_String) is Println

    procedure Put(var Output_Stream'Class; Univ_Character) is Print
    procedure New_Line(var Output_Stream'Class) is (Put(Output_Stream, "\n"))
    procedure Put(var Output_Stream'Class; Univ_Integer) is Print
    procedure Put(var Output_Stream'Class; Univ_Real) is Print
    procedure Put(var Output_Stream'Class; Univ_Enumeration) is Print
end A2X.Core.Output_Stream

package body A2X.Core.Output_Stream is
  -- Output stream interface; all operations
  -- expressed in terms of Univ_String print
    procedure Print(var Output_Stream'Class; Univ_String) is
        Output_Stream.Put(Univ_String)
    end Print

    procedure Println(var Output_Stream'Class; Univ_String) is
        Output_Stream.Put(Univ_String)
        Output_Stream.Put("\n")
    end Println

    procedure Print(var Output_Stream'Class; Univ_Character) is
        Output_Stream.Put(Image(Univ_Character))
    end Print

    procedure Print(var Output_Stream'Class; Univ_Integer) is
        Output_Stream.Put(Image(Univ_Integer))
    end Print

    procedure Print(var Output_Stream'Class; Univ_Real) is
        Output_Stream.Put(Image(Univ_Real))
    end Print

    procedure Print(var Output_Stream'Class; Univ_Enumeration) is
        Output_Stream.Put(Image(Univ_Enumeration))
    end Print

end A2X.Core.Output_Stream

package A2X.Core.Input_Stream is
    type Input_Stream is abstract private

    abstract function Get_Line(var Input_Stream) return Univ_String
    abstract procedure Close(var optional Input_Stream)

    function Readln(var Input_Stream'Class)
      return Univ_String
end A2X.Core.Input_Stream

package body A2X.Core.Input_Stream is
    function Readln(var Input_Stream'Class) return Univ_String is
         return Get_Line(Input_Stream)
    end Readln
end A2X.Core.Input_Stream

package A2X.Core.File_Output_Stream is
    type File_Output_Stream is new Output_Stream with private

    function Create(var IO; Name : Univ_String) return File_Output_Stream
      with Import, External_Name => #create_output_file;
    function Append(var IO; Name : Univ_String) return File_Output_Stream
      with Import, External_Name => #append_output_file;
    procedure Close(var optional File_Output_Stream)
      with Import, External_Name => #close_output_file;
    procedure Flush(var optional File_Output_Stream)
      with Import, External_Name => #flush_output_file;
    procedure Put(var File_Output_Stream; Univ_String)
      with Import, External_Name => #print_to_file;
end A2X.Core.File_Output_Stream

package body A2X.Core.File_Output_Stream is
    type File_Output_Stream is record
        Name : Univ_String
        Index : Univ_Integer
    end record File_Output_Stream

end A2X.Core.File_Output_Stream

package A2X.Core.File_Input_Stream is
    type File_Input_Stream is new Input_Stream with private

    function Open(IO : in out Core.IO; Name : Univ_String) return File_Input_Stream
      with Import, External_Name => #open_input_file;
    procedure Close(var optional File_Input_Stream)
      with Import, External_Name => #close_input_file;
    function Get_Line(var File_Input_Stream) return Univ_String
      with Import, External_Name => #read_from_file;
end A2X.Core.File_Input_Stream

package body A2X.Core.File_Input_Stream is
    type File_Input_Stream is record
        Name : Univ_String;
        Index : Univ_Integer
    end record File_Input_Stream
end A2X.Core.File_Input_Stream

procedure A2X.Test.Test_File (Name, X, Y : Univ_String; Z : Univ_Integer) is
    var IO := Core.IO.Get_IO()
    var File := File_Output_Stream.Create(IO, Name);
    Pi : constant := 3.14159265389793
    True : constant Boolean := Boolean'(#True)

    IO.Put_Line ("Writing to file: " & Name)

    File.Put ("Pi = ")
    Output_Stream.Put (File, Pi)
    File.Put (", True prints as ")
    Put (File, True)
    Put (File, "\n")
    File.Put ("X = \"" & X & '"')
    Put_Line (File, ", Y = \"" & Y & '"')
    IO.Put ("Give me somethin: ")
    var Inp := IO.Get_Line()
    IO.Put_Line ("You gave me: \"" & Inp & '"')
    File.Put_Line ("User input = \"" & Inp & '"')
    File.Close();

    var Inp_File := File_Input_Stream.Open(IO, Name)
    IO.Put_Line ("Contents of file " & Name)
    loop
        Line : constant := Inp_File.Get_Line()
        if Line is null then
            exit loop
        end if
        IO.Put_Line(Line)
    end loop

    IO.Put_Line("All done")

end A2X.Test.Test_File
