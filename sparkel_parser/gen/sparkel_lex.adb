
package body Sparkel_lex is

  --  Indicates whether outdenting should expect a perfect col-count match
  Col_Match_Expected : Boolean := True;

  Max_Depth : constant := 100;
  Indent_Stack : array(Positive range 1 .. Max_Depth) of Natural :=
    (others => 0);
     --  This indicates the 
  Bracketing_Token_Stack : array(Positive range 1 .. Max_Depth) of Token :=
    (others => Error);

  procedure ECHO_L(YYT : String := yytext) is
  --
  -- Local version of the  define string.
  -- 
  begin
     Echo_Token (YYT);
     --  We normally expect an exact match
     Col_Match_Expected := True;
  end ECHO_L;

  procedure Init is
  begin
     --  Reset indent level stack.
     Top := 0;
  end Init;

  function Create_Token(Text : String := yytext) return YYSType is
     Src_Pos : Source_Position := Cur_Source_Pos;
  begin
     --  Point to beginning of token
     Src_Pos.Col := Column_Number'Max (1, Src_Pos.Col - Text'Length + 1);
     --  TBD: "gcc" prefers column count rather than character count

     if Debug_Indent and then Expecting_Indent then
        Text_IO.Put (" [CT: indent off] ");
     end if;
     Expecting_Indent := False;

     --  Create a token for the parser.
     return (One_Token, Src_Pos, String_Lookup(Text));
  end Create_Token;
     
function YYLex return Token is
subtype short is integer range -32768..32767;
    yy_act : integer;
    yy_c : short;

-- returned upon end-of-file
YY_END_TOK : constant integer := 0;
YY_END_OF_BUFFER : constant := 197;
subtype yy_state_type is integer;
yy_current_state : yy_state_type;
INITIAL : constant := 0;
TICK : constant := 1;
CHARLIT : constant := 2;
AFTER_IMPLEMENTS : constant := 3;
OUTDENTING : constant := 4;
RESCANNING : constant := 5;
yy_accept : constant array(0..784) of short :=
    (   0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,  197,  195,  184,  194,  195,  195,  195,  170,
      150,  151,  160,  161,  162,  163,  164,  165,  175,  175,
      167,  168,  154,  172,  155,  171,  173,  173,  152,  153,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  156,  169,  158,    6,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  169,  149,
      195,    6,  191,  196,  191,  191,  191,  191,  191,  191,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,

      196,  196,  196,  196,  184,  194,    0,  117,    0,  182,
      182,    0,  174,  141,  121,  137,  148,  135,  183,  136,
      131,  148,  126,  138,    0,    0,  175,    0,    0,    0,
        0,    0,  166,  148,    0,  122,    0,  120,  119,  125,
        0,  159,  116,  130,  115,  118,    0,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,   65,  173,   68,   70,  173,  173,  173,  173,  173,
      173,  173,   80,   81,   83,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,

      173,  173,  173,  157,  140,  134,    6,    0,    0,    0,
        0,    0,    0,    0,  173,  173,  173,  173,  173,  173,
      173,  173,  173,   68,  173,    6,  173,  173,  173,  173,
      173,  134,    0,    0,    6,    0,  190,    0,    0,    0,
        0,  189,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,   22,    0,    0,    0,    0,    0,  133,
      174,  139,  183,  129,    0,  176,  180,    0,  175,  179,
        0,  128,  146,  123,  124,  142,  132,  147,  173,   23,
      173,  173,   27,   28,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,   52,  173,

      173,  173,  173,   59,  173,  173,  173,  173,  173,  173,
      173,  173,  173,   75,   77,   78,  173,  173,  144,  173,
       85,  173,  173,  173,  173,  173,  173,  173,  173,  173,
       97,   98,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  109,  110,  173,  173,  173,  114,    4,    0,    0,
        0,    0,    0,    0,   23,  173,  173,  173,    6,  173,
      173,  173,  173,  173,  173,   77,  173,  173,  173,    6,
      173,    3,  181,    0,    0,    0,    0,    0,    0,    0,
        0,    0,   12,    0,    0,    0,    0,    0,    0,   76,
        0,    0,    0,   19,    0,  177,    0,    0,    0,  176,

        0,    0,  180,    0,  175,    0,  179,    0,    0,  127,
      173,  173,  173,  173,  143,  173,  173,  173,  173,   34,
       35,  173,  173,  173,  173,  173,  173,  173,   45,   48,
       46,  173,  173,  173,   55,  173,  173,  173,   61,  173,
      173,  173,  173,  173,  173,  173,  173,   74,   79,  173,
      173,  173,  173,  173,  173,   90,  173,  173,  173,  173,
      173,  173,  173,  173,  102,  173,  173,  106,  107,  173,
      111,  173,  113,  145,    0,    0,    0,    1,    0,  173,
      173,  173,  173,  173,  173,    6,  173,  173,  173,  173,
        6,  173,  106,    6,    0,    0,    0,  187,    0,    0,

        0,    0,    0,    0,    0,   14,    0,    0,    0,    0,
       16,    0,  105,   18,    0,    0,    0,  176,   37,  173,
      173,  173,   29,  173,   31,   33,   36,  173,   39,  173,
      173,   43,  173,    0,  173,   50,   51,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,   94,
       95,  173,  173,  173,  173,  173,  173,  108,  112,    0,
        0,    0,  173,   31,    6,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,    5,    0,    0,  185,    0,
       32,    8,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,  177,  178,    0,    0,  176,    0,  173,
       25,  173,   30,  173,  173,  173,  173,   44,    0,   47,
      173,  173,  173,  173,  173,  173,   64,  173,   67,  173,
       71,  173,   73,  173,   84,  173,  173,   88,  173,  173,
      173,   93,   96,  173,  100,  173,  173,  104,    0,    0,
      173,  173,  173,  173,  173,  173,    6,  173,  173,  173,
      173,  188,    0,    0,    0,    0,    0,    0,    0,   17,
        0,    0,    0,    0,  177,    0,    0,  173,   26,  173,
      173,  173,   42,   49,  173,   57,   58,   60,  173,   63,
      173,  173,   72,  173,   86,  173,   89,  173,  173,   99,

      101,  103,    0,    0,  173,  173,  173,   57,  173,    6,
      173,    6,  173,  173,    0,    0,    0,    0,   56,    0,
       10,    0,   21,    0,    0,    0,  178,   24,  173,   40,
       41,  173,   62,  173,  173,   82,   87,  173,  173,    0,
        0,    6,  173,  173,    2,    6,  173,  173,  173,    0,
        7,    0,    0,   13,    0,    0,    0,  178,    0,  173,
       54,  173,   69,   91,   92,    0,  173,   54,    6,    6,
        6,    0,    0,   53,   20,   15,   11,   38,   66,    6,
        0,    9,  186,    0
    ) ;

yy_ec : constant array(ASCII.NUL..Character'Last) of short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    5,    6,    7,    1,    1,    8,    9,   10,
       11,   12,   13,   14,   15,   16,   17,   18,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   20,   21,   22,
       23,   24,   25,    1,   26,   27,   28,   26,   29,   26,
       30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
       30,   30,   30,   30,   30,   30,   30,   31,   30,   30,
       32,   33,   34,    1,   35,    1,   36,   37,   38,   39,

       40,   41,   42,   43,   44,   30,   45,   46,   47,   48,
       49,   50,   51,   52,   53,   54,   55,   56,   57,   58,
       59,   30,   60,   61,   62,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    ) ;

yy_meta : constant array(0..62) of short :=
    (   0,
        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
        1,    4,    1,    1,    1,    5,    1,    6,    6,    1,
        1,    1,    4,    1,    1,    7,    7,    7,    7,    8,
        8,    1,    1,    1,    9,    7,    7,    7,    7,    7,
        7,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    8,    8,    1,
        1,    1
    ) ;

yy_base : constant array(0..801) of short :=
    (   0,
        0,   61, 1057, 1056, 1055, 1054, 1053,   62,   69,   77,
        0,  103, 1061, 1067,   71, 1067, 1037,   79,    0, 1036,
     1067, 1067,   55,   67, 1067,   53,   75, 1035,  158,  143,
      133, 1067,  147,   69,   46, 1067,    0, 1011, 1067, 1067,
      144,   80,  155,   56,  164,   78,   88,  158,  131, 1007,
      139,  173,   43, 1000,   68,  100,  177,   71, 1018,  159,
     1004, 1028,  163, 1067,  235,  196,  186,  194,  171,  166,
      205,  205,  214,  216,  132,  219,  208,  216,  241, 1067,
     1018,  263, 1067, 1067,    0, 1010, 1002, 1008, 1004,  985,
     1008, 1004,  227,   84,  988, 1002,  233, 1001,  990,  238,

      996,  985,  993,  975,  282, 1067, 1020, 1067,  285, 1067,
     1028, 1030,    0, 1067, 1009, 1067, 1067, 1067,    0, 1067,
     1067, 1015, 1008, 1067,    0,  274,  287,  280,  294,    0,
      282,  317, 1067, 1009, 1013, 1067, 1011, 1003,  287, 1067,
     1002, 1067, 1000, 1067, 1067, 1067, 1000,    0,  986,  968,
      982,  271,  980,  966,  964,  974,  966,  975,  960,  976,
      963,  249,  968,  971,  270,  969,  286,  955,  958,  957,
      955,    0,  953,  948,    0,  954,  953,  288,  960,  941,
      943,  950,    0,  941,  971,  950,  938,  287,  297,  951,
      287,  304,  943,  952,  946,  947,  936,  931,  944,  931,

      294,  928,  929, 1067, 1067, 1067,    0,    0,  940,  921,
      925,  937,  933,  914,  921,  931,  936,  923,  931,  305,
      921,  920,  917,  912,  908,  910,  309,  318,  923,  922,
      907,  361,  951,  956,    0,  909, 1067,  915,  906,  898,
      914, 1067,  900,  910,  915,  902,  910,  116,  900,  899,
      896,  891,  887, 1067,  905,  893,  901,  900,  885, 1067,
        0, 1067,    0, 1067,  337,  350,  338,  310,  352,  903,
      934,  914, 1067, 1067, 1067, 1067, 1067, 1067,  882,  880,
      893,  896,    0,  908,  894,  889,  884,  889,  867,  885,
      871,  328,  877,  868,  877,  877,  878,  334,  874,  877,

      862,  866,  874,  856,  874,  871,  873,  331,  869,  871,
      863,  861,  855,    0,    0,    0,  858,  859, 1067,  862,
        0,  856,  864,  857,  842,  337,  842,  843,  853,  845,
        0,    0,  857,  837,  851,  850,  835,  846,  839,  846,
      841,    0,    0,  836,  837,  839,  858, 1067,  838,  338,
      390,  822,  838,  393,  823,  832,  822,  345,  830,  833,
      823,  833,  830,  340,  829,  398,  823,  365,  819,    0,
      823, 1067, 1067,  813,  820,  817,  402,  814,  807,  816,
      806,  820, 1067,  817,  807,  817,  814,  804,  812, 1067,
      806,  369,  802, 1067,  806,  380,    0,  401,  405,  395,

      413,  392,  415,  397,  419,  423,  813,  812,  843, 1067,
      792,  792,  790,  789, 1067,  782,  788,  791,  793,    0,
        0,  784,  781,  781,  790,  797,  796,  777,    0,    0,
      304,  789,  788,  778,    0,  775,  778,  789,  770,  771,
      786,  781,  768,  767,  779,  763,  776,    0,    0,  766,
      762,  777,  766,  764,  774,  769,  768,  767,  766,  765,
      752,  756,  750,  749,    0,  741,  759,    0,    0,  752,
        0,  757,    0, 1067,  752,  755,  745, 1067,  745,  740,
      743,  737,  734,  738,  735,  732,  733,  732,  731,  746,
      741,  740,  441,    0,  444,  731,  738, 1067,  449,  725,

      728,  722,  719,  723,  720,  717,  718,  717,  716,  731,
      726,  725, 1067, 1067,  442,  432,  440,  444,    0,  728,
      710,  722,    0,  707,    0,    0,    0,  708,  723,  710,
      705,    0,  703,  711,  713,    0,    0,  699,  698,  712,
      698,  705,  704,  701,  699,  691,  703,  707,  702,  702,
      692,  686,  696,  691,  700,  681,  695,  695,  693,    0,
        0,  692,  690,  681,  675,  677,  687,    0,    0,  677,
      674,  671,  686,  462,    0,  669,  666,  665,  674,  673,
      662,  674,  672,  674,  674, 1067,  466,  664, 1067,  674,
     1067, 1067,  657,  654,  653,  662,  661,  650,  662,  660,

      662,  662,  453,  455,  389,  442,  449,  457,  462,  661,
        0,  659,    0,  645,  648,  640,  654,    0,  652,    0,
      648,  638,  637,  650,  639,  649,    0,  646,    0,  649,
        0,  645,    0,  647,    0,  642,  641,    0,  640,  624,
      624,    0,    0,  624,    0,  636,  635,    0,  620,  619,
      634,  619,  626,  616,  619,  629,    0,  630,  625,  609,
      609, 1067,  622,  623,  608,  615,  605,  608,  618, 1067,
      619,  614,  598,  598,  464,  467,  476,  597,    0,  610,
      595,  608,    0, 1067,  598,    0,    0,    0,  598,    0,
      597,  606,    0,  597,    0,  596,    0,  589,  600,    0,

        0,    0,  595,  585,  583,  596,  586,  494,  586,    0,
      595,    0,  580,  591,  582,  575,  587,  575, 1067,  575,
     1067,  571, 1067,  553,  561,  469,  482,    0,  546,    0,
        0,  531,    0,  514,  481,    0,    0,  480,  480,  469,
      500,    0,  468,  467, 1067,    0,  453,  438,  388,  371,
     1067,  374,  336, 1067,  310,  242,  238,  487,  489,  187,
        0,  178,    0,    0,    0,  170,  119,  507,    0,    0,
        0,   54,   30, 1067, 1067, 1067, 1067,    0,    0,    0,
      510, 1067, 1067, 1067,  522,  531,  540,  543,  546,  555,
      564,  568,  577,  581,  583,  590,  597,  601,  610,  614,

      619
    ) ;

yy_def : constant array(0..801) of short :=
    (   0,
      784,    1,    1,    2,    1,    2,    1,    2,  785,  785,
      786,  786,  784,  784,  784,  784,  784,  787,  788,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  789,  789,  784,  784,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  784,  784,  784,  784,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  784,  784,
      790,   65,  784,  784,  791,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,

      784,  784,  784,  784,  784,  784,  784,  784,  787,  784,
      784,  787,  792,  784,  784,  784,  784,  784,  793,  784,
      784,  784,  784,  784,  794,  784,  784,  784,  784,  795,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,

      789,  789,  789,  784,  784,  784,   65,  796,  784,  784,
      784,  784,  784,  784,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  784,  784,  790,   82,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      792,  784,  793,  784,  797,  784,  784,  784,  784,  798,
      799,  784,  784,  784,  784,  784,  784,  784,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,

      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  784,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  784,  784,  784,
      784,  784,  784,  784,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  800,  797,  797,  784,

      784,  784,  784,  784,  784,  784,  798,  798,  799,  784,
      789,  789,  789,  789,  784,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  784,  784,  784,  784,  784,  784,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  784,  784,  784,  784,  784,  784,

      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  801,  784,  784,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  784,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  784,
      784,  784,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,

      784,  784,  784,  784,  784,  801,  801,  784,  784,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  784,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  784,  784,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,
      789,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  789,  789,  789,
      789,  789,  789,  784,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  789,

      789,  789,  784,  784,  789,  789,  789,  789,  789,  789,
      789,  789,  789,  789,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  789,  789,  789,
      789,  789,  789,  789,  789,  789,  789,  789,  789,  784,
      784,  789,  789,  789,  784,  789,  789,  789,  789,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  789,
      789,  789,  789,  789,  789,  784,  789,  789,  789,  789,
      789,  784,  784,  784,  784,  784,  784,  789,  789,  789,
      784,  784,  784,    0,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,

      784
    ) ;

yy_nxt : constant array(0..1129) of short :=
    (   0,
       14,   15,   16,   15,   17,   18,   19,   20,   14,   21,
       22,   23,   24,   25,   26,   27,   28,   29,   30,   31,
       32,   33,   34,   35,   36,   37,   37,   38,   37,   37,
       37,   39,   14,   40,   14,   41,   42,   43,   44,   45,
       46,   47,   37,   48,   37,   49,   50,   51,   52,   53,
       54,   55,   56,   57,   58,   59,   60,   61,   37,   62,
       63,   64,   65,   82,   65,   82,  115,  119,  146,  147,
       81,   84,  105,  106,  105,  120,  121,  116,  188,   84,
       85,  110,  117,  782,  111,  107,  117,  122,   85,  118,
      123,  143,  144,  145,  189,  162,   66,   67,   68,  163,

       69,   70,   71,  191,   72,   86,  781,  192,   73,   74,
       75,  112,   87,   86,   76,   77,   88,   78,  198,  156,
       87,   79,   89,  199,   88,  157,  168,  170,  158,   90,
       89,  247,  169,  171,  132,  133,  132,   90,   91,   92,
       93,  248,   94,   95,   96,  134,   97,  135,  193,  125,
       98,   99,  100,  384,  194,  136,  101,  102,  126,  103,
      127,  127,  137,  104,  125,  385,  176,  227,  138,  139,
      140,  129,  780,  126,  177,  127,  127,  131,  180,  178,
      150,  151,  129,  228,  128,  205,  129,  181,  130,  152,
      159,  153,  131,  182,  128,  154,  155,  129,  172,  164,

      160,  201,  202,  161,  173,  174,  164,  141,  142,  165,
      175,  166,  195,  183,  168,  130,  165,  354,  219,  196,
      221,  167,  184,  206,  185,  216,  186,  187,  220,  159,
      779,  157,  215,  151,  158,  197,  207,  106,  207,  217,
      778,  152,  218,  153,  222,  172,  208,  154,  155,  107,
      171,  223,  224,  225,  195,  198,  183,  175,  201,  231,
      230,  229,  181,  205,  235,  226,  235,  185,  182,  186,
      187,  209,  245,  255,  210,  246,  777,  197,  211,  251,
      252,  776,  212,  105,  106,  105,  293,  110,  213,  256,
      111,  266,  266,  125,  294,  214,  107,  267,  267,  127,

      127,  232,  126,  236,  127,  127,  268,  534,  268,  274,
      275,  269,  269,  297,  282,  129,  283,  112,  132,  133,
      132,  131,  298,  300,  322,  312,  129,  269,  269,  301,
      328,  135,  324,  344,  329,  302,  313,  345,  323,  303,
      325,  330,  360,  396,  331,  326,  367,  535,  301,  775,
      332,  333,  397,  324,  361,  403,  403,  334,  303,  335,
      323,  325,  372,  372,  372,  423,  368,  400,  400,  405,
      405,  399,  404,  431,  456,  476,  442,  432,  401,  443,
      424,  425,  483,  774,  402,  442,  406,  477,  488,  401,
      457,  478,  478,  478,  372,  372,  372,  424,  425,  372,

      372,  372,  491,  498,  498,  498,  511,  396,  515,  400,
      400,  784,  400,  400,  403,  403,  397,  677,  492,  515,
      784,  773,  512,  401,  772,  517,  771,  517,  677,  402,
      518,  518,  403,  403,  401,  399,  405,  405,  605,  784,
      405,  405,  372,  372,  372,  586,  586,  586,  605,  404,
      589,  589,  589,  406,  603,  784,  603,  518,  518,  604,
      604,  608,  608,  372,  372,  372,  607,  662,  662,  662,
      604,  604,  675,  675,  608,  608,  607,  770,  609,  608,
      608,  675,  675,  784,  675,  675,  727,  727,  726,  676,
      726,  609,  769,  727,  727,  745,  745,  745,  676,  758,

      758,  745,  745,  745,  758,  758,  758,  758,  372,  372,
      372,  783,  783,  783,  768,  767,  759,  766,  765,  764,
      763,  759,   83,   83,   83,   83,   83,   83,   83,   83,
       83,   84,   84,   84,   84,   84,   84,   84,   84,   84,
      109,  109,  109,  109,  109,  109,  109,  109,  109,  113,
      113,  148,  148,  148,  148,  233,  233,  233,  233,  233,
      233,  233,  233,  233,  237,  237,  237,  762,  237,  237,
      237,  237,  237,  261,  261,  261,  261,  263,  761,  263,
      263,  263,  263,  263,  263,  263,  265,  265,  270,  270,
      348,  348,  348,  760,  348,  348,  348,  348,  348,  398,

      757,  398,  398,  398,  756,  398,  407,  407,  755,  407,
      409,  409,  409,  409,  409,  409,  409,  409,  409,  516,
      516,  606,  754,  753,  606,  606,  752,  606,  751,  750,
      749,  748,  747,  746,  744,  743,  742,  741,  740,  739,
      738,  737,  736,  735,  734,  733,  732,  731,  730,  729,
      728,  725,  724,  723,  722,  721,  720,  719,  718,  717,
      716,  715,  714,  713,  712,  711,  710,  709,  708,  707,
      706,  705,  704,  703,  702,  701,  700,  699,  698,  697,
      696,  695,  694,  693,  692,  691,  690,  689,  688,  687,
      686,  685,  684,  683,  682,  681,  680,  679,  678,  674,

      673,  672,  671,  670,  669,  668,  667,  666,  665,  664,
      663,  661,  660,  659,  658,  657,  656,  655,  654,  653,
      652,  651,  650,  649,  354,  648,  647,  646,  645,  644,
      643,  642,  641,  640,  639,  638,  637,  636,  635,  634,
      633,  632,  631,  630,  629,  628,  627,  626,  625,  624,
      623,  622,  621,  620,  619,  618,  617,  616,  615,  614,
      613,  612,  611,  610,  602,  601,  600,  599,  598,  597,
      596,  595,  594,  593,  592,  591,  590,  588,  587,  585,
      584,  583,  582,  581,  580,  579,  578,  577,  576,  575,
      574,  573,  354,  572,  571,  570,  569,  568,  567,  566,

      565,  564,  563,  562,  561,  560,  559,  558,  557,  556,
      555,  554,  553,  552,  551,  550,  549,  548,  547,  546,
      545,  544,  543,  542,  541,  540,  539,  538,  537,  536,
      533,  532,  531,  530,  529,  528,  527,  526,  525,  524,
      523,  522,  521,  520,  519,  133,  784,  408,  514,  513,
      510,  509,  508,  507,  506,  505,  504,  503,  502,  501,
      500,  499,  497,  496,  495,  494,  493,  490,  489,  487,
      486,  485,  484,  433,  482,  481,  480,  479,  354,  475,
      474,  473,  472,  471,  470,  469,  468,  467,  466,  465,
      464,  463,  462,  461,  460,  459,  458,  455,  454,  453,

      452,  451,  450,  449,  448,  447,  446,  445,  444,  441,
      440,  439,  438,  437,  436,  435,  434,  433,  430,  429,
      428,  427,  426,  422,  421,  420,  419,  418,  417,  416,
      415,  414,  413,  412,  411,  410,  133,  408,  395,  394,
      393,  392,  391,  390,  389,  388,  387,  386,  383,  382,
      381,  380,  379,  378,  377,  376,  375,  374,  784,  373,
      371,  370,  369,  318,  366,  365,  364,  363,  362,  359,
      358,  357,  356,  355,  354,  353,  352,  351,  350,  349,
      347,  346,  343,  342,  341,  340,  339,  338,  337,  336,
      327,  321,  320,  319,  318,  317,  316,  315,  314,  311,

      310,  309,  308,  307,  306,  305,  304,  299,  296,  295,
      292,  291,  290,  289,  288,  287,  286,  285,  284,  281,
      280,  279,  278,  277,  276,  273,  272,  271,  117,  264,
      117,  262,  784,  109,  119,  260,  259,  258,  257,  254,
      253,  250,  249,  244,  243,  242,  241,  240,  239,  238,
      234,  204,  203,  200,  190,  179,  149,  124,  114,  108,
      784,   81,   81,   81,   80,   80,   13,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,

      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784
    ) ;

yy_chk : constant array(0..1129) of short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    2,    8,    2,    8,   23,   26,   35,   35,
        8,    9,   15,   15,   15,   26,   26,   23,   53,   10,
        9,   18,   24,  773,   18,   15,   24,   27,   10,   24,
       27,   34,   34,   34,   53,   44,    2,    2,    2,   44,

        2,    2,    2,   55,    2,    9,  772,   55,    2,    2,
        2,   18,    9,   10,    2,    2,    9,    2,   58,   42,
       10,    2,    9,   58,   10,   42,   46,   47,   42,    9,
       10,   94,   46,   47,   31,   31,   31,   10,   12,   12,
       12,   94,   12,   12,   12,   31,   12,   31,   56,   30,
       12,   12,   12,  248,   56,   31,   12,   12,   30,   12,
       30,   30,   33,   12,   29,  248,   49,   75,   33,   33,
       33,   30,  767,   29,   49,   29,   29,   30,   51,   49,
       41,   41,   30,   75,   29,   63,   29,   51,   29,   41,
       43,   41,   29,   51,   29,   41,   41,   29,   48,   45,

       43,   60,   60,   43,   48,   48,   69,   33,   33,   45,
       48,   45,   57,   52,   70,   29,   69,  766,   69,   57,
       70,   45,   52,   63,   52,   67,   52,   52,   69,   68,
      762,   67,   66,   66,   67,   57,   65,   65,   65,   68,
      760,   66,   68,   66,   71,   72,   65,   66,   66,   65,
       71,   72,   72,   73,   76,   77,   74,   72,   78,   78,
       77,   76,   73,   79,   82,   74,   82,   74,   73,   74,
       74,   65,   93,  100,   65,   93,  757,   76,   65,   97,
       97,  756,   65,  105,  105,  105,  162,  109,   65,  100,
      109,  126,  126,  127,  162,   65,  105,  128,  128,  131,

      131,   79,  127,   82,  127,  127,  129,  431,  129,  139,
      139,  129,  129,  165,  152,  127,  152,  109,  132,  132,
      132,  127,  165,  167,  188,  178,  127,  268,  268,  167,
      191,  132,  189,  201,  191,  167,  178,  201,  188,  167,
      189,  192,  220,  265,  192,  189,  227,  431,  220,  755,
      192,  192,  265,  228,  220,  267,  267,  192,  220,  192,
      227,  228,  232,  232,  232,  292,  228,  266,  266,  269,
      269,  265,  267,  298,  326,  350,  308,  298,  266,  308,
      292,  292,  358,  753,  266,  364,  269,  350,  364,  266,
      326,  351,  351,  351,  354,  354,  354,  358,  358,  366,

      366,  366,  368,  377,  377,  377,  392,  398,  396,  402,
      402,  399,  400,  400,  404,  404,  398,  605,  368,  396,
      399,  752,  392,  400,  750,  401,  749,  401,  605,  400,
      401,  401,  403,  403,  400,  398,  405,  405,  516,  399,
      406,  406,  493,  493,  493,  495,  495,  495,  606,  403,
      499,  499,  499,  405,  515,  607,  515,  517,  517,  515,
      515,  518,  518,  574,  574,  574,  516,  587,  587,  587,
      603,  603,  604,  604,  608,  608,  606,  748,  518,  609,
      609,  675,  675,  607,  676,  676,  726,  726,  677,  604,
      677,  608,  747,  677,  677,  708,  708,  708,  675,  727,

      727,  741,  741,  741,  758,  758,  759,  759,  768,  768,
      768,  781,  781,  781,  744,  743,  727,  740,  739,  738,
      735,  758,  785,  785,  785,  785,  785,  785,  785,  785,
      785,  786,  786,  786,  786,  786,  786,  786,  786,  786,
      787,  787,  787,  787,  787,  787,  787,  787,  787,  788,
      788,  789,  789,  789,  789,  790,  790,  790,  790,  790,
      790,  790,  790,  790,  791,  791,  791,  734,  791,  791,
      791,  791,  791,  792,  792,  792,  792,  793,  732,  793,
      793,  793,  793,  793,  793,  793,  794,  794,  795,  795,
      796,  796,  796,  729,  796,  796,  796,  796,  796,  797,

      725,  797,  797,  797,  724,  797,  798,  798,  722,  798,
      799,  799,  799,  799,  799,  799,  799,  799,  799,  800,
      800,  801,  720,  718,  801,  801,  717,  801,  716,  715,
      714,  713,  711,  709,  707,  706,  705,  704,  703,  699,
      698,  696,  694,  692,  691,  689,  685,  682,  681,  680,
      678,  674,  673,  672,  671,  669,  668,  667,  666,  665,
      664,  663,  661,  660,  659,  658,  656,  655,  654,  653,
      652,  651,  650,  649,  647,  646,  644,  641,  640,  639,
      637,  636,  634,  632,  630,  628,  626,  625,  624,  623,
      622,  621,  619,  617,  616,  615,  614,  612,  610,  602,

      601,  600,  599,  598,  597,  596,  595,  594,  593,  590,
      588,  585,  584,  583,  582,  581,  580,  579,  578,  577,
      576,  573,  572,  571,  570,  567,  566,  565,  564,  563,
      562,  559,  558,  557,  556,  555,  554,  553,  552,  551,
      550,  549,  548,  547,  546,  545,  544,  543,  542,  541,
      540,  539,  538,  535,  534,  533,  531,  530,  529,  528,
      524,  522,  521,  520,  512,  511,  510,  509,  508,  507,
      506,  505,  504,  503,  502,  501,  500,  497,  496,  492,
      491,  490,  489,  488,  487,  486,  485,  484,  483,  482,
      481,  480,  479,  477,  476,  475,  472,  470,  467,  466,

      464,  463,  462,  461,  460,  459,  458,  457,  456,  455,
      454,  453,  452,  451,  450,  447,  446,  445,  444,  443,
      442,  441,  440,  439,  438,  437,  436,  434,  433,  432,
      428,  427,  426,  425,  424,  423,  422,  419,  418,  417,
      416,  414,  413,  412,  411,  409,  408,  407,  395,  393,
      391,  389,  388,  387,  386,  385,  384,  382,  381,  380,
      379,  378,  376,  375,  374,  371,  369,  367,  365,  363,
      362,  361,  360,  359,  357,  356,  355,  353,  352,  349,
      347,  346,  345,  344,  341,  340,  339,  338,  337,  336,
      335,  334,  333,  330,  329,  328,  327,  325,  324,  323,

      322,  320,  318,  317,  313,  312,  311,  310,  309,  307,
      306,  305,  304,  303,  302,  301,  300,  299,  297,  296,
      295,  294,  293,  291,  290,  289,  288,  287,  286,  285,
      284,  282,  281,  280,  279,  272,  271,  270,  259,  258,
      257,  256,  255,  253,  252,  251,  250,  249,  247,  246,
      245,  244,  243,  241,  240,  239,  238,  236,  234,  233,
      231,  230,  229,  226,  225,  224,  223,  222,  221,  219,
      218,  217,  216,  215,  214,  213,  212,  211,  210,  209,
      203,  202,  200,  199,  198,  197,  196,  195,  194,  193,
      190,  187,  186,  185,  184,  182,  181,  180,  179,  177,

      176,  174,  173,  171,  170,  169,  168,  166,  164,  163,
      161,  160,  159,  158,  157,  156,  155,  154,  153,  151,
      150,  149,  147,  143,  141,  138,  137,  135,  134,  123,
      122,  115,  112,  111,  107,  104,  103,  102,  101,   99,
       98,   96,   95,   92,   91,   90,   89,   88,   87,   86,
       81,   62,   61,   59,   54,   50,   38,   28,   20,   17,
       13,    7,    6,    5,    4,    3,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,

      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784,  784,
      784,  784,  784,  784,  784,  784,  784,  784,  784
    ) ;


-- copy whatever the last rule matched to the standard output

procedure ECHO is
begin
   if (text_io.is_open(user_output_file)) then
     text_io.put( user_output_file, yytext );
   else
     text_io.put( yytext );
   end if;
end ECHO;

-- enter a start condition.
-- Using procedure requires a () after the ENTER, but makes everything
-- much neater.

procedure ENTER( state : integer ) is
begin
     yy_start := 1 + 2 * state;
end ENTER;

-- action number for EOF rule of a given start state
function YY_STATE_EOF(state : integer) return integer is
begin
     return YY_END_OF_BUFFER + state + 1;
end YY_STATE_EOF;

-- return all but the first 'n' matched characters back to the input stream
procedure yyless(n : integer) is
begin
        yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
        yy_cp := yy_bp + n;
        yy_c_buf_p := yy_cp;
        YY_DO_BEFORE_ACTION; -- set up yytext again
end yyless;

-- redefine this if you have something you want each time.
procedure YY_USER_ACTION is
begin
        null;
end;

-- yy_get_previous_state - get the state just before the EOB char was reached

function yy_get_previous_state return yy_state_type is
    yy_current_state : yy_state_type;
    yy_c : short;
    yy_bp : integer := yytext_ptr;
begin
    yy_current_state := yy_start;
    if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	yy_current_state := yy_current_state + 1;
    end if;

    for yy_cp in yytext_ptr..yy_c_buf_p - 1 loop
	yy_c := yy_ec(yy_ch_buf(yy_cp));
	if ( yy_accept(yy_current_state) /= 0 ) then
	    yy_last_accepting_state := yy_current_state;
	    yy_last_accepting_cpos := yy_cp;
	end if;
	while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
	    yy_current_state := yy_def(yy_current_state);
	    if ( yy_current_state >= 785 ) then
		yy_c := yy_meta(yy_c);
	    end if;
	end loop;
	yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
    end loop;

    return yy_current_state;
end yy_get_previous_state;

procedure yyrestart( input_file : file_type ) is
begin
   open_input(text_io.name(input_file));
end yyrestart;

begin -- of YYLex
<<new_file>>
        -- this is where we enter upon encountering an end-of-file and
        -- yywrap() indicating that we should continue processing

    if ( yy_init ) then
        if ( yy_start = 0 ) then
            yy_start := 1;      -- first start state
        end if;

        -- we put in the '\n' and start reading from [1] so that an
        -- initial match-at-newline will be true.

        yy_ch_buf(0) := ASCII.LF;
        yy_n_chars := 1;

        -- we always need two end-of-buffer characters.  The first causes
        -- a transition to the end-of-buffer state.  The second causes
        -- a jam in that state.

        yy_ch_buf(yy_n_chars) := YY_END_OF_BUFFER_CHAR;
        yy_ch_buf(yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

        yy_eof_has_been_seen := false;

        yytext_ptr := 1;
        yy_c_buf_p := yytext_ptr;
        yy_hold_char := yy_ch_buf(yy_c_buf_p);
        yy_init := false;
    end if; -- yy_init

    loop                -- loops until end-of-file is reached


        yy_cp := yy_c_buf_p;

        -- support of yytext
        yy_ch_buf(yy_cp) := yy_hold_char;

        -- yy_bp points to the position in yy_ch_buf of the start of the
        -- current run.
	yy_bp := yy_cp;
	yy_current_state := yy_start;
	if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	    yy_current_state := yy_current_state + 1;
	end if;
	loop
		yy_c := yy_ec(yy_ch_buf(yy_cp));
		if ( yy_accept(yy_current_state) /= 0 ) then
		    yy_last_accepting_state := yy_current_state;
		    yy_last_accepting_cpos := yy_cp;
		end if;
		while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
		    yy_current_state := yy_def(yy_current_state);
		    if ( yy_current_state >= 785 ) then
			yy_c := yy_meta(yy_c);
		    end if;
		end loop;
		yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
	    yy_cp := yy_cp + 1;
if ( yy_current_state = 784 ) then
    exit;
end if;
	end loop;
	yy_cp := yy_last_accepting_cpos;
	yy_current_state := yy_last_accepting_state;

<<next_action>>
	    yy_act := yy_accept(yy_current_state);
            YY_DO_BEFORE_ACTION;
            YY_USER_ACTION;

        if aflex_debug then  -- output acceptance info. for (-d) debug mode
            text_io.put( Standard_Error, "--accepting rule #" );
            text_io.put( Standard_Error, INTEGER'IMAGE(yy_act) );
            text_io.put_line( Standard_Error, "(""" & yytext & """)");
        end if;


<<do_action>>   -- this label is used only to access EOF actions
            case yy_act is
		when 0 => -- must backtrack
		-- undo the effects of YY_DO_BEFORE_ACTION
		yy_ch_buf(yy_cp) := yy_hold_char;
		yy_cp := yy_last_accepting_cpos;
		yy_current_state := yy_last_accepting_state;
		goto next_action;



-- ^[ \r\t\f]+/"queued"[ \r\t\f\n] {
--         -- ignore "queued" at start of line as far as indenting
--         ECHO_L; 
--         if Debug_Indent and then Expecting_Indent then
--            Text_IO.Put(" [queued: indent off] ");
--         end if;
--         Expecting_Indent := False;  -- "then" will turn it back on
-- }
when 1 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 3;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 50 "sparkel_lex.l"

        -- ignore "is" at start of line as far as indenting
        ECHO_L; 


when 2 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 55 "sparkel_lex.l"

        -- this keyword when used at the beginning of a line
        -- is expected to be "outdented" relative to the preceding and
        -- following construct.  We want to treat it as though it
        -- it is the same indent as the prior construct that is just slightly
        -- more indented than this keyword.
        -- However, if we are expecting an *indent* then we don't look
        -- at the stack, and just return an INDENT, while preserving
        -- the "expecting indent" flag.
        -- If not expecting an indent, then we generate zero or more
        -- OUTDENTs and one NEWLINE if it is outdented relative to
        -- the top of the indent stack.  If not outdented relative to
        -- the top of the indent stack, we don't produce anything extra.

    declare
        YYT : constant String := yytext;
        Exports_Length : constant := 7; --  "exports"'Length
    begin
        pragma Assert (Col_Count = 0);

        --  Start of line, determine indent
        ECHO_L(YYT(YYT'First .. YYT'Last - Exports_Length)); 

        --  Put "exports" back
        for I in reverse YYT'Last - Exports_Length + 1 .. YYT'Last loop
           unput(YYT(I));
        end loop;

        if Col_Count = 0 then
           ENTER(RESCANNING);
        end if;

        --  At this point, Col_Count is indent level

        if Expecting_Indent then
           yylval := Create_Token(Text => "");
           if Debug_Indent then
              Text_IO.Put_Line(" [returning INDENT] ");
              Text_IO.Flush;
           end if;
           --  Preserve indent expectation
           Expecting_Indent := True;
           return INDENT;
        elsif Top = 0 then
           --  No indents on stack yet
           --  This shouldn't happen.
           yyerror("Source file cannot start with this token");
        elsif Col_Count >= Indent_Stack(Top) then
           --  Indenting relative to remembered stack
           --  Do nothing
           null;
        elsif Top = 1 then
           --  This is unexpected; should be at least two
           --  Do nothing
           null;
        elsif Col_Count >= Indent_Stack(Top-1) then
           --  See where we stand relative to the next indent level.
           --  We are not more outdented than next level, so return NEWLINE
           yylval := Create_Token(Text => "");
           if Debug_Indent then
              Text_IO.Put_Line(" [returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           return NEWLINE;
        else
           --  Outdenting relative to remembered indent;
           --  we will set Col_Match_Expected to False so we
           --  won't complain about a col-count mismatch.
           pragma Assert (Col_Count < Indent_Stack (Top-1));

           Col_Match_Expected := False;

           if Debug_Indent then
              Text_IO.Put_Line(" [entering OUTDENTING; returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           ENTER(OUTDENTING);
           yylval := Create_Token(Text => "");
           return NEWLINE;
        end if;
        if Debug_Indent and then Expecting_Indent then
           Text_IO.Put(" [NL: indent off] ");
        end if;
        Expecting_Indent := False;
    end;


when 3 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 142 "sparkel_lex.l"

        -- ignore "new", "then", etc. at start of line as far as indenting
        -- but return a NEWLINE if not expecting an INDENT
    declare
        YYT : constant String := yytext;
    begin

        pragma Assert (Col_Count = 0);

        for I in reverse YYT'Range loop
           if YYT(I) <= ' ' then
              --  Echo the spaces at the front of the line
              ECHO_L(YYT(YYT'First .. I));
              exit;
           end if;
           --  Unput the non-space characters
           unput(YYT(I));
        end loop;

        if Col_Count = 0 then
           --  Next time, return the token
           ENTER(RESCANNING);
        end if;

        if not Expecting_Indent then
           yylval := Create_Token(Text => "");
           return NEWLINE;
        end if;
    end;


when 4 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 2;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 173 "sparkel_lex.l"

        -- Remember Expecting_Indent state, and return INDENT
        -- if expecting indent, but don't push new indent level on stack;
        -- return NEWLINE if not expecting an indent.
        Expecting_Indent_At_Label := Expecting_Indent;
        ECHO_L; 
        if Expecting_Indent then
            yylval := Create_Token(Text => "");
            if Debug_Indent then
               Text_IO.Put_Line(" [label: returning INDENT] "); Text_IO.Flush;
            end if;
            Expecting_Indent := True;
            return INDENT;
        else
            yylval := Create_Token(Text => "");
            return NEWLINE;
        end if;


when 5 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 4;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 192 "sparkel_lex.l"

        -- ignore "for" after "implements" at start of line as far as indenting
        ECHO_L; 
        ENTER(CHARLIT);


when 6 => 
--# line 198 "sparkel_lex.l"

    declare
        -- ignore spaces,Carriage returns,tabs,form feeds
        -- 
        -- determine indent (expanding tabs appropriately)
        -- compare to top of indent "stack"
        -- if less, emit OUTDENTs while popping from stack until find match
        --   (except ignore such a line if it starts with 
        --     "then"/"new"/"implements"/"exports"/"begin"/"||"/"*XXX*")
        --   * complain if new level does not match one already on stack
        -- if same, emit NEWLINE; leave stack as is.
        -- if indent is more than top of stack:
        --   * if prior line ends with ":", push indent on stack and emit INDENT
        --   * if prior line does *not* end with ":" do not push indent on stack

        YYT : constant String := yytext;
    begin

        pragma Assert (Col_Count = 0);

        if YYT(YYT'First) in 'a'..'z' then
           --  Indent is zero; put back characters
           for I in reverse YYT'Range loop
              unput(YYT(I));
           end loop;
           --  Next time, return the token
           ENTER(RESCANNING);
        else
           --  Start of line, determine indent
           ECHO_L; 
        end if;

        --  At this point, Col_Count is indent level

        if Top = 0 then
           --  No indents on stack yet
           Top := Top + 1;
           Indent_Stack(Top) := Col_Count;
           Bracketing_Token_Stack(Top) := Error;
           if Debug_Indent then
              Text_IO.Put_Line(" [pushing" & Integer'Image(Col_Count) &
                " at bottom of Indent_Stack] ");
              Text_IO.Flush;
           end if;
        elsif Col_Count > Indent_Stack(Top) then
           --  Indenting relative to remembered stack
           if Expecting_Indent then
              --  Indenting is only significant if
              --  preceded by ':'/is/of/then/else/loop
              Top := Top + 1;
              Indent_Stack(Top) := Col_Count;
              Bracketing_Token_Stack(Top) := Bracketing_Token;
              if Debug_Indent then
                 Text_IO.Put_Line(" [pushing" & Integer'Image(Col_Count) &
                   " on Indent_Stack] "); Text_IO.Flush;
              end if;
              yylval := Create_Token(Text => "");
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning INDENT] "); Text_IO.Flush;
              end if;
              return INDENT;
           end if;
        elsif Col_Count = Indent_Stack(Top) then
           --  Same indent, this is a "significant" newline
           yylval := Create_Token(Text => "");
           if Debug_Indent then
              Text_IO.Put_Line(" [returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           return NEWLINE;
        else
           --  Outdenting relative to remembered indent;
           --  we will pop indent-stack until we get a match
           pragma Assert (Col_Count < Indent_Stack (Top));

           --  tbd: convert last OUTDENT into a NEWLINE: Top := Top - 1;
           if Debug_Indent then
              Text_IO.Put_Line(" [entering OUTDENTING; returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           ENTER(OUTDENTING);
           yylval := Create_Token(Text => "");
           return NEWLINE;
        end if;
        if Debug_Indent and then Expecting_Indent then
           Text_IO.Put(" [NL: indent off] ");
        end if;
        Expecting_Indent := False;
    end;


when 7 => 
--# line 289 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ABSTRACT_kw);


when 8 => 
--# line 295 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CLASS_kw);


when 9 => 
--# line 301 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONCURRENT_kw);


when 10 => 
--# line 307 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (GENERIC_kw);


when 11 => 
--# line 313 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROTECTED_kw);


when 12 => 
--# line 319 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (END_kw);


when 13 => 
--# line 325 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 14 => 
--# line 331 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 15 => 
--# line 337 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 16 => 
--# line 343 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 17 => 
--# line 349 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IMPORT_kw);


when 18 => 
--# line 355 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WITH_kw);


when 19 => 
--# line 361 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (USE_kw);


when 20 => 
--# line 367 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (INTERFACE_kw);


when 21 => 
--# line 373 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PACKAGE_kw);


when 22 => 
--# line 379 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OP_kw);


  -- Sparkel reserved words
when 23 => 
--# line 386 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ABS_kw);


when 24 => 
--# line 391 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ABSTRACT_kw);


when 25 => 
--# line 396 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ACCESS_kw);


when 26 => 
--# line 401 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ALIASED_kw);


when 27 => 
--# line 406 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ALL_kw);


when 28 => 
--# line 411 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (AND_kw);


when 29 => 
--# line 416 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ARRAY_kw);


when 30 => 
--# line 421 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ASSERT_kw);


when 31 => 
--# line 426 "sparkel_lex.l"

        declare
           --  Remember state of "Expecting_Indent" before "begin"
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;  -- Restore Expecting_Indent

           if not Expecting_Indent
             and then (Bracketing_Token_Stack (Top) = DECLARE_kw
                or else Bracketing_Token_Stack (Top) = IS_kw)
           then
              --  This is a "begin" matching a "declare" or an "is"
              --  with some declarative part (i.e. normal case).
              --  Update the stacked bracketing token, and preserve
              --  expecting-indent as False.
              Bracketing_Token_Stack (Top) := BEGIN_kw;
           else
              --  This is a "naked" begin, or a "declare" or "is"
              --  immediately followed by a "begin".
              --  We are still expecting indent.
              --  Update the Bracketing_Token to be "BEGIN_kw"
              --  and make sure the Expecting_Indent is on.
              Expecting_Indent := True;
              Bracketing_Token := BEGIN_kw;
           end if;

           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (BEGIN_kw);
        end;


when 32 => 
--# line 460 "sparkel_lex.l"

        declare
           --  Preserve "Expecting_Indent" across "begin".
           --  Note that this cannot be a "naked" begin, since that
           --  isn't allowed at the top level.
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (BEGIN_kw);
        end;


when 33 => 
--# line 476 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := BLOCK_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (BLOCK_kw);


when 34 => 
--# line 486 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (BODY_kw);


when 35 => 
--# line 491 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CASE_kw);


when 36 => 
--# line 496 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CLASS_kw);


when 37 => 
--# line 501 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CLASS_kw);


when 38 => 
--# line 506 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONCURRENT_kw);


when 39 => 
--# line 511 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONST_kw);


when 40 => 
--# line 516 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONSTANT_kw);


when 41 => 
--# line 521 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONTINUE_kw);


when 42 => 
--# line 526 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := DECLARE_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (DECLARE_kw);


when 43 => 
--# line 536 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (DELTA_kw);


when 44 => 
--# line 541 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (DIGITS_kw);


when 45 => 
--# line 546 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EACH_kw);


when 46 => 
--# line 551 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := ELSE_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (ELSE_kw);


when 47 => 
--# line 561 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        yylval := Create_Token("elsif");
	yyerror("Use ""elsif"" rather than ""elseif""");
	return (ELSIF_kw);


when 48 => 
--# line 567 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        yylval := Create_Token("elsif");
        --  Allow "elif" as an alias for "elsif" for Python-like syntax
	return (ELSIF_kw);


when 49 => 
--# line 573 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        yylval := Create_Token("elsif");
	yyerror("Use ""elsif"" rather than ""else if""");
	return (ELSIF_kw);


when 50 => 
--# line 579 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ELSIF_kw);


when 51 => 
--# line 584 "sparkel_lex.l"

        unput('f'); unput('i');
	ECHO_L("end"); ENTER(CHARLIT); 
        yylval := Create_Token("end");
	yyerror("Use ""end if"" rather than ""endif""");
	return (END_kw);


when 52 => 
--# line 591 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (END_kw);


when 53 => 
--# line 596 "sparkel_lex.l"

        --  No need to preserve Expecting_Indent across exception
        --  since "exception" should never immediately follow a token
        --  that introduces a new level of indentation
        --  (unlike "new" or "then").
	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EXCEPTION_kw);


when 54 => 
--# line 605 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EXCEPTION_kw);


when 55 => 
--# line 610 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EXIT_kw);


when 56 => 
--# line 615 "sparkel_lex.l"

        declare
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (EXPORTS_kw);
        end;


when 57 => 
--# line 628 "sparkel_lex.l"

        declare
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (EXPORTS_kw);
        end;


when 58 => 
--# line 641 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EXTENDS_kw);


when 59 => 
--# line 646 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FOR_kw);


when 60 => 
--# line 651 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FORWARD_kw);


when 61 => 
--# line 656 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 62 => 
--# line 661 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 63 => 
--# line 666 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (GENERIC_kw);


when 64 => 
--# line 671 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (GLOBAL_kw);


when 65 => 
--# line 676 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IF_kw);


when 66 => 
--# line 681 "sparkel_lex.l"

	ECHO_L; ENTER(AFTER_IMPLEMENTS); 
        --  TBD: We might want to return a NEWLINE first.
	yylval := Create_Token;
	return (IMPLEMENTS_kw);


when 67 => 
--# line 687 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IMPORT_kw);


when 68 => 
--# line 692 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IN_kw);


when 69 => 
--# line 697 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (INTERFACE_kw);


when 70 => 
--# line 702 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := IS_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (IS_kw);


when 71 => 
--# line 712 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (LAMBDA_kw);


when 72 => 
--# line 717 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (LIMITED_kw);


when 73 => 
--# line 722 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (LOCKED_kw);


when 74 => 
--# line 727 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := LOOP_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (LOOP_kw);


when 75 => 
--# line 737 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (MOD_kw);


when 76 => 
--# line 742 "sparkel_lex.l"

        declare
           --  Preserve "Expecting_Indent" across "new"
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (NEW_kw);
        end;


when 77 => 
--# line 756 "sparkel_lex.l"

        declare
           --  Preserve "Expecting_Indent" across "new"
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (NEW_kw);
        end;


when 78 => 
--# line 770 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (NOT_kw);


when 79 => 
--# line 775 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (NULL_kw);


when 80 => 
--# line 780 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := OF_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (OF_kw);


when 81 => 
--# line 790 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OP_kw);


when 82 => 
--# line 795 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OPTIONAL_kw);


when 83 => 
--# line 800 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OR_kw);


when 84 => 
--# line 805 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OTHERS_kw);


when 85 => 
--# line 810 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OUT_kw);


when 86 => 
--# line 815 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PACKAGE_kw);


when 87 => 
--# line 820 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PARALLEL_kw);


when 88 => 
--# line 825 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PRAGMA_kw);


when 89 => 
--# line 830 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PRIVATE_kw);


when 90 => 
--# line 835 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 91 => 
--# line 840 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 92 => 
--# line 845 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROTECTED_kw);


when 93 => 
--# line 850 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (QUEUED_kw);


when 94 => 
--# line 855 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (RAISE_kw);


when 95 => 
--# line 860 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (RANGE_kw);


when 96 => 
--# line 865 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := RECORD_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (RECORD_kw);


when 97 => 
--# line 875 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (REF_kw);


when 98 => 
--# line 880 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (REM_kw);


when 99 => 
--# line 885 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (RENAMES_kw);


when 100 => 
--# line 890 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (RETURN_kw);


when 101 => 
--# line 895 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (REVERSE_kw);


when 102 => 
--# line 900 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (SOME_kw);


when 103 => 
--# line 905 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (SUBTYPE_kw);


when 104 => 
--# line 910 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (TAGGED_kw);


when 105 => 
--# line 915 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := THEN_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (THEN_kw);


when 106 => 
--# line 925 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := THEN_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (THEN_kw);


when 107 => 
--# line 935 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (TYPE_kw);


when 108 => 
--# line 940 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (UNTIL_kw);


when 109 => 
--# line 945 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (USE_kw);


when 110 => 
--# line 950 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (VAR_kw);


when 111 => 
--# line 955 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WHEN_kw);


when 112 => 
--# line 960 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WHILE_kw);


when 113 => 
--# line 965 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WITH_kw);


when 114 => 
--# line 970 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (XOR_kw);


  -- Match all the compound Sparkel delimiters. 
when 115 => 
--# line 977 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(COMPARE);


when 116 => 
--# line 982 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(EQ);


when 117 => 
--# line 987 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(NEQ);


when 118 => 
--# line 992 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(GEQ);


when 119 => 
--# line 997 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(LEQ);


when 120 => 
--# line 1002 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(LSHIFT);


when 121 => 
--# line 1007 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(POWER);


when 122 => 
--# line 1012 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(ASSIGN);


when 123 => 
--# line 1017 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(MOVE);


when 124 => 
--# line 1022 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(SWAP);


when 125 => 
--# line 1027 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(BOX);


when 126 => 
--# line 1032 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(DOT_DOT);


when 127 => 
--# line 1037 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(OPEN_INTERVAL);


when 128 => 
--# line 1042 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(OPEN_CLOSED_INTERVAL);


when 129 => 
--# line 1047 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(CLOSED_OPEN_INTERVAL);


when 130 => 
--# line 1052 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(REFERS_TO);


when 131 => 
--# line 1057 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(GIVES);


when 132 => 
--# line 1062 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(IMPLIES);


when 133 => 
--# line 1067 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PARALLEL);


when 134 => 
--# line 1072 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PARALLEL);


when 135 => 
--# line 1077 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PLUS_ASSIGN);


when 136 => 
--# line 1082 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(MINUS_ASSIGN);


when 137 => 
--# line 1087 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(TIMES_ASSIGN);


when 138 => 
--# line 1092 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(DIVIDE_ASSIGN);


when 139 => 
--# line 1097 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(POWER_ASSIGN);


when 140 => 
--# line 1102 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(COMBINE_ASSIGN);


when 141 => 
--# line 1107 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(AMPERSAND_ASSIGN);


when 142 => 
--# line 1112 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(COMBINE_MOVE);


when 143 => 
--# line 1117 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(AND_ASSIGN);


when 144 => 
--# line 1122 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(OR_ASSIGN);


when 145 => 
--# line 1127 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(XOR_ASSIGN);


when 146 => 
--# line 1132 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(LSHIFT_ASSIGN);


when 147 => 
--# line 1137 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(RSHIFT_ASSIGN);


when 148 => 
--# line 1142 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PLUS_BASED_OP);


  -- Match all the Sparkel single-character delimiters.
when 149 => 
--# line 1149 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(PRIME);


when 150 => 
--# line 1154 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('(');


when 151 => 
--# line 1159 "sparkel_lex.l"

	ECHO_L; ENTER(TICK); 
	yylval := Create_Token;
	return(')');


when 152 => 
--# line 1164 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('[');


when 153 => 
--# line 1169 "sparkel_lex.l"

	ECHO_L; ENTER(TICK); 
	yylval := Create_Token;
	return(']');


when 154 => 
--# line 1174 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('<');


when 155 => 
--# line 1179 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('>');


when 156 => 
--# line 1184 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(L_ASSERT);  --  or L_SET in PARython mode


when 157 => 
--# line 1189 "sparkel_lex.l"
  --  Allow > ... < so PARython can use  ...  for sets/maps
	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(L_ASSERT);


when 158 => 
--# line 1194 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(R_ASSERT);  --  or R_SET in PARython mode


when 159 => 
--# line 1199 "sparkel_lex.l"
  --  Allow > ... < so PARython can use  ...  for sets/maps
	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(R_ASSERT);


when 160 => 
--# line 1204 "sparkel_lex.l"

        declare
           --  Remember Expecting_Indent
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           if Expecting_Indent_At_Label then
              if not Old_Indent then
                 --  Seen '*' twice; set Expecting_Indent back on
                 Expecting_Indent_At_Label := False;
                 Expecting_Indent := True;
                 if Debug_Indent then
                    Text_IO.Put(" [indent on] ");
                 end if;
              end if;
           end if;
	   return ('*');
        end;


when 161 => 
--# line 1224 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('+');


when 162 => 
--# line 1229 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(',');


when 163 => 
--# line 1234 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('-');


when 164 => 
--# line 1239 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('.');


when 165 => 
--# line 1244 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('/');


when 166 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1249 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
        Bracketing_Token := ':';
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return(EOL_COLON);


when 167 => 
--# line 1259 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(':');


when 168 => 
--# line 1264 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(';');


when 169 => 
--# line 1269 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('|');


when 170 => 
--# line 1274 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('&');


when 171 => 
--# line 1279 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('?');


when 172 => 
--# line 1284 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('=');


  -- The following is used to match all valid Sparkel identifiers
  -- except reserved words. Note that leading digits and underscores
  -- are not allowed and that double underscores are not allowed.
when 173 => 
--# line 1294 "sparkel_lex.l"

	ECHO_L; ENTER(TICK);
	yylval := Create_Token;
	return(Identifier);


  -- Enumeration literals
when 174 => 
--# line 1301 "sparkel_lex.l"

	ECHO_L; ENTER(TICK);
	yylval := Create_Token;
	return(Enum_Literal);


  -- Decimal numeric literals
when 175 => 
--# line 1308 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(Integer_Literal);


when 176 => 
--# line 1314 "sparkel_lex.l"

      ECHO_L; ENTER(CHARLIT);
      yylval := Create_Token;
      return(Real_Literal);


  -- Based numeric literals.
when 177 => 
--# line 1322 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(Integer_Literal);


when 178 => 
--# line 1328 "sparkel_lex.l"

      ECHO_L; ENTER(CHARLIT);
      yylval := Create_Token;
      return(Real_Literal);


when 179 => 
--# line 1334 "sparkel_lex.l"

      ECHO_L; ENTER(CHARLIT); 
      yylval := Create_Token;
      return(Integer_Literal);


when 180 => 
--# line 1340 "sparkel_lex.l"

      ECHO_L; ENTER(CHARLIT); 
      yylval := Create_Token;
      return(Integer_Literal);


  -- Match all valid character literals.  See Ada LRM 2.6.
when 181 => 
--# line 1348 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(Char_Literal);


  -- Match all valid string literals.  See Ada LRM 2.6.
when 182 => 
--# line 1356 "sparkel_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        declare
           Tok : constant String := yytext;
           Quote : constant String := """";
        begin
           yylval := Create_Token (Tok);
           if Tok (Tok'Last) /= Quote(1) then
              yyerror ("unterminated string", At_Token => yylval);
           end if;
           return(String_Literal);
        end;


  -- Handle white space --
when 183 => 
--# line 1372 "sparkel_lex.l"
ECHO_L; -- ignore white space and comments to end-of-line

when 184 => 
--# line 1374 "sparkel_lex.l"

        --  Not start of line (or whole line); no need to keep track
        pragma Assert (Col_Count > 0);
        ECHO_L;


when 185 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1381 "sparkel_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 186 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1391 "sparkel_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 187 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1401 "sparkel_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 188 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1411 "sparkel_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 189 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1421 "sparkel_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 190 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1431 "sparkel_lex.l"

        --  Ignore outdent for label
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 191 => 
--# line 1441 "sparkel_lex.l"

        --  Return another OUTDENT
        declare
           Do_Match_Check : Boolean := True;
        begin
           unput(yytext(1));
           if Top > 1 and then Col_Count < Indent_Stack(Top)
             and then (Col_Match_Expected
               or else Col_Count < Indent_Stack(Top-1))
           then
              --  Not yet reached a matching indent;
              --  Pop the stack
              if Debug_Indent then
                 Text_IO.Put_Line(" [popping" &
                   Integer'Image(Indent_Stack(Top)) &
                   " from Indent_Stack] ");
                 Text_IO.Flush;
              end if;
              Top := Top - 1;
              if Col_Count >= Indent_Stack(Top)
                or else not Col_Match_Expected
                or else Bracketing_Token_Stack(Top + 1) = ':'
                or else Bracketing_Token_Stack(Top + 1) = REFERS_TO
              then
                 --  Don't check for indent match this time;
                 --  wait til next time since only one outdent occurring,
                 --  or ":" or "=>" used at end of line (which allows multiple
                 --  outdents at a time).
                 Do_Match_Check := False;
              end if;
           end if;

           if Do_Match_Check then
              --  Found (nearly) matching indent
              if Debug_Indent then
                 Text_IO.Put_Line(" [exiting OUTDENTING] ");
                 Text_IO.Flush;
              end if;
              if Col_Count = 0 then
                 --  Return the token at the beginning of the line
                 ENTER(RESCANNING);
              else
                 ENTER(CHARLIT);
              end if;
              if Col_Count /= Indent_Stack(Top)
                and then Col_Match_Expected
              then
                 --  Not quite matching
                 Parser_Warning("indent mismatch; expected indent of" &
                   Integer'Image(Indent_Stack(Top)) & ", found" &
                   Integer'Image(Col_Count));

                 --  Force a match
                 --  TBD: Not sure this is the right choice
                 if Top = 1 then
                    Top := Top + 1;
                    if Debug_Indent then
                       Text_IO.Put_Line(" [pushing" &
                         Integer'Image(Col_Count) &
                         " on Indent_Stack to force a match] ");
                       Text_IO.Flush;
                    end if;
                 else
                    if Debug_Indent then
                       Text_IO.Put_Line(" [setting top of Indent_Stack to" &
                         Integer'Image(Col_Count) & "] "); Text_IO.Flush;
                    end if;
                 end if;
                 Indent_Stack(Top) := Col_Count;
              end if;
           end if;
           yylval := Create_Token(Text => "");
           if Do_Match_Check then
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning NEWLINE after OUTDENTs] ");
                 Text_IO.Flush;
              end if;
              return NEWLINE;
           else
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning OUTDENT] ");
                 Text_IO.Flush;
              end if;
              return OUTDENT;
           end if;
        end;


when YY_END_OF_BUFFER +CHARLIT + 1 
 |
YY_END_OF_BUFFER +TICK + 1 
 |
YY_END_OF_BUFFER +AFTER_IMPLEMENTS + 1 
 |
YY_END_OF_BUFFER +INITIAL + 1 
 =>
--# line 1529 "sparkel_lex.l"

        if Top = 0 then
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [EOF: indent off] "); Text_IO.Flush;
           end if;
           Expecting_Indent := False;
           if Debug_Indent then
              Text_IO.Put(" [returning EOF] "); Text_IO.Flush;
           end if;
           return End_Of_Input;
        else
           unput(YY_END_OF_BUFFER_CHAR);
           Col_Count := Indent_Stack(1);
           if Debug_Indent then
              Text_IO.Put_Line(" [popping" & Integer'Image(Indent_Stack(Top)) &
                " from Indent_Stack] ");
              Text_IO.Flush;
           end if;
           Top := Top - 1;
           if Top > 0 then
              if Debug_Indent then
                 Text_IO.Put_Line(" [entering EOF OUTDENTING] ");
                 Text_IO.Flush;
              end if;
              ENTER(OUTDENTING);
           else
              --  This is a significant NEWLINE
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning NEWLINE] ");
                 Text_IO.Flush;
              end if;
              yylval := Create_Token(Text => "");
              return NEWLINE;
           end if;
        end if;


when YY_END_OF_BUFFER +OUTDENTING + 1 
 =>
--# line 1566 "sparkel_lex.l"

        --  Return another OUTDENT
        unput(YY_END_OF_BUFFER_CHAR);
        if Debug_Indent then
           Text_IO.Put_Line(" [popping" & Integer'Image(Indent_Stack(Top)) &
             " from Indent_Stack] ");
           Text_IO.Flush;
        end if;
        Top := Top - 1;
        if Top = 0 then
           --  All done
           if Debug_Indent then
              Text_IO.Put_Line(" [exiting EOF OUTDENTING] ");
              Text_IO.Flush;
           end if;
           ENTER(CHARLIT);
        end if;

        yylval := Create_Token(Text => "");
        if Debug_Indent then
           Text_IO.Put_Line(" [returning EOF OUTDENT] ");
           Text_IO.Flush;
        end if;
        return OUTDENT;


  -- The following matches all new lines (and the preceding white space).
when 194 => 
--# line 1595 "sparkel_lex.l"

        --  TBD: Should we return NEWLINE if this line is entirely blank?
        if Echo_Input then
           text_io.new_line;
        end if;
        Display_Linenum;


  -- The following matches everything else and prints an error message
  -- indicating that something unexpected was found.
when 195 => 
--# line 1606 "sparkel_lex.l"
ECHO_L; 
	    yyerror("lexical error: '" &
	      Sparkel_lex_dfa.yytext & "'");


when 196 => 
--# line 1611 "sparkel_lex.l"
raise AFLEX_SCANNER_JAMMED;
when YY_END_OF_BUFFER + RESCANNING + 1 => 
    return End_Of_Input;
                when YY_END_OF_BUFFER =>
                    -- undo the effects of YY_DO_BEFORE_ACTION
                    yy_ch_buf(yy_cp) := yy_hold_char;

                    yytext_ptr := yy_bp;

                    case yy_get_next_buffer is
                        when EOB_ACT_END_OF_FILE =>
                            begin
                            if ( yywrap ) then
                                -- note: because we've taken care in
                                -- yy_get_next_buffer() to have set up yytext,
                                -- we can now set up yy_c_buf_p so that if some
                                -- total hoser (like aflex itself) wants
                                -- to call the scanner after we return the
                                -- End_Of_Input, it'll still work - another
                                -- End_Of_Input will get returned.

                                yy_c_buf_p := yytext_ptr;

                                yy_act := YY_STATE_EOF((yy_start - 1) / 2);

                                goto do_action;
                            else
                                --  start processing a new file
                                yy_init := true;
                                goto new_file;
                            end if;
                            end;
                        when EOB_ACT_RESTART_SCAN =>
                            yy_c_buf_p := yytext_ptr;
                            yy_hold_char := yy_ch_buf(yy_c_buf_p);
                        when EOB_ACT_LAST_MATCH =>
                            yy_c_buf_p := yy_n_chars;
                            yy_current_state := yy_get_previous_state;

                            yy_cp := yy_c_buf_p;
                            yy_bp := yytext_ptr;
                            goto next_action;
                        when others => null;
                        end case; -- case yy_get_next_buffer()
                when others =>
                    text_io.put( "action # " );
                    text_io.put( INTEGER'IMAGE(yy_act) );
                    text_io.new_line;
                    raise AFLEX_INTERNAL_ERROR;
            end case; -- case (yy_act)
        end loop; -- end of loop waiting for end of file
end YYLex;
--# line 1611 "sparkel_lex.l"

end Sparkel_lex;


